<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="03장. 저장소와 검색" /><meta name="author" content="Bae Sangwoo" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자." /><meta property="og:description" content="데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자." /><link rel="canonical" href="https://bswsw.github.io/posts/designing-data-chapter3/" /><meta property="og:url" content="https://bswsw.github.io/posts/designing-data-chapter3/" /><meta property="og:site_name" content="bveloper" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-22T01:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="03장. 저장소와 검색" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Bae Sangwoo" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Bae Sangwoo"},"dateModified":"2024-11-22T01:00:00+09:00","datePublished":"2024-11-22T01:00:00+09:00","description":"데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자.","headline":"03장. 저장소와 검색","mainEntityOfPage":{"@type":"WebPage","@id":"https://bswsw.github.io/posts/designing-data-chapter3/"},"url":"https://bswsw.github.io/posts/designing-data-chapter3/"}</script><title>03장. 저장소와 검색 | bveloper</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="bveloper"><meta name="application-name" content="bveloper"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/bveloper.jpeg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">bveloper</a></div><div class="site-subtitle font-italic">bveloper</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/bswsw" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['baegoony','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>03장. 저장소와 검색</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="https://wikibook.co.kr/images/cover/l/9791158393601.jpg" class="preview-img bg" alt="Preview Image" data-proofer-ignore><h1 data-toc-skip>03장. 저장소와 검색</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/bswsw">BAE SANGWOO</a> </em></div><div class="d-flex"><div> <span> 게시 <em class="timeago" data-ts="1732204800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-11-22 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4627 단어"> <em>25 분</em>읽는 시간</span></div></div></div><div class="post-content"><blockquote><p>데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자.</p></blockquote><h2 id="0-개발자가-주의해야하는-이유"><span class="mr-2">0. 개발자가 주의해야하는 이유</span><a href="#0-개발자가-주의해야하는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>사용 가능한 여러 저장소 엔진 중에 어플리케이션에 적합한 엔진을 선택하는 것이 필요<li>특정 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있음 (트랜잭션 / 분석)<li>관계형 vs NoSQL</ul><h2 id="1-데이터베이스를-강력하게-만드는-데이터-구조"><span class="mr-2">1. 데이터베이스를 강력하게 만드는 데이터 구조</span><a href="#1-데이터베이스를-강력하게-만드는-데이터-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="10-색인"><span class="mr-2">1.0. 색인</span><a href="#10-색인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요 -&gt; <em>색인</em><li>색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것<ul><li>이정표 역할을 하여 원하는 데이터의 위치를 찾는데 도움을 줌</ul><li>기본 데이터에서 파생된 추가적인 구조<li>트레이드 오프<ul><li>색인을 잘 설계하여 읽기 성능의 향상<li>색인의 구조에 따라 데이터 쓰기 성능 하락<li>어플리케이션에서 질의 패턴을 이해하고 개발자와 DBA가 잘 협의하여 결정</ul></ul><h3 id="11-해시-색인"><span class="mr-2">1.1. 해시 색인</span><a href="#11-해시-색인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>키-값 색인<li>매우 일반적이고 복잡한 색인을 위한 구성 요소로 유용<li>사전 타입과 유사<li>해시맵, 해시테이블</ul><h4 id="111-파일에-추가하는-전략"><span class="mr-2">1.1.1. 파일에 추가하는 전략</span><a href="#111-파일에-추가하는-전략" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략<li>새로운 키-값을 추가할 때마다 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야함<li>값을 조회하려면 해시맵을 이용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽음<li><a href="https://en.wikipedia.org/wiki/Bitcask">비트캐스크 (Bitcask)</a><ul><li>키를 저장하고 검색하기 위한 API를 제공하는 Erlang 어플리케이션<li>해시맵을 전부 메모리에 유지하기 때문에 램에 모든 키가 저장된다는 조건을 전제로 고성능 쓰기, 읽기 가능<li>한 번의 디스크 탐색으로 디스크에서 적재할 수 있기 때문에 사용 가능 메모리보다 더 많은 공간 사용 가능<li>데이터 파일의 일부가 이미 파일 시스템 캐시에 있다면 읽기에 디스크 입출력이 필요하지 않음</ul><li>각 키의 값이 자주 갱신되는 상황에 적합<li>파일에 항상 추가만 한다면 결국 디스크 공간이 부족해짐</ul><h4 id="112-세그먼트-로그"><span class="mr-2">1.1.2. 세그먼트 로그</span><a href="#112-세그먼트-로그" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>특정 크기의 세그먼트로 로그를 나누는 방식<li>특정 크기의 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓰기 수행<li>컴팩션(compaction): 중복 키를 버리고 최신 갱신값만 유지<li>동시의 여러 세그먼트의 컴팩션이 가능<li>세그먼트가 쓰여진 후 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일에 수행<li>고정된 세그먼트 병합과 컴팩션은 백그라운드 스레드에서 수행<li>병합 후 병합된 세그먼트로 사용을 전환하고 이전 세그먼트 파일은 삭제<li>키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖음<li>키를 찾을 대 최신화된 순으로 세그먼트 해시맵을 확인<li>병합으로 적은 세그먼트 수를 유지하여 많은 해시맵을 확인할 필요 없음</ul><h4 id="113-실제-구현에서-중요한-문제"><span class="mr-2">1.1.3. 실제 구현에서 중요한 문제</span><a href="#113-실제-구현에서-중요한-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>파일 형식<li>레코드 삭제<li>고장 복구<li>부분적으로 레코드 쓰기<li>동시성 제어</ul><h4 id="114-제한-사항"><span class="mr-2">1.1.4. 제한 사항</span><a href="#114-제한-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>메모리에 저장하기 대문에 키가 너무 많으면 문제가 됨<ul><li>디스크를 사용하면?<ul><li>성능 이슈<li>확장 비용 이슈<li>해시 충돌 이슈</ul></ul><li>범위 질의에 효율적이지 않음<ul><li>개별 키 조회 필요</ul></ul><h3 id="12-ss-테이블과-lsm-트리"><span class="mr-2">1.2. SS 테이블과 LSM 트리</span><a href="#12-ss-테이블과-lsm-트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="121-ss-테이블"><span class="mr-2">1.2.1. SS 테이블</span><a href="#121-ss-테이블" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>정렬된 문자열 테이블 (Sorted String Table)<li>각 키는 병합된 세그먼트 파일 내에 한 번만 나타나야함<li>장점 (vs 해시 색인)<ul><li>정렬된 순서로 세그먼트를 병합하고 새로운 세그먼트 파일도 키로 정렬되어 있음<li>파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없음<ul><li>정렬이 되어 있기 때문에 특정 키의 오프셋만 알고 있으면 대략적인 위치를 알 수 있음</ul><li>읽기 요청은 요청 범위 내에서 여러 키값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축하여 색인의 각 항목은 압축된 블록의 시작을 가르킴<ul><li>디스크 공간을 절약하고 압축은 I/O 대역폭 사용도 줄임</ul></ul></ul><h4 id="122-ss-테이블-생성과-유지"><span class="mr-2">1.2.2. SS 테이블 생성과 유지</span><a href="#122-ss-테이블-생성과-유지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>메모리에 정렬된 구조를 저장<li>레드 블랙 트리 / AVL 트리<ul><li>임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있음</ul><li>쓰기가 들어오면 인메모리 균형 트리 데이터구조에 추가<ul><li>멤테이블 (memtable)</ul><li>멤테이블이 커지면 SS테이블 파일로 디스크에 기록<ul><li>멤테이블이 이미 정렬된 키값쌍을 유지하고 있기 때문에 효율적으로 수행 가능<li>새로운 SS테이블 파일은 가장 최신 세그먼트가 됨<li>디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록</ul><li>읽기 요청하면 멤테이블에서 키를 찾음 -&gt; 디스크 최신 세그먼트 순서<li>가끔 세그먼트 병합, 컴팩션을 백그라운드에서 수행<li>데이터베이스가 고장나면 디스크로 기록되지 않은 최신 쓰기가 손실됨<ul><li>매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크에 유지해야함<li>복원할 때만 필요하기 때문에 순서 정렬 필요 없음<li>멤테이블을 SS테이블에 기록하면 해당 로그는 버릴 수 있음</ul></ul><h4 id="123-ss-테이블에서-lsm-트리-만들기"><span class="mr-2">1.2.3. SS 테이블에서 LSM 트리 만들기</span><a href="#123-ss-테이블에서-lsm-트리-만들기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>LSM 트리<ul><li>로그 구조화 병합 트리 (Log Structured Merge Tree)<li>정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진 -&gt; LSM 저장소 엔진</ul><li>루씬(Lucene)<ul><li>엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진<li>용어 사전을 저장하기 위한 방법으로 LSM 트리 사용<li>키(용어) - 값(문서의 ID / 포스팅 목록)<li>용어와 포스팅 목록의 매핑은 SS 테이블 같은 정렬 파일에 유지<li>필요에 따라 백그라운드에서 병합</ul></ul><h4 id="124-성능-최적화"><span class="mr-2">1.2.4. 성능 최적화</span><a href="#124-성능-최적화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>블룸 필터 (Bloom filter)<li>크기 계층 (Size Tiered)<li>레벨 컴팩션 (Leveled Compaction)</ul><h3 id="13-b-트리"><span class="mr-2">1.3. B 트리</span><a href="#13-b-트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>거의 대부분의 관계형 데이터베이스에서 표준 색인 구현으로 사용<li>많은 비관계형 데이터베이스에서도 사용<li>정렬된 키값 쌍을 유지하여 키값 검색과 범위 질의에 효율적<li>4KB의 고정 크기 블록이나 페이지로 세그먼트를 나누고 한 번에 하나의 페이지에 읽기/쓰기 수행<li>디스크가 고정 크기 블록으로 배열되기 때문에 하드웨어와 밀접한 관련이 있음<li>각 페이지는 주소나 위치를 이용해 식별 -&gt; 하나의 페이지가 다른 페이지를 참조할 수 있음<li>색인에서 키를 찾기 시작하는 루트가 존재함<li>페이지는 여러 키와 하위 페이지의 참조 포함<li>각 하위 페이지는 키가 계속 이어지는 범위를 담당<li>참조 사이의 키는 해당 범위 경계가 어디인지 나타냄</ul><h4 id="131-신뢰할-수-있는-b-트리-만들기"><span class="mr-2">1.3.1. 신뢰할 수 있는 B 트리 만들기</span><a href="#131-신뢰할-수-있는-b-트리-만들기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 씀<li>데이터베이스 고장 상황에서 스스로 복구할 수 있게 만들려면 디스크 상에 쓰기 전 로그를 추가해 B 트리 구현<li>동시성 제어는 래치 (가벼운 잠금) 로 트리의 데이터 구조를 보호</ul><h4 id="132-b-트리-최적화"><span class="mr-2">1.3.2. B 트리 최적화</span><a href="#132-b-트리-최적화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>페이지 덮어 쓰기와 고장 복구를 위해 쓰기 시 복사 방식을 사용<ul><li>변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 함<li>동시성 제어에도 유용</ul><li>페이지에 전체 키를 저장하지 않고 축약하여 공간 절약<ul><li>패이지 하나에 키를 더 많이 채우면 더 높은 분기 계수를 얻어 트리 깊이 수준을 낮을 수 있음 (B+ 트리)</ul><li>리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도<ul><li>트리가 커지면 순서 유지에 어려움이 있음<li>LSM 트리는 병합 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기 더쉬움</ul><li>트리에 포인터를 추가하여 양쪽 형제 페이지에 대한 참조를 가져 상위로 가지 않고 순서대로 키를 스캔할 수 있음</ul><h4 id="133-b-트리와-lsm-트리-비교"><span class="mr-2">1.3.3. B 트리와 LSM 트리 비교</span><a href="#133-b-트리와-lsm-트리-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>구현 성숙도: B트리<li>쓰기: LSM 트리<li>읽기: B트리<li>어플리케이션에서 필요한 부하를 주고 적절하게 필요한 저장소 엔진을 선택해야함</ul><h3 id="14-기타-색인"><span class="mr-2">1.4. 기타 색인</span><a href="#14-기타-색인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>기본키 색인<li>보조 색인<li>클러스터드 색인<li>커버링 색인<li>다중 컬럼 색인<li>전문 검색과 퍼지 색인</ul><h2 id="2-트랜잭션-처리나-분석"><span class="mr-2">2. 트랜잭션 처리나 분석?</span><a href="#2-트랜잭션-처리나-분석" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>트랜잭션<ul><li>커머셜 트랜잭션: 판매, 공급 업체에 발주, 직원 급여 등<li>읽기, 쓰기 그룹 단위<li>트랜잭션이 반드시 ACID 속성을 가질 필요는 없음<li>지연 시간이 낮은 읽기아 쓰기를 가능하게 한다는 의미</ul><li>OLTP<ul><li>OnLine Transaction Processing<li>어플리케이션에서 색인을 사용해 적은 수의 레코드를 찾을 때<li>사용자 입력을 기반으로 삽입/갱신할 때</ul><li>OLAP<ul><li>OnLine Analytic Processing<li>많은 수의 레코드를 스캔해 해당 레코드의 일부 컬럼을 읽고 집계 통계를 계산할 때</ul></ul><h3 id="21-데이터-웨어하우징"><span class="mr-2">2.1. 데이터 웨어하우징</span><a href="#21-데이터-웨어하우징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>OLTP는 어플리케이션에 직접 사용되므로 높은 가용성과 낮은 지연 시간의 트랜잭션이 기대됨<li>다양한 분석 질의를 위해 OLTP를 <em>추출</em>하고 <em>변환</em>하고 데이터웨어 하우스에 <em>적재</em> -&gt; ETL</ul><h3 id="22-분석용-스키마-별-모양-스키마와-눈꽃송이-모양-스키마"><span class="mr-2">2.2. 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마</span><a href="#22-분석용-스키마-별-모양-스키마와-눈꽃송이-모양-스키마" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>별모양 스키마<li>대부분 데이터 웨어하우스는 별 모양 스키마 (star schema) 사용<li>사실 테이블 (fact table): 특정 시각에 발생한 이벤트<li>차원 테이블 (demension table): 이벤트의 속성을 나타냄 (육하원칙)<li>사실 테이블은 일부 데이터와 차원 테이블의 외래키 참조들을 가지고 있음<li>눈꽃송이 모양 스키마<ul><li>별 모양 스키마보다 더 정규화 되어 있음</ul></ul><h3 id="23-칼럼-지향-저장소"><span class="mr-2">2.3. 칼럼 지향 저장소</span><a href="#23-칼럼-지향-저장소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">SELECT</span>
	<span class="n">dim_date</span><span class="p">.</span><span class="n">weekday</span><span class="p">,</span> <span class="n">dim_product</span><span class="p">.</span><span class="n">category</span><span class="p">,</span>
	<span class="k">SUM</span> <span class="p">(</span><span class="n">fact_sales</span><span class="p">.</span><span class="n">quantity</span> <span class="p">)</span> <span class="k">AS</span> <span class="n">quantity_sold</span>
<span class="k">FROM</span> <span class="n">fact_sales</span>
	<span class="k">JOIN</span> <span class="n">dim_date</span> <span class="k">ON</span> <span class="n">fact_sales</span><span class="p">.</span><span class="n">date_key</span> <span class="o">=</span> <span class="n">dim_date</span><span class="p">.</span><span class="n">date_key</span>
	<span class="k">JOIN</span> <span class="n">dim_product</span> <span class="k">ON</span> <span class="n">fact_sales</span><span class="p">.</span><span class="n">product_sk</span> <span class="o">=</span> <span class="n">dim_product</span><span class="p">.</span><span class="n">product_sk</span>
<span class="k">WHERE</span>
	<span class="n">dim_date</span><span class="p">.</span><span class="nb">year</span> <span class="o">=</span> <span class="mi">2013</span> <span class="k">AND</span>
	<span class="n">dim_product</span><span class="p">.</span><span class="n">category</span> <span class="k">IN</span> <span class="p">(</span> <span class="s1">'Fresh fruit'</span> <span class="p">,</span> <span class="s1">'Candy'</span> <span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span>
	<span class="n">dim_date</span><span class="p">.</span><span class="n">weekday</span><span class="p">,</span> <span class="n">dim_product</span><span class="p">.</span><span class="n">category</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>OLTP<ul><li>row 지향 데이터 배치하고 한 row의 모든 값은 서로 인접하게 저장<li>문서 데이터베이스에서 전체 문서는 보통 하나의 연속된 바이트 열로 저장<li>위 쿼리 시 모든 컬럼을 포함한 로우를 메모리 적재하고 필터링해야하여 비효율적임</ul><li>데이터 웨어하우스의 사실 테이블은 100개 이상의 컬럼을 가지고 있지만 분석 질의에는 4~5개 컬럼만 사용함<li>컬럼 지향 저장소<ul><li>모든 값을 하나의 로우에 함께 저장하지 않고 컬럼별로 모든 값을 함께 저장<li>질의에 사용되는 컬럼만 읽고 구분 분석이 가능하여 작업량이 줄어듬</ul></ul><h4 id="231-컬럼-압축"><span class="mr-2">2.3.1. 컬럼 압축</span><a href="#231-컬럼-압축" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>100p: 데이터를 압축하면 디스크 처리량을 더 줄일 수 있다. ?????<li>컬럼 지향 저장소의 많은 값은 반복해서 나타날 수 있기 때문에 압축하기 좋음<li>비트맵 부호화 (bitmap encoding)<ul><li>컬럼에서 고유 값의 수는 로우 수에 비해 적음<li>n개의 고유 값을 가진 컬럼을 가져와 n개의 개별 비트맵으로 변환<li>고유값 하나가 하나의 비트맵이고 각 로우는 한 비트를 가짐<li>로우가 해당 값을 가지면 비트는 1, 아니면 0<li>n이 매우 작으면 로우당 하나의 비트로 저장 가능<li>n이 더 크면 대부분의 비트맵은 0이 더 많음 (희소 / sparse)<li>비트맵 색인은 데이터웨어하우스에서 일반적으로 사용되는 질의 종류에 매우 적합</ul></ul><h4 id="232-메모리-대역폭과-벡터화-처리"><span class="mr-2">2.3.2. 메모리 대역폭과 벡터화 처리</span><a href="#232-메모리-대역폭과-벡터화-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>데이터 웨어하우스 질의는 디스크로부터 메모리로 데이터를 가져오는 대역폭이 큰 병목<li>메인 메모리에서 CPU 캐시로 가는 대역폭을 효율적으로 사용하고 CPU 명령 처리 파이프라인에서 분기 예측 실패와 버블을 피하며 최신 CPU에서 단일 명령 다중 데이터 명령(SIMD)을 사용하게끔 신경써야함<li>컬럼 저장소 배치는 CPU 주기를 효율적으로 사용하기에 적합<ul><li>질의 엔진은 압축된 컬럼 데이터를 CPU L1 캐시에 덩어리로 나누어 가져오고 타이트 루프에서 반복<li>CPU는 함수 호출이 많이 필요한 코드나 각 레코드 처리를 위해 분기가 필요한 코드보다 타이트 루프를 훨씬 빨리 실행 가능<li>컬럼 압축을 사용하면 같은 양의 L1 캐시에 더 많은 로우를 저장할 수 있음<li>비트 AND, OR 같은 연산자는 압축된 컬럼 데이터 덩어리를 바로 연산할 수 있게 설계할 수 있음<li><em>벡터화 처리</em></ul></ul><h4 id="233-컬럼-저장소의-순서-정렬"><span class="mr-2">2.3.3. 컬럼 저장소의 순서 정렬</span><a href="#233-컬럼-저장소의-순서-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>로우가 저장되는 순서가 반드시 중요하지는 않고 삽입된 순서로 저장하는 방식이 가장 쉬움<li>SS 테이블에서 했던 것 처럼 순서를 도입해 색인 메커니즘으로 사용할 수도 있음<li>각 컬럼을 독립적으로 정렬할 수는 없음 -&gt; 동일한 로우를 알 수 없음<li>컬럼별로 저장되었지만 한번에 전체 로우를 정렬해야함<li>정렬된 순서가 있다면 컬럼 압축에 도움이 됨<li>기본 정렬 컬럼에 고유 값을 많이 포함하지 않는다면 정렬 후 기본 정렬 컬럼은 연속해서 같은 값이 길게 반복됨<li>첫 번째 정렬 키에서 압축 효과가 가장 강력하고 이후 정렬 키는 그보다 뒤섞여 있어 반복된 값이 그렇게 길지 않음<li>초반 정렬된 몇 개의 컬럼을 합축하는 것은 전체적으로 여전히 이득임</ul><h4 id="234-다양한-정렬-순서"><span class="mr-2">2.3.4. 다양한 정렬 순서</span><a href="#234-다양한-정렬-순서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>OLAP에서 여러 정렬 순서를 갖는 것은 OLTP에서 여러 2차 색인을 갖는 것과 약간 비슷<li>OLTP<ul><li>한 곳에 모든 로우를 유지하고 2차 색인은 포인터만 포함</ul><li>OLAP<ul><li>포인터가 없고 값을 포함한 컬럼만 존재</ul></ul><h4 id="235-컬럼-지향-저장소에-쓰기"><span class="mr-2">2.3.5. 컬럼 지향 저장소에 쓰기</span><a href="#235-컬럼-지향-저장소에-쓰기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>컬럼 지향 저장소는 일반적으로 읽기 질의를 더 빠르게 하지만 쓰기를 더 어렵게한다는 단점 존재<li>LSM 트리 처럼<ul><li>모든 쓰기를 인 메모리 저장소로 이동해 정렬된 구조에 추가하고 디스크에 쓸 준비를 함<li>인 메모리 저장소는 로우 지향, 컬럼 지향 인지 중요하지 않음<li>충분히 쓰기를 모으면 컬럼 파일에 병합하고 대량으로 새로운 파일에 기록</ul><li>질의는 디스크의 컬럼 데이터와 메모리의 최근 쓰기를 결합해야함<li>질의 최적화기는 이런 구별을 사용자에게 드러내지 않음</ul><h4 id="236-집계-데이터-큐브와-구체화-뷰"><span class="mr-2">2.3.6. 집계: 데이터 큐브와 구체화 뷰</span><a href="#236-집계-데이터-큐브와-구체화-뷰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>구체화 뷰<ul><li>자주 사용하는 일부 집계 (count, sum, …)를 캐시해둠<li>관계형 모델에서는 이런 캐시를 가상 뷰로 정의 (질의를 작성하는 단축키)<li>구체화 뷰(materialized view)는 디스크에 기록된 질의 결과의 복사본<li>원본 데이터를 변경하면 구체화 뷰 갱신이 필요해 쓰기 비용이 비쌈</ul><li>데이터 큐브 (OLAP 큐브)<ul><li>일반화된 구체화 뷰의 특별 사례<li>차원에 따라 특정 속성의 집계를 캐시함<li>특정 질의를 미리 계산했기 때문에 실제 질의 시 수행이 매우 빠름<li>특정 차원에 데이터가 존재하지 않으면 원시 데이터를 질의하는 것보다 유연성이 떨어짐<li>데이터 큐브와 같은 집계 값은 특정 질의에 대한 성능 향상에만 사용됨</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>Study</a>, <a href='/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%A4%EA%B3%84/'>데이터 중심 어플리케이션 설계</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/study/" class="post-tag no-text-decoration" >study</a> <a href="/tags/data/" class="post-tag no-text-decoration" >data</a> <a href="/tags/design/" class="post-tag no-text-decoration" >design</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=03장. 저장소와 검색 - bveloper&amp;url=https://bswsw.github.io/posts/designing-data-chapter3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=03장. 저장소와 검색 - bveloper&amp;u=https://bswsw.github.io/posts/designing-data-chapter3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://bswsw.github.io/posts/designing-data-chapter3/&amp;text=03장. 저장소와 검색 - bveloper" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/designing-data-chapter9/">09장. 일관성과 합의</a><li><a href="/posts/designing-data-chapter8/">08장. 분산 시스템의 골칫거리</a><li><a href="/posts/designing-data-chapter7/">07장. 트랜잭션</a><li><a href="/posts/designing-data-chapter6/">06장. 파티셔닝</a><li><a href="/posts/designing-data-chapter5/">05장. 복제</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/livestudy/">livestudy</a> <a class="post-tag" href="/tags/whiteship/">whiteship</a> <a class="post-tag" href="/tags/learningscala/">learningscala</a> <a class="post-tag" href="/tags/scala/">scala</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/data/">data</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/jpa/">jpa</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/designing-data-chapter2/"><div class="card-body"> <em class="timeago small" data-ts="1731135600" > 2024-11-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>02장. 데이터 모델과 질의 언어</h3><div class="text-muted small"><p> 소프트웨어에서 데이터를 저장, 표현, 조작하는 다양한 방법을 알아보자. 관계형 모델 문서 모델 그래프 기반 데이터 모델 1. 관계형 모델과 문서 모델 1.1. 관계형 모델 메인프레임 컴퓨터에서 수행된 비즈니스 데이터 처리, 트랜잭션 처리, 일괄처리를 하기 위해 사용됨. 개발자는 DB 내부 데이터 표현에 대해 ...</p></div></div></a></div><div class="card"> <a href="/posts/designing-data-chapter4/"><div class="card-body"> <em class="timeago small" data-ts="1732942800" > 2024-11-30 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>04장. 부호화와 발전</h3><div class="text-muted small"><p> Encoding and Evolution 데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자. 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다. 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있...</p></div></div></a></div><div class="card"> <a href="/posts/designing-data-chapter5/"><div class="card-body"> <em class="timeago small" data-ts="1733634000" > 2024-12-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>05장. 복제</h3><div class="text-muted small"><p> 복제를 위한 데이터 변경 처리에 대한 어려움을 알아보자 잘못될 수 있는 것과 잘못될 수 없는 것 사이의 주된 차이점은 잘못될 수 없는 것이 잘못됐을 때는 잘못을 파악하거나 고치는 것은 거의 불가능하다는 점이다. - 더글라스 애덤스, 대체로 무해함(1992) 0. 복제란? 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/designing-data-chapter2/" class="btn btn-outline-primary" prompt="이전 글"><p>02장. 데이터 모델과 질의 언어</p></a> <a href="/posts/designing-data-chapter4/" class="btn btn-outline-primary" prompt="다음 글"><p>04장. 부호화와 발전</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "bswsw/bswsw.github.io", "data-repo-id": "R_kgDOHbD5Uw", "data-category": "Announcements", "data-category-id": "DIC_kwDOHbD5U84CPetV", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "ko", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/bswsw">BAE SANGWOO</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/livestudy/">livestudy</a> <a class="post-tag" href="/tags/whiteship/">whiteship</a> <a class="post-tag" href="/tags/learningscala/">learningscala</a> <a class="post-tag" href="/tags/scala/">scala</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/data/">data</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/jpa/">jpa</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-153066340-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-153066340-1'); }); </script>
