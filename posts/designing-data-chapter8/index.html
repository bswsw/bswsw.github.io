<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="08장. 분산 시스템의 골칫거리" /><meta name="author" content="Bae Sangwoo" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="어떤 것이든지 잘못될 가능성이 있다면 잘못된다." /><meta property="og:description" content="어떤 것이든지 잘못될 가능성이 있다면 잘못된다." /><link rel="canonical" href="https://bswsw.github.io/posts/designing-data-chapter8/" /><meta property="og:url" content="https://bswsw.github.io/posts/designing-data-chapter8/" /><meta property="og:site_name" content="bveloper" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-02-09T13:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="08장. 분산 시스템의 골칫거리" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Bae Sangwoo" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Bae Sangwoo"},"dateModified":"2025-03-03T14:48:58+09:00","datePublished":"2025-02-09T13:00:00+09:00","description":"어떤 것이든지 잘못될 가능성이 있다면 잘못된다.","headline":"08장. 분산 시스템의 골칫거리","mainEntityOfPage":{"@type":"WebPage","@id":"https://bswsw.github.io/posts/designing-data-chapter8/"},"url":"https://bswsw.github.io/posts/designing-data-chapter8/"}</script><title>08장. 분산 시스템의 골칫거리 | bveloper</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="bveloper"><meta name="application-name" content="bveloper"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/bveloper.jpeg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">bveloper</a></div><div class="site-subtitle font-italic">bveloper</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/bswsw" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['baegoony','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>08장. 분산 시스템의 골칫거리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="https://wikibook.co.kr/images/cover/l/9791158393601.jpg" class="preview-img bg" alt="Preview Image" data-proofer-ignore><h1 data-toc-skip>08장. 분산 시스템의 골칫거리</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/bswsw">BAE SANGWOO</a> </em></div><div class="d-flex"><div> <span> 게시 <em class="timeago" data-ts="1739073600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-02-09 </em> </span> <span> 업데이트 <em class="timeago" data-ts="1740980938" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-03-03 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8008 단어"> <em>44 분</em>읽는 시간</span></div></div></div><div class="post-content"><blockquote><p>어떤 것이든지 잘못될 가능성이 있다면 잘못된다.</p></blockquote><h2 id="0-분산-시스템의-골칫거리"><span class="mr-2">0. 분산 시스템의 골칫거리</span><a href="#0-분산-시스템의-골칫거리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다르다.<li>엔지니어로서의 우리의 임무는 모든게 잘못되더라도 사용자가 기대하는 보장을 만족시키는 제 역할을 해내는 시스템을 구축하는 것이다.</ul><h2 id="1-결함과-부분-장애"><span class="mr-2">1. 결함과 부분 장애</span><a href="#1-결함과-부분-장애" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>컴퓨터에 내부 결함이 발생하면 잘못된 결과를 반환하기보다는 완전히 동작하지 않기를 원한다.<li>단일 컴퓨터 기준<ul><li>하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다. (결정적이다.)<li>하드웨어 문제가 있으면 보통 시스템이 완전히 실패하는 결과를 낳는다.</ul><li>분산 시스템 기준<ul><li>네트워크 문제, 부분적인 실패, 타이밍 문제 등 다양한 문제가 발생할 수 있다.<li>부분 장애는 비결정적이다.<li>이러한 문제들은 예측하기 어렵고, 디버깅하기도 어렵다.</ul></ul><h3 id="11-클라우드-컴퓨팅과-슈퍼컴퓨팅"><span class="mr-2">1.1. 클라우드 컴퓨팅과 슈퍼컴퓨팅</span><a href="#11-클라우드-컴퓨팅과-슈퍼컴퓨팅" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>슈퍼 컴퓨팅<ul><li>슈퍼컴퓨터에서 실행되는 작업은 보통 가끔씩 계산 상태를 지속성 있는 저장소에 체크포인트로 저장한다.<li>노드 하나에 장애가 발생했을 때 흔한 해결책은 그냥 전체 클러스터 작업부하를 중단하는 것이다.<li>슈퍼컴퓨터는 부분 장애를 전체 장애로 확대하는 방법으로 처리하는데 시스템의 어느 부분에 장애가 발생하면 그냥 전체가 죽게 한다.</ul><li><strong>분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다.</strong><li>올바르게 동작하던 시스템도 시간이 지나면 어떤 부분에 결함이 생길 것이고 소프트웨어는 어떤 식으로든 그 결함을 처리해야 한다.</ul><h2 id="2-신뢰성-없는-네트워크"><span class="mr-2">2. 신뢰성 없는 네트워크</span><a href="#2-신뢰성-없는-네트워크" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비다.<li>인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크다.<li>노드는 다른 노드로 패킷을 보낼 수 있지만 도착을 보장하지 않고 요청을 보내고 응답을 기다리는 사이에 여러 잘못이 생길 수 있다.<li>이런 문제를 다루는 가장 흔한 방법은 타임아웃이다.</ul><h3 id="21-현실의-네트워크-결함"><span class="mr-2">2.1. 현실의 네트워크 결함</span><a href="#21-현실의-네트워크-결함" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>네트워크 문제는 놀랄 만큼 흔하다.<li>중간 규모의 데이터센터에서 매달 12번의 네트워크 결함이 발생함을 발견했다.<li>EC2 같은 공개 클라우드 서비스는 일시적으로 네트워크 결함이 자주 발생하는 것으로 알려져 있다.<li>소프트웨어는 예측하지 못하는 상황이지만 네트워크 결함을 반드시 견뎌내도록 처리할 필요는 없다.<li>네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야 한다.<li>고의로 네트워크 문제를 유발하여 시스템의 반응을 테스트해보는 것도 좋다. (카오스 몽키)</ul><h3 id="22-결함-감지"><span class="mr-2">2.2. 결함 감지</span><a href="#22-결함-감지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>결함을 자동으로 감지할 수 있어야 한다.<li>네트워크는 불확실성이 있기 때문에 노드가 동작 중인지 아닌지 구별하기 어렵다.<li>TCP가 패킷이 전달됐다는 확인 응답을 했더라도 애플리케이션이 그것을 처리하기 전에 죽을 수도 있다.<li>요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.</ul><h3 id="23-타임아웃과-기약-없는-지연"><span class="mr-2">2.3. 타임아웃과 기약 없는 지연</span><a href="#23-타임아웃과-기약-없는-지연" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다.<li>타임아웃이 짧으면 결함을 빨리 발견하지만 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아진다.<li>빠른 타임아웃은 다른 노드로 역할을 넘겨주게 되고 해당 요청이 중복되어 실행될 수도 있다.<li>역할이 다른 노드로 전달되어 다른 노드와 네트워크에 추가적인 부하를 준다.<li>비동기 네트워크는 기약 없는 지연(unbounded delay)이 있다.</ul><h4 id="231-네트워크-혼잡과-큐-대기"><span class="mr-2">2.3.1. 네트워크 혼잡과 큐 대기</span><a href="#231-네트워크-혼잡과-큐-대기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을 때까지 잠시 기다려야할 수도 있는데 이를 네트워크 혼잡(Network Congestion)이라고 부른다.<li>패킷이 목적지에 도착했을 때 모든 CPU가 바쁜 상태라면 운영체제 큐에 넣어둔다.<li>TCP는 혼잡 회피, 배압이라고 하는 흐름 제어를 수행하여 데이터가 네트워크로 들어가기 전에 송신을 제어하는 부가적인 큐 대기를 할 수 있다.<li>TCP는 타임아웃이 발생하면 손실로 간주하고 자동으로 재전송하는데 애플리케이션에서는 패킷의 손실과 재전송이 보이지 않지만 지연은 확인할 수 있다.<li>다양한 요인으로 네트워크 지연의 변동성에 영향을 준다.<li>이런 환경에서는 실험적으로 타임아웃을 선택하는 수 밖에 없다.<li>고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 그들의 변동성을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 하는 방법이 있다.</ul><h3 id="24-동기-네트워크-대-비동기-네트워크"><span class="mr-2">2.4. 동기 네트워크 대 비동기 네트워크</span><a href="#24-동기-네트워크-대-비동기-네트워크" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>전화 통화는 회선(circuit)을 만들어 고정되고 보장된 양의 대역폭이 할당된다. (동기식 네트워크)<li>큐 대기가 없으므로 네트어워크 종단 지연 시간의 최대치가 고정돼 있다. - 제한 있는 지연 (bounded delay)<li>TCP 연결의 패킷은 가용한 네트워크 대역폭을 기회주의적으로 사용한다. (비동기식 네트워크)<li>웹 페이지 요청, 이메일/파일 전송 처럼 순간적으로 몰리는 트래픽의 경우 TCP 패킷 교환이 적절하다.<li>네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 것이라고 가정하고 타임아웃의 올바른 값은 실험을 통해 결정해야 한다.</ul><h2 id="3-신뢰성-없는-시계"><span class="mr-2">3. 신뢰성 없는 시계</span><a href="#3-신뢰성-없는-시계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>분산 시스템에서는 통신이 즉각적이지 않으므로 시간을 다루기 까다롭다.<li>메시지가 네트워크를 거쳐 전달되는 데 시간이 걸리고 네트워크의 지연 변동성 때문에 얼마나 거릴지 알 수 없다.<li>개별 장비는 수정 발진기(quartz oscillator)라는 시계를 갖고 있지만 다른 장비와 차이가 있을 수 있다.<li>네트워크 시간 프로토콜(NTP) 메커니즘으로 서버 그룹 내에 시계를 조정할 수 있게 한다.<li>GPS로 더 정확한 시간을 동기화시킬 수 있다.</ul><h3 id="31-단조-시계-대-일-기준-시계"><span class="mr-2">3.1. 단조 시계 대 일 기준 시계</span><a href="#31-단조-시계-대-일-기준-시계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>일 기준 시계(Wall-Clock Time)<ul><li>모두가 같이 보는 벽 시계<li>created_at 기록에 적합하다.</ul><li>단조 시계(Monotonic Clock vs)<ul><li>나 혼자 보는 손목 시계<li>elapsed_time 측정에 적합하다.</ul><li><a href="https://blog.naver.com/anysecure3/222646997574" target="_blank" rel="noopener">리눅스 서버 ntp 동기화 설정</a></ul><h4 id="311-일-기준-시계"><span class="mr-2">3.1.1. 일 기준 시계</span><a href="#311-일-기준-시계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>일 기준 시계는 직관적으로 시계에 기대하는 일을 한다.<li>어떤 달력에 따라 현재 날짜와 시간을 변환한다.<ul><li>리눅스: clock_gettime(CLOCK_REALTIME)<li>자바: System.currentTimeMillis()<li>에포크(epoch)부터 흐른 초(or 밀리초) 수를 반환한다. (에포크: 1970년 1월 1일 0시 0분 0초 - UTC)</ul><li>일 기준 시계는 보통 NTP로 동기화되어 한 장비의 타임스탬프는 다른 장비의 타임스탬프와 동일한 의미를 지닌다는 뜻이다.<li>로컬 시계가 NTP 서버보다 너무 앞서면 강제 리셋되어 과거 시점으로 거구로 뛰는 것처럼 보일 수 있다.</ul><h4 id="312-단조-시계"><span class="mr-2">3.1.2. 단조 시계</span><a href="#312-단조-시계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>단조 시계는 타임아웃이나 서비스 응답 시간 같은 지속 시간(시간 구간)을 재는 데 적합하다.<ul><li>리눅스: clock_gettime(CLOCK_MONOTONIC)<li>자바: System.nanoTime()</ul><li>두 시점의 단조 시계 값을 확인하여 두 값 사이의 차이로 시간이 얼마나 흘렀는지 알 수 있다.<li>그러나 시계의 절대적인 값은 의미가 없다.<li>컴퓨터가 시작한 이래 흐른 나노초 수일 수도 있고 비슷한 어떤 것일 수도 있다.<li>두 대의 다른 컴퓨터에서 나온 단조 시계 값은 동일한 것을 의미하지 않기 때문에 이 둘을 비교하는 것은 의미가 없다.<li>여러 개의 CPU 소켓이 있는 서버는 CPU마다 독립된 타이머가 있을 수 있다.<ul><li>운영체제는 차이를 보정하여 스레드가 여러 CPU에 걸쳐 스케쥴링 되더라도 시계가 단조적으로 보이게 하려고 한다.<li>단조성 보장은 곧이 곧대로 받아들이지 않는게 현명하다.</ul><li>단조 시계의 해상도는 좋은 편이기 때문에 마이크로초나 그 이하 단위로 측정할 수 있다.<li>분산 시스템의 경과 시간을 재는데 단조 시계를 쓰는 것은 측정이 약간 부정확해도 민감하지 않기 때문에 일반적으로 괜찮다.</ul><h3 id="32-시계-동기화와-정확도"><span class="mr-2">3.2. 시계 동기화와 정확도</span><a href="#32-시계-동기화와-정확도" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>단조 시계는 동기화가 필요 없지만 일 기준 시계는 NTP 서버나 다른 외부 시간 출처에 맞춰 설정돼야 유용하다.<li>하드웨어 시계와 NTP는 생각보다 정확하지 않다.<ul><li>컴퓨터의 수정 시계는 장비 온도에 따라 더 빠르거나 느리게 실행되는 드리프트 현상이 생긴다.<li>컴퓨터 시계와 NTP 서버와 차이가 심하면 동기화가 거부되거나 강제로 리셋될 수 있다.<li>방화벽으로 NTP 서버가 차단되어 잘못된 설정이 얼마동안 알려지지 않을 수 있다.<li>NTP 동기화는 잘해야 네트워크 지연만큼만 좋을 수 있다. (최소 오차 35ms)<li>어떤 NTP 서버들은 이상이 잇거나 설정이 잘못돼서 몇 시간 정도 차이 나는 시간을 보고하고 있다.<li>윤초가 발생하면 1분이 길이가 59-61초가 되어 윤초를 고려하지 않고 설계된 시스템에서는 시간에 관한 가정이 엉망이 돼 버린다.<li>가상 장비에서 하드웨어 시계는 가상화돼서 정확한 시간 엄수가 필요한 애플리케이션에게 추가적인 어려움이 생긴다.<li>완전히 제어할 수 없는 장치에서 소프트웨어를 실행하면 아마도 그 장치의 하드웨어 시계를 전혀 믿을 수 없을 것이다.</ul><li>유럽 금융 규제 기관 초안은 고빈도 트레이딩 펀드는 모두 그들의 시계를 UTC와 100마이크로초 이내 동기화를 요구한다.<ul><li>GPS, 정밀 시간 프로토콜(PTP), 세심한 배포와 모니터링<li>상당한 노력과 전문 기술이 필요하며 시계 동기화가 잘못될 수 있는 수많은 가능성이 존재한다.<ul><li>잘못된 NTP 대몬 설정, 방화벽 NTP 트래픽 차단 등</ul></ul></ul><h3 id="33-동기화된-시계에-의존하기"><span class="mr-2">3.3. 동기화된 시계에 의존하기</span><a href="#33-동기화된-시계에-의존하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>하루는 정확히 86400초가 아닐 수도 있고, 일 기준 시계가 거꾸로 갈 수도 있으며, 노드 간 시간 차이가 많이 날 수도 있다.<li>소프트웨어는 네트워크 결함을 가정해서 설계돼야하며 시계도 마찬가지로 고려 대상이다.<li>견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다.<li>시계가 잘못된다는 것을 눈치채기 어렵다.<li>동기화된 시계가 필요한 소프트웨어를 사용한다면 모든 장비 사이의 시계 차이를 모니터링해야 한다.<li>시계 차이가 큰 노드는 죽은 것으로 간주하고 클러스터에서 제거돼야 한다.</ul><h4 id="331-이벤트-순서화용-타임스탬프"><span class="mr-2">3.3.1. 이벤트 순서화용 타임스탬프</span><a href="#331-이벤트-순서화용-타임스탬프" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>그림 8-3 다중 리더 복제를 쓰는 데이터베이스에서 일 기준 시간을 위험하게 사용하는 예 - 291p<ul><li>노드 간 시계 차이로 데이터 수정의 순서가 변경될 수 있다.</ul><li>최종 쓰기 승리 (last write win, LWW) 전략으로 충돌을 해소할 수 있고 다중 리더 복제, 리더 없는 데이터베이스에서 널리 사용된다.<li>타임스탬프를 서버가 아니라 클라이언트에서 생성하는 구현도 있지만 LWW에 존재하는 근본적은 문제를 바꾸지는 못한다.<ul><li>시계가 뒤처지는 노드는 시계가 빠른 노드가 먼저 쓴 내용을 그들 사이에 차이나는 시간이 흐를 때까지 덮어쓸 수 없기 때문에 데이터베이스 쓰기가 사라질 수 있다.<li>순차적인 쓰기가 빠른 시간 내에 연속으로 실행되는 것과 진짜 동시에 쓰기가 실행되는 것을 구별할 수 없다.<li>두 노드가 독립적으로 동일한 타임스탬프를 가진 쓰기 작업을 만들 수도 있다.</ul><li>가장 최근 값을 유지하고 다른 것들을 버림으로써 충돌을 해소하고 싶더라도 최근의 정의는 로컬 일 기준 시게에 의존하며 그 시게는 틀릴 수도 있다는 것을 아는게 중요하다.<li>잘못된 순서화가 발생하지 않을 정도로 NTP 동기화를 정확하게 하기는 거의 불가능하다.<li>올바른 순서화를 위해서는 시계 출처가 측정하려고 하는 대상(네트워크 지연)보다 훨씬 더 정확해야한다.<ul><li>논리적 시계 (logical clock)<ul><li>진동 수정 대신 증가하는 카운터 기반<li>일 기준, 경과한 초 수를 측정하지 않고 이벤트의 상대적인 순서만 측정</ul><li>물리적 시계 (physical clock)<ul><li>일 기준 시계와 단조 시계는 실제 경과 시간을 측정<li>순서화 보장 336p</ul></ul></ul><h4 id="332-시계-읽기는-신뢰-구간이-있다"><span class="mr-2">3.3.2. 시계 읽기는 신뢰 구간이 있다</span><a href="#332-시계-읽기는-신뢰-구간이-있다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>시계 읽기를 어떤 시점으로 생각하는 것보다 어떤 신뢰 구간에 속하는 시간의 범위로 생각하는 것이 좋다.<ul><li>장비의 일 기준 시계를 마이크로초, 나노초 해상도로 읽을 수 있지만 그 값이 그런 정밀성을 제공할 만큼 정확하지 않다.<li>로컬 네트워크에 있는 NTP 서버와 매분 동기화하더라도 부정확한 수정 시계에서 발생하는 드리프트는 쉽게 몇 ms가 될 수 있다.<li>공개 인터넷 NTP 서버를 사용하면 달성 가능한 최선의 정확도는 아마 수십 ms 정도이고 네트워크가 혼잡하다면 100ms 이상이 될 수 있다.</ul><li>불확실성 경계는 시간 출처를 기반으로 계산할 수 있다.<ul><li>GPS, 컴퓨터의 원자 시계: 제조사에서 제공하는 예상 오류 범위<li>NTP 서버: 마지막 동기화 시간 이후로 예상되는 시간 드리프트 + NTP 서버의 불확실성 + 네트워크 왕복 시간<li>clock_gettime()을 호출하더라도 예상 오차를 알려주지는 않는다.<li>스패너의 구글 트루타임 API는 로컬 시계의 신뢰 구간을 명시적으로 보여준다.<li><a href="https://cloud.google.com/spanner?hl=ko#features" target="_blank" rel="noopener">구글 스패너</a></ul></ul><h4 id="333-전역-스냅숏용-동기화된-시계"><span class="mr-2">3.3.3. 전역 스냅숏용 동기화된 시계</span><a href="#333-전역-스냅숏용-동기화된-시계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>스냅숏 격리는 작고 빠른 읽기 쓰기 트랜잭션과 크고 오래 실행되는 읽기 전용 트랜잭션 모두를 지원해야 하는 데이터베이스에서 아주 유용한 기능이다.<li>가장 흔한 스냅숏 격리 구현은 단조 증가하는 트랜잭션 ID가 필요하다.<li>스냅숏보다 나중에 쓰기가 실행됐다면 그 내용은 스냅숏 트랜잭션에게 보이지 않는다.<li>단일 노드 데이터베이스에서는 단순한 카운터가 트랜잭션 ID를 생성하는데 충분하다.<li>분산 데이터베이스는 코디네이션이 필요하다.<li>분산 시스템에서 작고 빠른 트랜잭션이 많으면 트랜잭션 ID 생성은 방어할 수 없는 병목이 된다.<li>구글 스패너 예시<ul><li>트루타임 API의 시계 신뢰 구간을 사용하여 신뢰 구간이 겹치지 않는다면 트랜잭션의 우선 순위를 보장할 수 있다.<ul><li>A-earliest &lt; A-latest &lt; B-earliest &lt; A-earliest</ul><li>트랜잭션 타임스탬프가 인과성을 반영하는 것을 보장하기 위해 읽기 쓰기 트랜잭션을 커밋하기 전에 의도적으로 신뢰 구간의 길이만큼 기다린다.<li>그 데이터를 읽을지도 모르는 트랜잭션은 충분히 나중에 실행되는 게 보장되므로 신뢰 구간이 겹치지 않는다.<li>시계 불확실성을 가능하면 작게 유지해야하기 때문에 각 데이터센터에 GPS 수신기나 원자 시계를 배치해서 약 7ms 이내로 동기화되게 한다.</ul></ul><h3 id="34-프로세스-중단"><span class="mr-2">3.4. 프로세스 중단</span><a href="#34-프로세스-중단" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>분산 시스템에서 리더가 안전하게 쓰기를 받을 수 있는 임차권(lease) 예제 - 295p<li>프로그램 실행 중에 예상치 못한 중단이 있어서 오랫동안 요청이 오랫동안 멈춰있다면 이미 임차권이 만료되어 다른 노드가 리더 역할을 맡고 있을 수 있다.<li>단일 장비에서는 뮤텍스, 세마포어, 원자적 카운터, 락프리, 블로킹 큐 등 다양한 스레드 안전 기법을 사용할 수 있지만 분산 시스템에서는 불가능 하다.<li>분산 시스템의 노드는 어느 시점에 실행이 상당히 멈출 수 있다고 가정해야 하고 심지어 함수 중간에 멈출 수도 있다.</ul><h4 id="341-응답-시간-보장"><span class="mr-2">3.4.1. 응답 시간 보장</span><a href="#341-응답-시간-보장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>명시된 시간안에 응답하는 데 실패하면 심각한 손상을 유발할 수 있는 환경에서 실행되는 소프트웨어는 데드라인이 명시된다.<li>프로세스가 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케쥴링 해주는 실시간 운영체제가 필요하다.<li>라이브러리 함수는 최악의 실행 시간을 문서화해야 한다.<li>동적 메모리 할당은 제한되거나 완전히 금지될 수 있다.<li>보장 만족의 확신을 위해 막대한 양의 테스트와 측정을 해야 한다.<li>프로그래밍 언어, 라이브러리, 도구의 범위를 엄격하게 제한한다.<li>안전이 필수적인 임베디드 장치에서 가장 흔하게 사용된다.<li>실시간 시스템은 무엇보다도 제때에 응답하는 것을 우선시해야 하므로 처리량이 더 낮을 수도 있다. (실시간은 고성능과 동일하지 않다.)</ul><h4 id="342-가비지-컬렉션의-영향을-제한하기"><span class="mr-2">3.4.2. 가비지 컬렉션의 영향을 제한하기</span><a href="#342-가비지-컬렉션의-영향을-제한하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>언어 런타임은 객체 할당률과 시간에 따라 남아 있는 여유 메모리 공간을 추적할 수 있으므로 언제 GC 할지와 관련된 어느정도 유연성을 갖고 있다.<li>GC 중단을 노드가 잠시 동안 계획적으로 중단되는 것으로 간주하고 노드가 GC 하는 동안 클라이언트 요청을 다른 노드들이 처리하게 한다.<li>런타임이 애플리케이션에게 노드가 곧 GC 중단이 필요하다는 경고를 할 수 있다면 애플리케이션은 그 노드로 새로운 요청을 멈추고, 그 노드가 요청 처리를 완료한 후 아무 요청도 처리 하지 않는 동안 GC를 실행하기를 기다릴 수 있다.<li>GC를 클라이언트로부터 감추고 응답 시간의 상위 백분위를 줄여준다.<li>지연 시간에 민감한 금융 거래 시스템 중에 이 방법을 쓰는 것도 있다.<li>수명이 짧은 객체만 GC를 사용하고 수명이 긴 객체의 전체 GC가 필요할 만큼 객체가 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법도 있다.<li>GC 중단을 완전히 막을 수는 없지만 애플리케이션에 미치는 영향은 유용하게 줄일 수 있다.</ul><h2 id="4-지식-진실-그리고-거짓말"><span class="mr-2">4. 지식, 진실, 그리고 거짓말</span><a href="#4-지식-진실-그리고-거짓말" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>분산 시스템은 공유 메모리가 없고 지연 변동이 있는 네트워크로 통신하여 부분 장애, 신뢰성 없는 시계, 프로세스 중단 등 다양한 문제가 있다.<li>분산 시스템에서 동작(시스템 모델)에 관해 정한 가저을 명시하고, 이런 가정을 만족시키는 방식으로 실제 시스템을 설계할 수 있다.<li>어떤 시스템 모델 내에서 알고리즘이 올바르게 동작하는지 증명할 수 있다.<li>기반 시스템 모델이 매우 적은 보장만 제공하더라도 신뢰성 있는 동작을 달성할 수 있다.<li>그러나 신뢰성 없는 시스템 모델에서 잘 동작하는 소프트웨어를 만드는 게 가능할지라도 그것이 간단하지는 않다.</ul><h3 id="41-진실은-다수결로-결정된다"><span class="mr-2">4.1. 진실은 다수결로 결정된다</span><a href="#41-진실은-다수결로-결정된다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>분산 시스템은 한 노드에만 의존할 수 없고 노드에 언제든 장애가 나서 잠재적으로 시스템이 멈추고 복구할 수 없게 될 수도 있다.<li>여러 분산 알고리즘은 <strong>정족수(quorum)</strong>, 노드들 사이의 투표에 의존한다.<li>노드의 과반수 이상을 정족수로 삼는 게 가장 흔하다.</ul><h4 id="411-리더와-잠금"><span class="mr-2">4.1.1. 리더와 잠금</span><a href="#411-리더와-잠금" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>파티션의 리더, 잠금 획득, 식별자<li>어떤 노드가 스스로를 리더라고 믿더라도 정족수도 반드시 동의하지는 않고 다른 노드들이 그 노드가 죽었다고 선언하면 그 노드는 강등되고 다른 리더가 이미 선출되었을 수도 있다.<li>임차권 잠금 예시<ul><li>임차권을 가진 클라이어트가 너무 오랫동안 멈춰 있어서 임차권이 만료된다.<li>다른 클라이언트가 임차권을 얻어서 쓰기를 시작할 수 있다.<li>멈췄던 클라이언트가 여전히 유효한 임차권을 갖고 있느 것으로 잘못 알고 파일에 쓴다.<li>두 클라이언트의 쓰기가 충돌되고 파일이 오염된다.</ul></ul><h4 id="412-펜싱-토큰"><span class="mr-2">4.1.2. 펜싱 토큰</span><a href="#412-펜싱-토큰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>잠금(임차권)을 쓸 때 자신이 잠금을 얻었다고 잘못 믿고 있는 노드가 시스템을 방해할 수 없도록 보장하기 위한 단순한 기법이 펜싱이다.<li>잠금 서버가 잠금이나 임차권을 승인할 때마다 펜싱 토큰을 반환하고 클라이언트가 쓰기 요청을 할 때 펜싱 토큰을 포함하도록 한다.<li>오랫동안 중단된 클라이언트의 임차권은 만료되어 쓰기를 거부할 수 있다.<li>잠금 서비스로 주키퍼를 사용하면 트랜잭션 ID zxid나 노드 버전 cversion을 펜싱토큰으로 사용할 수 있고 이들은 단조 증가가 보장된다.</ul><h3 id="42-비잔틴-결함"><span class="mr-2">4.2. 비잔틴 결함</span><a href="#42-비잔틴-결함" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>노드가 고의로 시스템의 보장을 무너뜨리기 위해 가짜 펜싱 토큰을 포함한 메시지를 보낼 수 있다.<li>노드들은 느리거나 응답하지 않을 수 있고 그들의 상태는 뒤쳐질 수도 있지만 노드가 응답한다면 그 노드는 진실을 말한다고 가정한다. (프로토콜의 규칙에 따라 동작한다.)<li>분산 시스템의 노드가 거짓말을 할지도 모른다는 위험이 있다면 훨씬 더 어려워진다.<li>어떤 노드가 실제로 받지 않은 특정 메시지를 받았다고 주장하는 동작을 <strong>비잔틴 결함</strong>이라고 하며 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 <strong>비잔틴 장군 문제</strong>라고 한다.<li>비잔틴 장군 문제 - 두 장군 문제 (304p)<li>일부 노드가 오작동하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 이 시스템은 <strong>비잔틴 내결함성을 지닌다.</strong><li>비잔틴 내결함성을 지닌 시스템은 <strong>비잔틴 장군 문제를 해결할 수 있다.</strong><li>웹 애플리케이션은 최종 사용자가 제어하는 웹브라우저 같은 클라이언ㅌ의 행동이 임의적이고 악이적이라고 예상해야 한다.<ul><li>SQL 인잭션, 크로스 사이트 스크립팅, CSRF, 클릭재킹, DDoS</ul><li>모든 노드가 동일한 소프트웨어를 실행하고 있기 때문에 공격자가 노드 하나를 침해한다면 모든 노드를 침해할 수 있다.</ul><h4 id="421-약한-형태의-거짓말"><span class="mr-2">4.2.1. 약한 형태의 거짓말</span><a href="#421-약한-형태의-거짓말" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>약한 형태의 거짓말: 하드웨어 문제, 소프트웨어 버그, 잘못된 설정으로 유효하지 않은 메시지<li>약한 형태의 거짓말로부터 보호해주는 메커니즘을 소프트웨어에 추가하는 게 가치가 있을 수 있다.<ul><li>애플리케이션 수준 프로토콜에서 체크섬을 사용한다.<li>사용자 입력값을 신중하게 살균(검증)한다.<li>NTP 서버를 사용할 때는 여러 개의 서버를 사용하고 그들의 응답을 비교한다.</ul></ul><h3 id="43-시스템-모델과-현실"><span class="mr-2">4.3. 시스템 모델과 현실</span><a href="#43-시스템-모델과-현실" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>알고리즘은 하드웨어와 소프트웨어 설정의 세부 사항에 너무 심하게 의존하지 않는 방식으로 작성해야 한다.<li>시스템에서 발생할 것으로 예상되는 결함의 종류를 어떻게 정형화해야한다.<li>시스템 모델을 정의해서 정형화하는데 시스템 모델은 알고리즘이 가정하는 것을 기술한 추상화다.<ul><li>동기식 모델: 네트워크 지연, 프로세스 중단, 시계 오차 모두 제한이 있다고 가정<li>부분 동기식 모델: 대부분의 시간에는 동기식으로 동작하지만 때때로 네트워크 지연, 프로세스 중단, 시계 드리프트 한계치를 초과할 수 있다고 가정<li>비동기식 모델: 타이밍에 대한 어떠한 가정도 할 수 없음</ul><li>노드 장애를 고려하기 위한 노드용 시스템 모델<ul><li>죽으면 중단하는 결함<li>죽으면 복구하는 결함<li>비잔틴 결함</ul></ul><h4 id="431-알고리즘의-정확성"><span class="mr-2">4.3.1. 알고리즘의 정확성</span><a href="#431-알고리즘의-정확성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>알고리즘의 정확하다는 게 어떤 의미인지 정의하기 위해 알고리즘의 속성을 기술할 수 있다.<li>정확하다는 게 어떤 뜻인지 정의하고 싶은 분산 시스템의 속성을 써볼 수 있다.<li>펜싱 토큰이라면 유일성, 단조 일련번호, 가용성<li>모든 노드가 죽거나 모든 네트워크 지연이 갑자기 무한히 길어진다면 어떤 알고리즘이라도 아무것도 할 수 없다.</ul><h4 id="432-안정성과-활동성"><span class="mr-2">4.3.2. 안정성과 활동성</span><a href="#432-안정성과-활동성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>안정성(safety): 유일성, 단조 일련번호<li>활동성(liveness): 가용성<li>활동성은 eventually 라는 단어를 포함한다. (최종적 일관성: eventually consistency)<li>안정성이 위반되면 그 속성이 깨진 시점을 가리킬 수 있어야 한다. 위반된 후에는 취소할 수 없다.<li>활동성은 시점을 정하지 못할 수는 있지만 항상 미래에 만족시킬 수 있다는 희망이 있다.<li>분산 알고리즘은 시스템 모델의 모든 상황에서 안정성이 항상 만족되기를 요구하는게 일반적이다.<li>활동성 속성에 대해서는 경고를 하는게 허용된다. - 노드의 다수가 죽지 않고 네트워크가 복구됐을 때만 요청이 응답받아야 한다.</ul><h4 id="433-시스템-모델을-현실-세계에-대응시키기"><span class="mr-2">4.3.3. 시스템 모델을 현실 세계에 대응시키기</span><a href="#433-시스템-모델을-현실-세계에-대응시키기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>안정성 및 활동성 속성과 시스템 모델은 분산 시스템의 정확성을 따져보는 데 매우 유용하다.<li>그러나 현업에서 알고리즘을 구현할 때 현실의 지저분한 사실들이 여러분을 곤란하게 만든다.<ul><li>죽으면 복구하는 모델에서 디스크의 데이터가 오염되거나, 하드웨어 오류, 잘못된 설정으로 데이터가 삭제된다면?<li>정족수 알고리즘에서 노드가 저장했던 데이터를 잊어버리고 정족수 조건을 깨뜨린다면?</ul><li>알고리즘이 올바르다고 증명됐더라도 반드시 현실 시스템에서의 구현도 언제나 올바르게 동작한다고 보장할 수 없다.<li>그렇지만 알고리즘을 이론적으로 분석하여 실제 시스템에 오랫동안 숨어 있다가 흔치 않은 상황 때문에 가정이 깨질 때만 나타나서 알고리즘의 문제를 드러낼 수 있다.<li>알고리즘의 이론적 분석과 경험적 실험은 똑같이 중요하다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>Study</a>, <a href='/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%A4%EA%B3%84/'>데이터 중심 어플리케이션 설계</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/study/" class="post-tag no-text-decoration" >study</a> <a href="/tags/data/" class="post-tag no-text-decoration" >data</a> <a href="/tags/design/" class="post-tag no-text-decoration" >design</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=08장. 분산 시스템의 골칫거리 - bveloper&amp;url=https://bswsw.github.io/posts/designing-data-chapter8/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=08장. 분산 시스템의 골칫거리 - bveloper&amp;u=https://bswsw.github.io/posts/designing-data-chapter8/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://bswsw.github.io/posts/designing-data-chapter8/&amp;text=08장. 분산 시스템의 골칫거리 - bveloper" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/designing-data-chapter9/">09장. 일관성과 합의</a><li><a href="/posts/designing-data-chapter8/">08장. 분산 시스템의 골칫거리</a><li><a href="/posts/designing-data-chapter7/">07장. 트랜잭션</a><li><a href="/posts/designing-data-chapter6/">06장. 파티셔닝</a><li><a href="/posts/designing-data-chapter5/">05장. 복제</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/livestudy/">livestudy</a> <a class="post-tag" href="/tags/whiteship/">whiteship</a> <a class="post-tag" href="/tags/learningscala/">learningscala</a> <a class="post-tag" href="/tags/scala/">scala</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/data/">data</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/jpa/">jpa</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/designing-data-chapter2/"><div class="card-body"> <em class="timeago small" data-ts="1731135600" > 2024-11-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>02장. 데이터 모델과 질의 언어</h3><div class="text-muted small"><p> 소프트웨어에서 데이터를 저장, 표현, 조작하는 다양한 방법을 알아보자. 관계형 모델 문서 모델 그래프 기반 데이터 모델 1. 관계형 모델과 문서 모델 1.1. 관계형 모델 메인프레임 컴퓨터에서 수행된 비즈니스 데이터 처리, 트랜잭션 처리, 일괄처리를 하기 위해 사용됨. 개발자는 DB 내부 데이터 표현에 대해 ...</p></div></div></a></div><div class="card"> <a href="/posts/designing-data-chapter3/"><div class="card-body"> <em class="timeago small" data-ts="1732204800" > 2024-11-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>03장. 저장소와 검색</h3><div class="text-muted small"><p> 데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자. 0. 개발자가 주의해야하는 이유 사용 가능한 여러 저장소 엔진 중에 어플리케이션에 적합한 엔진을 선택하는 것이 필요 특정 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 ...</p></div></div></a></div><div class="card"> <a href="/posts/designing-data-chapter4/"><div class="card-body"> <em class="timeago small" data-ts="1732942800" > 2024-11-30 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>04장. 부호화와 발전</h3><div class="text-muted small"><p> Encoding and Evolution 데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자. 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다. 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/designing-data-chapter7/" class="btn btn-outline-primary" prompt="이전 글"><p>07장. 트랜잭션</p></a> <a href="/posts/designing-data-chapter9/" class="btn btn-outline-primary" prompt="다음 글"><p>09장. 일관성과 합의</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "bswsw/bswsw.github.io", "data-repo-id": "R_kgDOHbD5Uw", "data-category": "Announcements", "data-category-id": "DIC_kwDOHbD5U84CPetV", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "ko", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/bswsw">BAE SANGWOO</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/livestudy/">livestudy</a> <a class="post-tag" href="/tags/whiteship/">whiteship</a> <a class="post-tag" href="/tags/learningscala/">learningscala</a> <a class="post-tag" href="/tags/scala/">scala</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/data/">data</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/jpa/">jpa</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-153066340-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-153066340-1'); }); </script>
