<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="07장. 트랜잭션" /><meta name="author" content="Bae Sangwoo" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="트랜잭션 잘 사용하기" /><meta property="og:description" content="트랜잭션 잘 사용하기" /><link rel="canonical" href="https://bswsw.github.io/posts/designing-data-chapter7/" /><meta property="og:url" content="https://bswsw.github.io/posts/designing-data-chapter7/" /><meta property="og:site_name" content="bveloper" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-01-12T09:30:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="07장. 트랜잭션" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Bae Sangwoo" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Bae Sangwoo"},"dateModified":"2025-02-07T00:49:05+09:00","datePublished":"2025-01-12T09:30:00+09:00","description":"트랜잭션 잘 사용하기","headline":"07장. 트랜잭션","mainEntityOfPage":{"@type":"WebPage","@id":"https://bswsw.github.io/posts/designing-data-chapter7/"},"url":"https://bswsw.github.io/posts/designing-data-chapter7/"}</script><title>07장. 트랜잭션 | bveloper</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="bveloper"><meta name="application-name" content="bveloper"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/bveloper.jpeg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">bveloper</a></div><div class="site-subtitle font-italic">bveloper</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/bswsw" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['baegoony','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>07장. 트랜잭션</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="https://wikibook.co.kr/images/cover/l/9791158393601.jpg" class="preview-img bg" alt="Preview Image" data-proofer-ignore><h1 data-toc-skip>07장. 트랜잭션</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/bswsw">BAE SANGWOO</a> </em></div><div class="d-flex"><div> <span> 게시 <em class="timeago" data-ts="1736641800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-01-12 </em> </span> <span> 업데이트 <em class="timeago" data-ts="1738856945" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-02-07 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9697 단어"> <em>53 분</em>읽는 시간</span></div></div></div><div class="post-content"><blockquote><p>트랜잭션 잘 사용하기</p></blockquote><h2 id="0-트랜잭션"><span class="mr-2">0. 트랜잭션</span><a href="#0-트랜잭션" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>데이터 시스템은 다양한 문제가 발생할 가능성이 있다.<ul><li>데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.<ul><li>애플리케이션은 언제라도 죽을 수 있다.<li>네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될수 있다.<li>여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.<li>클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.<li>클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.</ul></ul><li>이러한 결함이 발생하여 시스템에 치명적인 장애가 발생하지 않도록 막아야 한다. - 내결함성<li>트랜잭션은 여러 읽기와 쓰기를 논리적 단위로 묶어서 이러한 문제를 단순화하는 메커니즘이다.<li>데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만들어졌다.<li>트랜잭션을 사용함으로써 애플리케이션에서 어느 정도 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다. - 안정성 보장</ul><h2 id="1-애매모호한-트랜잭션의-개념"><span class="mr-2">1. 애매모호한 트랜잭션의 개념</span><a href="#1-애매모호한-트랜잭션의-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>트랜잭션의 개념은 1975년 첫 번째 SQL 데이터베이스인 IBM시스템 R 에서 소개되었고 대부분의 데이터베이스는 그 스타일을 따른다.<li>NoSQL 데이터베이스의 발전과 분산 데이터베이스가 홍보되면서 시스템의 높은 성능과 고가용성을 유지하기 위해 트랜잭션은 과거의 인식보다 많이 약화되었다.</ul><h3 id="11-acid의-의미"><span class="mr-2">1.1. ACID의 의미</span><a href="#11-acid의-의미" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>데이터베이스의 내결함성 메커니즘을 나타내는 정확한 용어를 확립하기 위해 만들어졌다.<ul><li>원자성(Atomicity)<li>일관성(Consistency)<li>격리성(Isolation)<li>지속성(Durability)</ul><li>데이터베이스의 ACID 구현은 제각각이고 어떤 데이터베이스가 ACID를 준수한다고 할 때 그 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다. (ACID는 거의 마케팅 용어가 되어버렸다.)<li>BASE이라고 불리우는 ACID 표준을 따르지 않는 ACID보다 더 모호한 정의가 있다.<ul><li>기본적으로 가용성을 제공 (Basically Available)<li>유연한 상태를 가짐 (Soft state)<li>최종적 일관성 (Eventual consistency)</ul></ul><h4 id="111-원자성"><span class="mr-2">1.1.1. 원자성</span><a href="#111-원자성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>원자적<ul><li>더 작은 부분으로 쪼갤 수 없는 무언가<li>다중 스레드 프로그래밍에서 한 스레드는 다른 스레드에서 절반만 완료된 연산을 관찰할 수 없다.<li>시스템은 연산을 실행하기 전이나 실행한 후의 상태만 있을 수 있고 중간 상태에 머물 수 없다.</ul><li>원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려고 할 때 무슨일이 생기는지 설명하지 않기 때문에 ACID의 맥락에서 보면 원자성은 동시성과 관련이 없다.<li>ACID의 원자성은 클라이언트가 여러 쓰기 작업을 실행하려고 할 때 일부만 처리된 후 결함이 생기면 무슨 일이 생기는지 설명한다.<li>결함 때문에 완료될 수 없다면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야한다.<li>ACID의 원자성은 오류가 발생했을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이다. - 어보트 능력(abortability)</ul><h4 id="112-일관성"><span class="mr-2">1.1.2. 일관성</span><a href="#112-일관성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>다양한 의미로 일관성이 사용된다.<li>ACID의 일관성은 항상 진실어야하는, <strong>데이터에 관한 어떤 선언(불변식(invariant))</strong>이 있다는 것이다.<li>이 일관성은 데이터베이스가 보장하는 것이 아니라 애플리케이션이 책임이다.<li>데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.<li>애플리케이션은 일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수는 있지만 데이터베이스만으로 되는 것은 아니다.</ul><h4 id="113-격리성"><span class="mr-2">1.1.3. 격리성</span><a href="#113-격리성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>데이터베이스에는 여러 클라이언트가 접속이 가능하고 클라이언트들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨리게 된다.<ul><li>e.g. 카운터를 동시에 증가시키는 경우</ul><li>ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.<li>트랜잭션은 다른 트랜잭션을 방해할 수 없다.<li>고전적인 데이터베이스 교과서에서는 격리성 = 직렬성<li>직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다.<li>여러 트랜잭션이 동시에 실행되면 트랜잭션이 커밋됐을 때의 결과가 <strong>순차적으로(하나씩 차례로)</strong> 실행됐을 때의 결과와 동일하도록 보장한다.<li>직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않고 직렬성보다 보장이 약한 <strong>스냅숏 격리</strong>를 구현했다.</ul><h4 id="115-지속성"><span class="mr-2">1.1.5. 지속성</span><a href="#115-지속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다.<li><strong>지속성(durability)</strong>은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.<li>디스크에 저장된 데이터 구조가 오염됐을 때 복구할 수 있게 해주는 쓰기 전 로그(write-ahead log)나 비슷한 수단을 동반한다.<li>복제 기능이 있다면 데이터가 다른 몇 개의 노드에 복사됐다는 것으로 지속성을 의미할 수 있다.<li>지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야한다.</ul><h3 id="12-단일-객체-연산과-다중-객체-연산"><span class="mr-2">1.2. 단일 객체 연산과 다중 객체 연산</span><a href="#12-단일-객체-연산과-다중-객체-연산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>원자성, 격리성의 정의는 한 번에 여러 객체를 변경할 수 있다고 가정한다.<li><strong>다중 객체 트랜잭션</strong>은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.<li>관계형 데이터베이스의 트랜잭션은 BEGIN TRANSACTION, COMMIT 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.<li>비관계형 데이터베이스에서는 다중 put 연산을 제공하지만 반드시 트랜잭션을 보장하지는 않기 때문에 일부만 성공하고 나머지는 실패하는 부분 갱신 상태가 될 수 있다.</ul><h4 id="121-단일-객체-쓰기"><span class="mr-2">1.2.1. 단일 객체 쓰기</span><a href="#121-단일-객체-쓰기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.<ul><li>원자성: 장애 복구용 로그<li>격리성: 객체 잠금</ul><li>어떤 데이터베이스는 Compare-And-Set 같은 연산을 제공하기도 한다.<li>이러한 단일 객체 연산은 동시에 같은 객체를 쓰려고할 때 갱신 손실을 방지하지만 일반적으로 사용되는 트랜잭션과는 다르다.<li>트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.</ul><h4 id="122-다중-객체-트랜잭션의-필요성"><span class="mr-2">1.2.2. 다중 객체 트랜잭션의 필요성</span><a href="#122-다중-객체-트랜잭션의-필요성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다.<ul><li>여러 파티션에 걸쳐서 구현하기 어렵다.<li>매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오가 없다.</ul><li>애플리케이션에 내에서 단일 객체 연산만 사용해서 다중 객체 트랜잭션인 것처럼 구현할 수 있다.<li>하지만 원자성이 없으면 오류 처리가 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.</ul><h4 id="123-오류와-어보트-처리"><span class="mr-2">1.2.3. 오류와 어보트 처리</span><a href="#123-오류와-어보트-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.<li>하지만 모든 시스템이 이 철학을 따르지는 않는다.<li>리더 없는 복제를 사용하는 데이터스토어는 가능 한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다는 원칙을 가지고 있기 대문에 오류 복구는 애플리케이션에게 책임이 있다.<li>어보트의 취지는 안전하게 재시도를 할 수 있게 하는데 있고 어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.</ul><h2 id="2-완화된-격리-수준"><span class="mr-2">2. 완화된 격리 수준</span><a href="#2-완화된-격리-수준" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다.<li>동시성은 추론하기도 매우 어렵다.<li>그래서 데이터베이스는 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.<li>직렬성 격리<ul><li>여러 트랜잭션이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장<li>성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않음</ul><li>완화된 트랜잭션 격리<ul><li>일부 동시성 이슈로부터 보호해주지만 모든 이슈로부터 보호해주지 않음<li>미묘한 동시성 버그를 유발할 수 있음</ul></ul><h3 id="21-커밋-후-읽기"><span class="mr-2">2.1. 커밋 후 읽기</span><a href="#21-커밋-후-읽기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>read committed<li>데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없음)<li>데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)</ul><h4 id="211-더티-읽기-방지"><span class="mr-2">2.1.1. 더티 읽기 방지</span><a href="#211-더티-읽기-방지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>커밋되지 않은 것을 읽는 것 - 더티 읽기<li>사용자는 읽지 않은 새 메일은 볼 수 있지만 갱신된 개수를 볼 수 없는 경우<li>나중에 롤백 될 데이터를 보는 경우</ul><h4 id="212-더티-쓰기-방지"><span class="mr-2">2.1.2. 더티 쓰기 방지</span><a href="#212-더티-쓰기-방지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 것 - 더티 쓰기<li>동시에 같은 차를 사는 경우 구매자 반영과 구매자에게 판매 송장을 전송해야하는 경우<li>카운터를 증가시키는 경우</ul><h4 id="213-커밋-후-읽기-구현"><span class="mr-2">2.1.3. 커밋 후 읽기 구현</span><a href="#213-커밋-후-읽기-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>다양한 데이터베이스에서 기본 설저으로 제공<li>로우 수준 잠금 사용으로 더티 쓰기 방지<li>동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 하여 더티 읽기 방지<ul><li>위 방법은 어렵고 지연 시간으로 인해 잘 사용되지 않음<li>트랜잭션이 실행 중인 객체를 읽으면 과거의 값을 읽게 함</ul></ul><h3 id="22-스냅숏-격리와-반복-읽기"><span class="mr-2">2.2. 스냅숏 격리와 반복 읽기</span><a href="#22-스냅숏-격리와-반복-읽기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>트랜잭션 처리 중에 데이터를 읽으면 비반복 읽기(nonrepeatable read), 읽기 스큐(read skew) 현상이 발생될 수 있다.<li>읽기 스큐는 커밋 후 읽기 격리에서는 받아들일 수 있는 것으로 여겨진다.<li>대용량 데이터 백업, 분석 질의와 무결성 확인 등 시간이 오래 걸리는 작업일 경우 작업 중에 데이터베이스 쓰기가 발생할 수 있다.<li>각 트랜잭션은 데이터베이스의 <strong>일관된 스냅숏</strong>으로부터 데이터를 읽어서 해결한다.<li>트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 보고 데이터가 다른 트랜잭션에 의해 변경되더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.<li>시간이 오래걸리는 읽기 질의에 유용하다.</ul><h4 id="221-스냅숏-격리-구현"><span class="mr-2">2.2.1. 스냅숏 격리 구현</span><a href="#221-스냅숏-격리-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>스냅숏 격리의 핵심 원리는 <strong>읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다.</strong><li>데이터베이스는 객체마다 여러 커밋 버전을 유지할 수 있고 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 볼 수 있다. - 다중 버전 동시성 제어 <strong>(multi-version concurrency control, MVCC)</strong><li>데이터베이스가 커밋 후 읽기 격리만 필요하다면 객체마다 두 개의 버전만 유지하면 충분하지만 스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다.<li>포스트그레스큐엘 예시<ol><li>트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID 할당<li>트랜잭션이 데이터베이스 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션 ID가 함께 붙음<li>로우를 테이블에 삽입함 트랜잭션 ID를 갖는 created_by 필드가 있고 비어 있는 deleted_by가 있음<li>트랜잭션이 로우를 삭제하면 DB에서 지우지 않고 deleted_by 필드를 삭제 요청 트랜잭션ID로 설정<li>어떤 트랜잭션도 삭제된 데이터에 접근하지 않으면 표시된 로우들을 삭제</ol></ul><h4 id="222-일관된-스냅숏을-보는-가시성-규칙"><span class="mr-2">2.2.2. 일관된 스냅숏을 보는 가시성 규칙</span><a href="#222-일관된-스냅숏을-보는-가시성-규칙" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>트랜잭션은 DB에서 객체를 읽을 때 트랜잭션ID를 사용해 볼 수 있는 것을 결정한다.<li>동작 방식<ol><li>각 트랜잭션을 실행할 때 그 시점에 진행 중인 트랜잭션의 목록을 만들고 이 트랜잭션이 쓴 데이터와 커밋은 무시<li>어보트된 트랜잭션이 쓴 데이터는 모두 무시<li>트랜잭션ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계없이 모두 무시<li>그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있음</ol><li>볼수 있는 객체의 조건<ul><li>읽기 실행 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태일 경우<li>읽기 대상 객체가 삭제된 것으로 표시되지 않음<li>읽기 대상 객체가 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않음</ul></ul><h4 id="223-색인과-스냅숏-격리"><span class="mr-2">2.2.3. 색인과 스냅숏 격리</span><a href="#223-색인과-스냅숏-격리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>다중 버전 데이터베이스의 색인 동작 방식<li>단순하게 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 한다.<li>현실에서는 여러 구현 세부 사항에 따라 다중 버전 동시성 제어의 성능이 결정된다.<li>포스트그레스큐엘<ul><li>동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화</ul><li>카우치DB, 데이토믹, LMDB<ul><li>B트리를 사용하지만 <strong>추가 전용이며 쓸 때 복사되는(append-only/copy-on-write)</strong> 변종 사용<li>추가 전용 B트리를 사용하면 쓰기를 실행하는 모든 트랜잭션은 새로운 B트리 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다.<li>컴팩션과 가비지 컬렉션을 실행하는 백그라운드 프로세스가 필요하다.</ul></ul><h4 id="224-반복-읽기와-혼란스러운-이름"><span class="mr-2">2.2.4. 반복 읽기와 혼란스러운 이름</span><a href="#224-반복-읽기와-혼란스러운-이름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>SQL 표준에 스냅숏 격리의 개념이 없기 때문에 이름이 혼란스럽다.<li>반복 읽기라는 SQL 표준의 정의되어있고 Postgresql, MySQL은 표준 요구사항을 만족시키기 때문에 스냅숏 격리 수준을 반복 읽기라고 한다.<li>하지만 SQL 표준 격리 수준 정의에는 결함이 있다.<li>결과적으로 반복 읽기가 무슨 뜻인지 실제로 아는 사람은 아무도 없다.</ul><h3 id="23-갱신-손실-방지"><span class="mr-2">2.3. 갱신 손실 방지</span><a href="#23-갱신-손실-방지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>동시 실행 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 - <strong>갱신 손실 (lost update)</strong><li>e.g. 카운터 증가<li>애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다. (<strong>read-modify-write 주기</strong>)<li>나중에 슨 것이 먼저 쓴 것을 <strong>때려눕힌다(clobber)</strong>.</ul><h4 id="231-원자적-쓰기-연산"><span class="mr-2">2.3.1. 원자적 쓰기 연산</span><a href="#231-원자적-쓰기-연산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>여러 데이터베이스에서 원자적 갱신 연산을 제공하여 read-modify-write 주기를 구현할 필요를 없애준다.</ul><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="k">UPDATE</span> <span class="n">counters</span> <span class="k">SET</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">WHERE</span> <span class="k">key</span> <span class="o">=</span> <span class="s1">'foo'</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>원자적 연산은 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. - <strong>커서 안정성 (cursor stability)</strong><li>그냥 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 방법이 있다.<li>애플리케이션에서 ORM을 사용하면 read-modify-write 코드 작성이 더 쉽다.</ul><h4 id="232-명시적인-잠금"><span class="mr-2">2.3.2. 명시적인 잠금</span><a href="#232-명시적인-잠금" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다.<li>애플리케이션에서 잠금을 얻은 후 read-modify-write 를 수행하고 완료되면 잠금을 푼다.</ul><h4 id="233-갱신-손실-자동-감지"><span class="mr-2">2.3.3. 갱신 손실 자동 감지</span><a href="#233-갱신-손실-자동-감지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>병렬 실행을 하용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이다.<li>데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다.<li>애플리케이션 코드에서 데이터베이스의 기능을 쓸 필요 없도록 도와준다.<li>잠금, 원자적 연산을 쓰는 것을 잊어버려서 버그를 유발할 수는 있지만 자동으로 갱신 손실이 감지되어 오류가 덜 발생하게 해준다.</ul><h4 id="234-compare-and-set"><span class="mr-2">2.3.4. Compare-and-set</span><a href="#234-compare-and-set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다.</ul><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="k">UPDATE</span> <span class="p">...</span> <span class="k">SET</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1234</span> <span class="k">AND</span> <span class="n">content</span> <span class="o">=</span> <span class="s1">'old content'</span><span class="p">;</span>
</pre></table></code></div></div><p>-</p><ul><li>content가 일치하지 않으면 이 갱신은 적용되지 않는다.<li>DB에서 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다.<li>데이터베이스의 compare-and-set 연산에 의존하기 전에 먼저 안전한지 확인이 필요하다.</ul><h4 id="235-충돌-해소와-복제"><span class="mr-2">2.3.5. 충돌 해소와 복제</span><a href="#235-충돌-해소와-복제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>여러 노드에 데이터 복사본이 있어서 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다.<li>잠금과 compare-and-set 연산은 최신 복사본이 하나만 있다고 가정한다.<li>다중 리더, 리더 없는 복제를 사용하는 DB는 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하기 때문에 최신 복사본이 하나라는 보장을 할 수 없다. - 잠금, compare-and-set 기법 적용 불가<li>복제 적용 DB에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전(<strong>형제(sibling)</strong>)을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합한다.<li>원자적 연산은 복제 상황에서도 잘 동작한다. - 특히 교환 법칙이 성립하는 연산<li>최종 쓰기 승리(las write wins, LWW) 충돌 해소 방법은 갱신 손실이 발생하기 쉽다.<li>많은 복제 DB는 LWW가 기본 설정이다.</ul><h3 id="24-쓰기-스큐와-팬텀"><span class="mr-2">2.4. 쓰기 스큐와 팬텀</span><a href="#24-쓰기-스큐와-팬텀" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>두 의사가 호출 대기를 하는데 동시에 호출 대기를 끄는 동작<li>스냅숏 격리가 둘 다 두 명이상 대기중으로 알려줘서 둘다 호출대기가 꺼질 수 있음</ul><h4 id="241-쓰기-스큐를-특징짓기"><span class="mr-2">2.4.1. 쓰기 스큐를 특징짓기</span><a href="#241-쓰기-스큐를-특징짓기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>두 트랜잭션이 같은 객체들을 읽어서 그 중 일부를 갱신할 때 나타날 수 있다.<li>다른 트랜잭션이 하나의 동일한 객체를 갱신하는 특별한 경우에 더티 쓰기나 갱신 손실 이상 현상을 겪게된다.<li>막는 방법<ul><li>여러 객체가 관련되므로 원자적 단일 객체 연산은 도움이 되지 않는다.<li>스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 도움이되지 않는다.<li>어떤 DB에서는 제약 조건을 설정할 수 있다. - 트리거, 구체화 뷰를 사용<li>직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다.</ul></ul><h4 id="242-추가적인-쓰기-스큐의-예"><span class="mr-2">2.4.2. 추가적인 쓰기 스큐의 예</span><a href="#242-추가적인-쓰기-스큐의-예" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>회의실 예약 시스템: 겹치는 시간 예약 확인<li>다중플레이어 게임: 플레이어들이 두 개의 다른 물체를 옮기는 경우<li>사용자명 획득: 계정 생성 시 중복 체크<li>이중 사용 방지: 돈이나 포인트를 더 많이 지불하는 경우</ul><h4 id="243-쓰기-스큐를-유발하는-팬덤"><span class="mr-2">2.4.3. 쓰기 스큐를 유발하는 팬덤</span><a href="#243-쓰기-스큐를-유발하는-팬덤" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>스큐를 유발하는 패턴<ul><li>SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.<li>첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정한다.<li>애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 커밋한다.</ul><li>의사 예시는 1단계 로우를 잠금으로써 (SELECT FOR UPDATE) 스큐를 회피할 수 있지만 2.4.2. 예제는 1단계 질의가 아무 로우도 반환하지 않으면 SELECT FOR UPDATE는 아무것도 잠글 수 없어서 다르다.<li>어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 한다.</ul><h4 id="244-충돌-구체화"><span class="mr-2">2.4.4. 충돌 구체화</span><a href="#244-충돌-구체화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>회의실 예약의 경우 회의실과 시간 범위의 모든 조합에 대해 로우를 미리 만들어 놓고 SELECT FOR UPDATE로 잠글 수 있도록 처리할 수 있다.<li>이런 방법을 충돌 구체화(materializing conflict)라고 한다.<li>충돌을 구체화하는 방법은 알아내기 어렵고 오류가 발생하기 쉽다.<li>동시성 제어 메커니즘이 애플리케이션데이터 모델로 새어 나오는 것도 보기 좋지 않다.<li>다른 대안이 불가능할 때 최후의 수단으로 고려해야 한다.<li>대부분 직렬성 격리 수준이 훨씬 더 선호된다.</ul><h2 id="3-직렬성"><span class="mr-2">3. 직렬성</span><a href="#3-직렬성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>커밋 후 읽기, 스냅숏 격리 수준 등으로 특정 경쟁 조건을 방지할 수 있지만 쓰기 스큐와 팬텀과 관련된 까다로운 케이스는 방지하기 어렵다.<li>직렬성 격리는 가장 강력한 격리 수준으로 여겨진다.<li>동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.<li>모든 경쟁 조건을 막아준다.</ul><h3 id="31-실제적인-직렬-실행"><span class="mr-2">3.1. 실제적인 직렬 실행</span><a href="#31-실제적인-직렬-실행" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>동시성을 완전히 제거하고 한 번에 하나씩만 직렬로 단일 스레드에서 실행하여 충돌을 감지하고 방지하는 문제를 완전히 회피할 수 있다.<li>두 가지 발전으로 이 방법이 가능해졌다.<ul><li>하드웨어 성능 향상<li>OLTP 트랜잭션이 보통 짧고 읽기, 쓰기의 개수가 적다는 것을 알게 됨</ul><li>처리량은 CPU 코어 하나의 처리량으로 제한되기 때문에 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와는 다르게 구조화돼야 한다.</ul><h4 id="311-트랜잭션을-스토어드-프로시저-안에-캡슐화-하기"><span class="mr-2">3.1.1. 트랜잭션을 스토어드 프로시저 안에 캡슐화 하기</span><a href="#311-트랜잭션을-스토어드-프로시저-안에-캡슐화-하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>데이터베이스 초창기에는 트랜잭션이 사용자 활동 전체 흐름을 포함하려는 의도가 있었다.<ul><li>e.g. 항공권 예약 과정</ul><li>대부분의 데이터베이스는 이를 효율적으로 처리할 수 없어서 모든 OLTP 애플리케이션은 트랜잭션 내에서 대화식으로 사용자 응답을 대기하는 것을 회피함으로써 트랜잭션을 짧게 유지한다.<ul><li>e.g. 1개 http 요청에 1개의 트랜잭션</ul><li>이런 상호작용식 트랜잭션은 애플리케이션과 데이터베이스 사이의 네트워크 통신에 많은 시간을 소비하고 동시성을 허용하지 않고 한 번에 트랜잭션 하나씩만 처리하면 처리량이 매우 저하된다.<li><strong>트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 만들어두어 사용하면 네트워크나 디스크 I/O 대기 없이 매우 빨리 실행된다고 가정한다.</strong><li>기존에 PL/SQL을 사용했으나 현대에는 DB 벤더사 마다 자바, 그루비, 클로저 등 언어를 지원한다.<li>I/O 대기가 필요 없고 다른 동시성 제어 오버헤드를 회피하므로 단일 스레드로 상당히 좋은 처리량을 얻을 수 있다.<li>단점<ul><li>DB 마다 지원 언어가 다르고 라이브러리 생태계가 빈약함<li>디버깅이 어려움<li>버전 관리 및 배포가 불편함<li>테스트 까다로움<li>모니터링 어려움<li>DB는 공유 자원으로 애플리케이션보다 성능에 더 민감함</ul></ul><h4 id="312-파티셔닝"><span class="mr-2">3.1.2. 파티셔닝</span><a href="#312-파티셔닝" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>여러 CPU 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝할 수 있다.<li>각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝할 수 있다면 다른 파티션과 독립적으로 실행되는 트랜잭션 처리 스레드를 가질 수 있다.<li>CPU 코어에 각자의 파티션을 할당해서 트랜잭션 처리량을 CPU 개수에 맞춰 선형적으로 확장할 수 있다.<li>여러 파티션에 접근해야 하는 트랜잭션이 있다면 데이터베이스가 트랜잭션이 접근하는 모든 파티션에 걸쳐서 코디네이션 해야 한다.<li>여러 파티션에 걸친 트랜잭션은 코디네이션 오버헤드로 매우 느리다.</ul><h4 id="313-직렬-실행-요약"><span class="mr-2">3.1.3. 직렬 실행 요약</span><a href="#313-직렬-실행-요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>트랜잭션 직렬 실행의 제약 사항<ul><li>모든 트랜잭션은 작고 빨라야한다.<li>활성 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.<li>쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다.<li>여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 사용할 수 잇는 정도에는 엄격한 제한이 있다.</ul></ul><h3 id="32-2단계-잠금2pl"><span class="mr-2">3.2. 2단계 잠금(2PL)</span><a href="#32-2단계-잠금2pl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>직렬성을 구현하는 데 널리 쓰인 유일한 알고리즘이다. (2단계 커밋과 다르다.)<li>더티 쓰기를 막는데 잠금이 자주 사용된다.<li>2단계 잠금 요구 사항<ul><li>쓰기를 실행하는 트랜잭션이 없는 객체는 여러 트랜잭션에서 읽을 수 있다.<li>객체에 쓰려고 하면 독점적인 접근이 필요하다.</ul><li>예시<ul><li>트랜잭션A가 객체 하나를 읽고 트랜잭션B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A의 커밋/어보트를 기다려야 한다.<li>트랜잭션A가 객체에 썼고 트랜잭션B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A의 커밋/어보트를 기다려야 한다.</ul><li>스냅숏 격리는 읽는 쪽은 쓰는 쪽을 막지 않고 쓰는 쪽은 읽는 쪽을 막지 않지만 2PL은 막을 수 있기 때문에 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해준다.</ul><h4 id="321-2단계-잠금-구현"><span class="mr-2">3.2.1. 2단계 잠금 구현</span><a href="#321-2단계-잠금-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>MySQL, SQL 서버의 직렬성 격리 수준 구현에 사용<li>DB2의 반복 읽기 격리 수준 구현에 사용<li>읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용해 구현한다.<ul><li>잠금: 공유 모드<li>쓰기: 독점 모드</ul><li>잠금이 아주 많이 사용되어 잠금 해제를 기다리는 상황이 매우 쉽게 발생할 수 있음 - 교착 상태<li>교착 상태를 감지하여 트랜잭션을 어보트하고 다른 트랜잭션이 진행할 수 있게 한다.</ul><h4 id="322-2단계-잠금-성능"><span class="mr-2">3.2.2. 2단계 잠금 성능</span><a href="#322-2단계-잠금-성능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>완화된 격리 수준보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다.<li>잠금을 획득하고 해제하는 오버헤드가 발생한다.<li>트랜잭션 경쟁 조건이 유발되어 트랜잭션 완료를 기다려야 하기 때문에 동시성이 줄어든다.<li>어보트된 트랜잭션은 애플리케이션에서 재시도해야 한다.</ul><h4 id="323-서술-잠금"><span class="mr-2">3.2.3. 서술 잠금</span><a href="#323-서술-잠금" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Predicate lock<li>한 트랜잭션이 다른 트랜잭션의 검색 질의 결과를 바꿔버리는 <strong>팬텀 문제</strong>가 발생한다.<li>검색 조건에 해당하는 모든 객체를 잠근다.<li>접근 제한 방법<ul><li>어떤 조건에 부합하는 객체를 읽기 원한다면 조건에 대한 공유 모드 서술 잠금 획득이 필요하다.<li>어떤 객체를 삽입, 갱신, 삭제하길 원한다면 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 한다. 서술 잠금이 다른 트랜잭션이 잡고 있다면 해당 트랜잭션의 커밋/어보트를 기다려야한다.</ul><li>2단계 잠금이 서술 잠금을 포함하면 모든 형태의 쓰기 스큐와 다른 경쟁 조건을 막을 수 있어서 직렬성 격리가 된다.</ul><h4 id="324-색인-범위-잠금"><span class="mr-2">3.2.4. 색인 범위 잠금</span><a href="#324-색인-범위-잠금" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>index-range locking.<li>다음 키 잠금(next-key locking) 이라고도 한다.<li>서술 잠금을 간략하게 근사한 것이다.<li>더 많은 객체가 부합하도록 서술 조건을 간략화하는 것은 안전하다.<ul><li>오후 1시 123번 방 예약 - 모든 시간 범위에 123번 방 예약에 대한 잠금</ul><li>쓰기 팬텀과 쓰기 스큐로부터 보호해주는 효과가 발생한다.<li>서술 잠금 보다 정밀하지는 않지만 오버 헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다.<li>적합한 색인이 없다면 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다.</ul><h3 id="33-직렬성-스냅숏-격리-ssi"><span class="mr-2">3.3. 직렬성 스냅숏 격리 (SSI)</span><a href="#33-직렬성-스냅숏-격리-ssi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>직렬성 스냅숏 격리 알고리즘은 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있다.<li>역사가 짧지만 새로운 기본값이 될 수 있다.</ul><h4 id="331-비관적-동시성-제어-대-낙관적-동시성-제어"><span class="mr-2">3.3.1. 비관적 동시성 제어 대 낙관적 동시성 제어</span><a href="#331-비관적-동시성-제어-대-낙관적-동시성-제어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>2단계 잠금은 비관적이지만 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다.<li>트랜잭션이 커밋되기를 원할 때만 격리가 위반됐는지 확인한다.<li>성능이 충분하고 트랜잭션 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 성능이 좋은 경향이 있다.<li>스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.</ul><h4 id="332-뒤처진-전제에-기반한-결정"><span class="mr-2">3.3.2. 뒤처진 전제에 기반한 결정</span><a href="#332-뒤처진-전제에-기반한-결정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>트랜잭션은 어떤 전제를 기반으로 어떤 동작을 한다. (전제: 일관된 스냅숏)<li>트랜잭션에서 실행하는 질의와 쓰기 사이에 인과적 의존성이 있을 수 있다.<li>직렬성 격리를 제공하려면 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 트랜잭션을 어보트시켜야 한다.<li>질의 결과 변경 감지 방법<ul><li>오래된 MVCC 객체 버전을 읽었는지 감지하기 (읽기 전에 커밋되지 않은 쓰기가 발생했음)<li>과거의 읽기가 영향을 미치는 쓰기 감지하기 (읽은 후에 쓰기가 실행됨)</ul></ul><h5 id="3321-오래된-mvcc-읽기-감지하기"><span class="mr-2">3.3.2.1. 오래된 MVCC 읽기 감지하기</span><a href="#3321-오래된-mvcc-읽기-감지하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li>트랜잭션이 MVCC 데이터베이스에서 일관된 스냅숏에서 읽음녀 스냅숏 생성 시점에 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시한다.<li>트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인하고 있다면 트랜잭션은 어보트돼야 한다.<li>다른 트랜잭션이 진행되면서 쓰기를 실행할지 알 수 없기 때문에 커밋할 때 까지 기다려야한다.<li>SSI는 불필요한 어보트를 피해서 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지한다.</ul><h5 id="3322-과거의-읽기에-영향을-미치는-쓰기-감지하기"><span class="mr-2">3.3.2.2. 과거의 읽기에 영향을 미치는 쓰기 감지하기</span><a href="#3322-과거의-읽기에-영향을-미치는-쓰기-감지하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li>다른 트랜잭션을 차단하지 않고 2단계 잠금과 비슷한 기법을 쓸 수 있다.<li>트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에게 확인해야 한다.<li>키 범위 쓰기 잠금을 획득하는 것과 비슷하지만 읽는 쪽에서 커밋될 때까지 차단하지 않는다.<li>읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려줄 뿐이다.<li>트랜잭션을 커밋할 때 충돌되는 쓰기가 이미 커밋됐으면 어보트돼야 한다.</ul><h4 id="333-직렬성-스냅숏-격리의-성능"><span class="mr-2">3.3.3. 직렬성 스냅숏 격리의 성능</span><a href="#333-직렬성-스냅숏-격리의-성능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>한 가지 트레이드오프는 트랜잭션의 읽기 쓰기를 추적하는 세밀함의 정도이다.<li>상세하게 추적하면 어보트해야할 트랜잭션을 정확히 판별할 수 있지만 기록 오버헤드가 심해진다.<li>어떤 경우에는 다른 트랜잭션에서 덮어쓴 정보를 트랜잭션이 읽어도 괜찮다.<ul><li>불필요한 어보트 개수를 줄일 수 있음</ul><li>2단계 잠금과 비교<ul><li>다른 트랜잭션이 잠금을 기다리느라 차단될 필요가 없음<li>읽기 전용 질의는 잠금 없이 일관된 스냅숏 위에서 실행될 수 있음</ul><li>순차 실행과 비교<ul><li>단일 CPU 코어의 처리량에 제한되지 않음<li>직렬성 충돌 감지를 여러 장비로 분산시켜서 처리량이 높도록 확장할 수도 있음 (파운데이션DB)<li>여러 장비에 파티셔닝돼 있더라도 트랜잭션은 직렬성 격리를 보장하면서 여러 파티션으로부터 읽고 쓸 수 있다.</ul><li>오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워 SSI는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구하지만 2단계 잠금이나 순차 실행보다는 느린 트랜잭션에 덜 민감할 것이다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>Study</a>, <a href='/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%A4%EA%B3%84/'>데이터 중심 어플리케이션 설계</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/study/" class="post-tag no-text-decoration" >study</a> <a href="/tags/data/" class="post-tag no-text-decoration" >data</a> <a href="/tags/design/" class="post-tag no-text-decoration" >design</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=07장. 트랜잭션 - bveloper&amp;url=https://bswsw.github.io/posts/designing-data-chapter7/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=07장. 트랜잭션 - bveloper&amp;u=https://bswsw.github.io/posts/designing-data-chapter7/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://bswsw.github.io/posts/designing-data-chapter7/&amp;text=07장. 트랜잭션 - bveloper" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/designing-data-chapter9/">09장. 일관성과 합의</a><li><a href="/posts/designing-data-chapter8/">08장. 분산 시스템의 골칫거리</a><li><a href="/posts/designing-data-chapter7/">07장. 트랜잭션</a><li><a href="/posts/designing-data-chapter6/">06장. 파티셔닝</a><li><a href="/posts/designing-data-chapter5/">05장. 복제</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/livestudy/">livestudy</a> <a class="post-tag" href="/tags/whiteship/">whiteship</a> <a class="post-tag" href="/tags/learningscala/">learningscala</a> <a class="post-tag" href="/tags/scala/">scala</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/data/">data</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/jpa/">jpa</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/designing-data-chapter2/"><div class="card-body"> <em class="timeago small" data-ts="1731135600" > 2024-11-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>02장. 데이터 모델과 질의 언어</h3><div class="text-muted small"><p> 소프트웨어에서 데이터를 저장, 표현, 조작하는 다양한 방법을 알아보자. 관계형 모델 문서 모델 그래프 기반 데이터 모델 1. 관계형 모델과 문서 모델 1.1. 관계형 모델 메인프레임 컴퓨터에서 수행된 비즈니스 데이터 처리, 트랜잭션 처리, 일괄처리를 하기 위해 사용됨. 개발자는 DB 내부 데이터 표현에 대해 ...</p></div></div></a></div><div class="card"> <a href="/posts/designing-data-chapter3/"><div class="card-body"> <em class="timeago small" data-ts="1732204800" > 2024-11-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>03장. 저장소와 검색</h3><div class="text-muted small"><p> 데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자. 0. 개발자가 주의해야하는 이유 사용 가능한 여러 저장소 엔진 중에 어플리케이션에 적합한 엔진을 선택하는 것이 필요 특정 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 ...</p></div></div></a></div><div class="card"> <a href="/posts/designing-data-chapter4/"><div class="card-body"> <em class="timeago small" data-ts="1732942800" > 2024-11-30 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>04장. 부호화와 발전</h3><div class="text-muted small"><p> Encoding and Evolution 데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자. 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다. 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/designing-data-chapter6/" class="btn btn-outline-primary" prompt="이전 글"><p>06장. 파티셔닝</p></a> <a href="/posts/designing-data-chapter8/" class="btn btn-outline-primary" prompt="다음 글"><p>08장. 분산 시스템의 골칫거리</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "bswsw/bswsw.github.io", "data-repo-id": "R_kgDOHbD5Uw", "data-category": "Announcements", "data-category-id": "DIC_kwDOHbD5U84CPetV", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "ko", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/bswsw">BAE SANGWOO</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/livestudy/">livestudy</a> <a class="post-tag" href="/tags/whiteship/">whiteship</a> <a class="post-tag" href="/tags/learningscala/">learningscala</a> <a class="post-tag" href="/tags/scala/">scala</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/data/">data</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/jpa/">jpa</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-153066340-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-153066340-1'); }); </script>
