[ { "title": "10장. 일괄 처리", "url": "/posts/designing-data-chapter10/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2025-04-26 13:00:00 +0900", "snippet": "0. 일괄 처리 일괄 처리는 대규모 데이터를 처리하는 중요한 방식으로, 서비스(온라인), 일괄 처리(오프라인), 스트림 처리(준실시간)와 구분한다. 일괄 처리 시스템은 대용량 입력 데이터를 받아 처리하고 결과 데이터를 생산하며, 작업 시간이 길어 사용자의 즉각적인 대기 없이 반복적인 일정으로 수행된다. 주요 성능 지표는 처리량이다. 일괄 처리는 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션 구축에 중요한 구성요소 이다.1. 유닉스 도구로 일괄 처리하기1.1. 단순 로그 분석 cat, awk, sort, uniq, head 등의 명령으로 파이프로 연결하여 로그에서 특정 정보를 추출하고, 정렬 및 집계하는 작업을 수행할 수 있다. 대용량 파일을 효율적으로 처리하며 분석 방법을 쉽게 수정할 수 있는 유연성을 제공한다. 정렬 기반 접근법과 인 메모리 집계(해시 테이블)는 데이터 규모에 따라 효율이 다르다. 유닉스의 sort는 메모리보다 큰 데이터셋도 디스크를 활용하여 처리하고 병렬 정렬을 지원한다.1.2. 유닉스 철학 유닉스 철학 각 프로그램은 한 가지 일만 잘 수행하도록 작성한다. 프로그램 출력은 다른 프로그램의 입력으로 사용될 수 있다고 생각한다. 소프트웨어를 빠르게 개발하고 개선한다. 반복 작업을 줄이기 위해 도구를 활용해라. 이러한 원칙은 오늘날의 애자일 및 DevOps 문화와 흡사하다. 유닉스 도구는 파일 및 파이프를 통한 동일 인터페이스를 사용하여 쉽게 결합되어 웹이 URL과 HTTP를 통해 서로 다른 사이트를 연결하는 것과 유사하다. 표준 입출력(stdin, stdout) 사용은 로직과 연결을 분리하여 프로그램의 유연성을 높힌다. 유닉스 도구는 입력의 불변성, 중간 출력 확인 기능, 재시작 가능성 등으로 투명성과 실험에 용이하다.2. 맵리듀스와 분산 파일 시스템 맵리듀스는 유닉스 도구와 유사하지만 수천 대 장비에 분산 실행이 가능하다는 차이가 있다. 맵리듀스 작업은 분산 파일 시스템(HDFS, GlusterFS, QFS 등)을 입출력으로 사용한다. HDFS는 비공유 원칙을 기반으로 하며 데이터 복제를 통해 결함에 대비하고 뛰어난 확장성으로 대규모 데이터 처리가 가능하다.2.1. 맵리듀스 작업 실행하기 맵리듀스 작업은 입력 레코드를 처리하는 매퍼(Mapper)와 결과를 집계하는 리듀서(Reducer) 함수로 구성된다. 매퍼는 모든 입력 레코드마다 호출되어 키와 값을 추출한다. 리듀서는 같은 키를 가진 값의 집합을 받아 처리하고 출력 레코드를 생산한다. 맵리듀스 프레임워크는 매퍼 출력을 같은 키의 기준으로 모으고 정렬하여 리듀서에 전달한다. (셔플) 맵리듀스는 병렬 처리를 지원하며, 데이터 지역성 원리를 적용하여 처리 효율을 높힌다. 작업 할당 시 코드도 함께 복사된다.2.2. 리듀스 사이드 조인과 그룹화 일괄 처리에서 조인(join)은 데이터셋 간의 모든 연관 관계를 처리하며, 색인 대신 전체 스캔이 일반적이다. 정렬 병합 조인 - 사용자 활동 이벤트 분석 예시 매퍼에서 조인키를 추출하고 셔플 과정을 통해 같은 키가 레코드를 같은 리듀서로 모은다. 리듀서는 정렬된 레코드를 병합하여 조인 결과를 생성한다. 이 방식은 필요한 데이터를 한 곳에 모아 효율적인 처리를 가능하게 한다. 그룹화 SQL의 GROUP BY와 유사하게 특정 키로 레코드를 그룹화하는 연산도 맵리듀스에서 키를 기준으로 데이터를 모아 리듀서에서 집계하는 방식으로 구현된다. 사용자 세션별 활동 이벤트를 수집 분석할 때에도 그룹화를 사용하는데 세션화(sessionization)라고 한다. 쏠림 다루기 린치핀 객체(핫 키)와 같은 데이터 쏠림 현상은 특정 리듀서에 부하를 집중시켜 성능을 저하한다. 쏠림 조인 등의 기법은 핫 키 데이터를 여러 리듀서에 분산시켜 처리함으로써 핫스팟을 완화한다. 2.3. 맵 사이드 조인 리듀서나 정렬 없이 매퍼에서 조인을 수행하여 효율을 높이는 방식이다. 브로드캐스트 해시 조인 작은 데이터셋을 메모리 해시테이블에 적재하고 큰 데이터셋을 스캔하여 조회한다. 작은 데이터셋이 모든 매퍼에 브로드캐스트되는 것과 유사하다. 파티션 해시 조인 조인 입력 두 개를 같으 방식으로 파티셔닝한 후 각 파티션별로 해시 조인을 독립적으로 수행한다. 각 매퍼가 처리할 데이터 양을 줄인다. 맵 사이드 병합 조인 입력 데이터셋이 파티셔닝되고 정렬되어 있다면 매퍼에서 병합 조인을 사용할 수 있다. 입력 데이터의 크기, 정렬, 파티셔닝에 제약이 있으며 데이터셋의 물리적 레이아웃 파악이 중요하다. 2.4. 일괄 처리 워크플로의 출력 일괄 처리 작업의 출력은 보고서 형태 외에 검색 색인 또는 머신러닝/추천 시스템의 기반 데이터베이스 형태를 가진다. 일괄 처리 작업에서 생산된 데이터를 외부 데이터베이스에 직접 기록하는 것은 성능 저하 및 부수 효과 문제로 선호되지 않는다. 일괄 처리 작업 내부에 새로운 데이터베이스 파일을 구축하여 분산 파일 시스템에 저장하고, 이를 읽기 전용으로 제공하는 방식이 좋다. 볼드모트, HBase 벌크 적재 등이 이러한 기능을 제공. 일괄 처리 작업의 출력 철학은 입력의 불변성, 부수 효과 없음, 출력의 완전한 교체 등으로 유지보수 및 복구에 유리하여 실패한 태스크는 안전하게 재시도 된다.2.5. 하둡과 분산 데이터베이스의 비교 하둡은 유닉스의 분산 버전과 유사하며, MPP(대규모 병렬 처리) 데이터베이스와 비교된다. 저장소의 다양성 하둡의 분산 파일 시스템은 데이터 모델에 제약이 없어 다양한 형태의 데이터를 저장할 수 있으며 스키마 설계는 나중에 고려하여 데이터 수집의 속도를 올릴 수 있다. (데이터 호수(Data lake)) MPP 데이터베이스는 데이터를 가져오기 전에 신중한 모델링이 필요하다. 처리 모델의 다양성 MPP 데이터베이스는 주로 SQL 분석 질의에 초점을 맞춘다. 하둡은 맵리듀스 외에도 SQL, 머신러닝 등 다양한 처리 모델을 지원하는 유연성이 있다. 동일 클러스터에서 다양한 작업 부하를 지원하여 데이터 이동 없이 처리가 가능하다. 빈번하게 발생하는 결함을 줄이는 설계 맵리듀스는 태스크 실패 시 전체 작업 재수행 없이 개별 태스크 수준에서 복구하며 데이터를 디스크에 자주 기록한다. 태스크 종료가 빈번한 환경에 적합하다. (구글 선점형 스케쥴링) MPP 데이터베이스는 장비 장애 시 전체 질의가 중단되는 경우가 많다. 3. 맵리듀스를 넘어 맵리듀스는 분산 시스템 이해에 유용하지만, 복잡한 구현과 비효율성이 단점이다. 고수준 언어와 API가 이러한 문제를 일부 해결한다.3.1. 중간 상태 구체화 맵리듀스는 분산 파일 시스템에 중간 상태를 구체화하여 내결함성을 확보하지만 유닉스 파이프에 비해 여러 단점을 가진다. 단점: 느린 수행 시간, 중복 작업, 과도한 I/O 스파크, 테즈 플링크와 같은 데이터플로 엔진은 중간 상태 구체화를 피하고 메모리나 로컬 디스크를 활용하여 효율을 높힌다. 데이터플로 엔진은 전체 워크플로를 하나의 작업으로 다루고, 연산자 간 데이터 흐름을 명시적으로 모델링하며, 맵리듀스보다 유연하고 최적화된 실행을 제공한다. 내결함성은 중간 데이터 재계산이나 체크포인트를 통해 확보하며 연산이 결정적인지 파악하는 것이 중요하다.3.2. 그래프와 반복 처리 그래프 데이터 처리는 머신러닝, 추천 시스템 등에 중요하며 페이지랭크가 대표적인 알고리즘이다. 많은 그래프 알고리즘은 반복적인 연산을 포함하며, 맵리듀스는 이러한 반복 처리에 비효율적이다. 프리글(Pregel) 모델은 일괄 처리 그래프 처리에 최적화된 모델(벌크 동기식 병렬: BSP)이며 정점 간 메시지 전달 및 반복 간 상태 유지를 통해 효율을 높힌다. 프리글은 체크포인트 저장을 통해 내결함성을 확보하며, 프레임워크가 그래프 파티셔닝 및 메시지 라우팅을 담당한다.3.3. 고수준 API와 언어 하이브, 피그 등 고수준 언어/API는 맵리듀스 작업 작성을 용이하게 하며, 데이터플로 엔진으로 전환 시 코드 수정 없이 설정 변경만으로 가능할 수 있다. 스파크, 플링크 등도 관계형 연산자 기반의 고수준 데이터플로 API를 제공한다. 고수준 인터페이스는 코드 작성량을 줄이고 대화식 사용을 지원하며, 질의 최적화 기능을 통해 성능을 향상시킨다. 일괄 처리 프레임워크는 임의 코드 실행 유연성을 유지하면서도 선언적 기능을 통합하며 MPP 데이터베이스와 유사해지고 있다. 통계, 수치 알고리즘 머신러닝 등 다양한 분야를 지원하기 위한 전문화된 라이브러리(머하웃)가 개발되고 있다. k 최근접 이웃 알고리즘 같은 공간 알고리즘을 사용하여 머신러닝 애플리케이션(분류, 추천 시스템)등에서 유사도 검색을 위해 사용된다." }, { "title": "09장. 일관성과 합의", "url": "/posts/designing-data-chapter9/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2025-04-13 19:00:00 +0900", "snippet": "0. 일관성과 합의 애플리케이션은 다양한 결함이 발생 가능하다. 네트워크 패킷 손실 타임아웃으로 인한 중복 수신 네트워크 지연 발생 및 순서 변경 정확하지 않은 시간 노드가 멈추거나 죽는 상황 내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것이다. 트랜잭션 애플리케이셔션은 충돌이 없음 (원자성) 데이터베이스에 동시에 접근하지 않음 (격리성) 데이터를 믿을 수 있음 (지속성) 분산 시스템에 가장 중요한 추상화 중 하나는 합의, 모든 노드가 어떤 것에 동의하게 만드는 것이다. 단일 리더 복제 데이터베이스에서 새 리더 선출 과정 - 스플릿 브레인 회피 1. 일관성 보장 복제 데이터베이스는 대부분 최종적 일관성을 제공한다. 모든 업데이트가 완료되면 모든 노드에 동일한 데이터가 저장된다. 언제 복제본이 최종적인지 알 수 없기 때문에 보장이 매우 약하다. 약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 계속 알아야 하고 뜻하지 않게 너무 많은 것을 가정하면 안 된다. 약한 보장의 문제는 결함이 있거나 동시성이 높을 때 드러나며 테스트로 발견하기 힘든 버그가 발생 할 수 있다. 성능이 떨어지고 내결함성이 비교적 약하지만 데이터를 올바르게 사용하기 위해서 강한 보장이 필요할 수 있다.2. 선형성 원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만들어 애플리케이션이 신경 쓸 필요가 없다. 읽은 데이터가 최근 갱신 데이터이고 뒤처진 캐시나 복제보에서 나온 데이터가 아니라고 보장해준다는 뜻 - 최신성 보장 비선형성 시스템 예시 (p323): 리더의 데이터가 여러 팔로워에 반영하는데 시간 차가 발생하고 클라이언트는 각각 다른 팔로워를 바라본다.2.1. 시스템에 선형성을 부여하는 것은 무엇인가? 선형성 예제 (p324-236) 쓰기가 처리되는 동안에는 읽기 요청은 old, new 데이터를 반환할 수 있다. - 완전하지 않은 선형성 쓰기가 처리되는 동안에 읽기 요청이 new 데이터를 반환했다면 후속 읽기 요청은 new 데이터를 반환해야 한다. - 완전한 선형성 원자적 compare-and-set 연산을 추가 선형성 대 직렬성 직렬성: 트랜잭션들의 격리 속성. 트랜잭션들이 순서에 따라 실행되는 것처럼 보장한다. 선형성: 레지스터에 실행되는 읽기와 쓰기에 대한 최신성 보장이다. 쓰기 스큐 문제를 막지 못한다. 둘다 제공하면 엄격한 직렬성, 강한 단일 복사본 직렬성이라고 한다. 2.2. 선형성에 기대기2.2.1. 잠금과 리더 선출 단일 리더 복제를 사용하는 시스템은 리더가 진짜로 하나만 존재하도록 보장해야한다. 리더를 선출하기 위해 잠금을 사용하여 잠금 획득을 성공한 노드가 리더가 된다. 주키퍼나 etcd 같은 코디네이터를 사용하여 분산 잠금과 리더 선출을 구현한다. 잠금과 리더 선출을 구현할 대 펜싱 문제 같은게 발생할 수 있다. 코디네이터는 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.2.2.2. 제약 조건과 유일성 보장 유일성 제약 조건을 보장하기 위해 선형성이 필요하다. 잠금과 비슷하며 원자적 compare-and-set 연산과도 매우 비슷하다. 은행 잔고, 재고 관리, 좌석 예매 등을 보장하고 싶을 때도 비슷한 문제가 생긴다.2.2.3. 채널 간 타이밍 의존성 이미지 업로드와 썸네일을 생성하는 예제 (p330) 이미지를 업로드하고 썸네일 생성 요청을 메시지 큐로 처리하는 경우, 이미지를 파일저장소에 업로드하기 전에 메시지 큐가 더 빠를 수 있다. 선형성의 최신성 보장이 없으면 이 두 채널 사이에 경쟁 조건이 발생할 수 있다.2.3. 선형성 시스템 구현하기 선형성은 근본적으로 데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적이라는 것을 의미한다. 가장 간단한 방법은 데이터 복사본을 하나만 사용하는 것이다. 하나의 복사본을 저장한 노드에 장애가 나면 데이터는 손실되거나 노드가 살아날 때까지 접근할 수 없다. 복제를 사용하여 선형적으로 동작하는 시스템을 구현할 수 있다. 단일 리더 복제 (선형적일 가능성) 리더는 쓰기에 사용되는 데이터의 복사본을 갖고 있고 팔로워는 백업 복사본을 보관한다. 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다. 동시성 버그, 스냅숏 격리 사용 등으로 비선형적일 수 있다. 합의 알고리즘 (선형적) 합의 프로콜에는 스플릿 브레인과 복제본이 뒤처지는 문제를 막을 수단이 포함된다. 주키퍼, etcd 등 코디네이터 다중 리더 복제 (비선형적) 여러 노드에서 동시에 쓰기를 처리하고 비동기로 복제하기 때문에 비선형적이다. 충돌 해소가 필요한 충돌 쓰기를 만들 수 있다. 리더 없는 복제 (아마도 비선형적) 정족수 읽기와 쓰기를 요구하여 엄격한 일관성을 달성할 수 있다고 주장한다. 일 기준 시게를 기반으로 한 최종 쓰기 승리 충돌 해소 방법은 시계 스큐 때문에 순서를 보장할 수 없어서 비선형적이다. 2.3.1. 선형성과 정족수 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보이지만 네트워크 지연 변동이 심하면 경쟁 조건이 생길 수 있다. (p332) 정족수 조건이 만족되더라도 처음 읽은 값과 나중에 읽은 값이 다를 수 있어서 선형적이지 않다. 성능이 떨어지는 비용을 지불하고 다이나모 스타일 정족수를 선형적으로 만드는 게 가능하다. 읽기를 실행하는 클라이언트는 결과를 애플리케이션에 반환하기 전에 읽기 복구를 동기식으로 수행해야 하고 쓰기를 실행하는 클라이언트는 쓰기 요청을 보내기 전에 노드들의 정족수로부터 최신 상태를 읽어야 한다. 리더 없는 복제 시스템은 선형성을 제공하지 않는다고 보는게 가장 안전한다. 2.4. 선형성의 비용 두 데이터센터 사이의 네트워크가 끊기면… 다중 리더 데이터베이스는 비동기로 복제되므로 큐에 쌓았다가 정상화되면 전달하여 각 데이터센터를 정상 동작할 수 있다. 단일 리더 복제는 팔로워는 데이터가 뒤처졌을 수 있다. (비선형적)2.4.1. CAP 정리 선형성이 필요 없는 애플리케이션은 네트워크 문제에 더 강인하다. CAP 정리는 일관성, 가용성, 파티션 내구성 중 두 가지만 보장할 수 있다고 주장한다. 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 보는게 더 좋다. 네트워크 분단 외 다양한 결함이나 트레이드오프를 논하지 않아 실용적 가치가 거의 없다.2.4.2. 선형성과 네트워크 지연 다중 코어 CPU 램 예제 (p335) 메인 메모리 데이터 갱신을 비동기로 처리하여 선형성이 손실된다. 선형성과 성능은 트레이드오프 이다. 효율적인 선형 저장소를 찾을 수는 있지만 선형성을 원하면 쓰기 요청의 응답 시간이 적어도 네트워크 지연의 불확실성에 비례해야 함을 증명했다. 선형성 읽기와 쓰기의 응답 시간은 필연적으로 높다.3. 순서화 보장 선형적 레지스터는 복사본이 하나만 있는것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적이다. 단일 리더 복제의 리더의 주 목적은 복제 로그에서 팔로워가 쓰기를 적용하는 순서를 보장하는 것 직렬성은 트랜잭션들이 일련의 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서를 부여하려는 것 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있음이 드러난다.3.1. 순서화와 인과성 순서화가 인과성을 보존하는데 도움을 준다. 일관된 순서로 읽기에서 질문에 대한 응답의 인과적 의존성이 존재함 네트워크 지연으로 쓰기 추월이 발생하지 않고 로우가 갱신되기 이전에 생성되야할 때 동시 쓰기 감지에서 이전 발생 관계는 인과성을 표현하는 방법 스냅숏 격리와 반복 읽기에서 트랜잭션이 일관된 스냅숏으로 읽을 때 일관적이란 인과성에 일관적이라는 의미 쓰기 스큐와 팬텀에서도 호출대기에서 빠지는 동작은 누가 호출 대기 중인지 관찰하는 것에 인관적으로 의존 서버로부터 뒤처진 결과를 받았다는 사실은 인과성 위반이다. 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적이라고 한다.3.1.1. 인과적 순서가 전체 순서는 아니다 선형성 연산의 전체 순서를 정할 수 있다. 선형성 데이터스토어에는 동시적 연산이 없다. 단일 데이터 복사본에 연산을 실행에 모든 요청이 한 시점에 원자적으로 처리되도록 보장해준다. 인과성 두 이벤트에 인과적인 관계가 있으면 순서가 있지만 동시에 실행되면 비교할 수 없다. git 같은 분산 버전 관리 시스템은 인과적 의존성 그래프와 유사하다. 3.1.2. 선형성은 인과적 일관성보다 강하다 선형성은 인과성을 내포하여 선형적이라면 인과성도 올바르게 유지한다. 시스템을 선형적으로 만들면 네트워크 지연이 클 때 성능과 가용성에 해가될 수 있다. 인과적 일관성은 네트워크 지연 대문에 느려지지 않고 네트워크 장애가 발생해도 가용한 일관성 모델 중 가장 강력하다. 많은 경우에 더 필요한 것은 인과적 일관성이다.3.1.3. 인과적 의존성 담기 인과성을 유지하기 위해 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다. (부분 순서) 버전 벡터를 일반화하여 인과적 의존성을 추가해야 한다. 이전 연산의 버전 번호를 데이터베이스로 되돌려주거나 직렬성 스냅숏 격리에서 트랜잭션이 커밋될 때 읽은 데이터가 최신인지 확인해야하는 것.3.2. 일련번호 순서화 일련번호나 타임스탬프를 써서 이벤트의 순서를 정할 수 있다. 물리적 시게를 사용하면 시계 스큐가 발생할 수 있기 때문에 논리적 시계에서 얻어도 된다. 일련번호나 타임스탬프는 크기가 작고 전체 순서를 제공하며 인과성에 일관적인 전체 순서대로 일련변호를 생성할 수 있다.3.2.1. 비인과적 일련번호 생성기 단일 리더가 없이 여러 노드에서 일련변호를 생성하면 인과성에 일관적이지 않다.3.2.2. 램포트 타임스탬프 램포트 타임스탬프는 노드ID와 카운터를 조합한 일련번호를 뜻한다. 물리적 일 기준 시계와 아무 관련 없지만 전체 순서화를 제공한다. 카운터가 큰 것이 타임스탬프가 크고 카운터 값이 같다면 노드ID가 큰 것이 타임스탬프가 크다. 버전 벡터와 차이점 버전 벡터는 두 연산의 인과적 의존성을 구별하지만 램포트 타임스탬프는 전체 순서화를 강제하여 두 연산이 동시적인지 인과적 의존성이 있는지 알 수 없다. 버전 벡터보다 크기가 더 작다. 3.2.3. 타임스탬프 순서화로는 충분하지 않다 유일성을 보장해야하는 연산을 동시에 요청되면 타임스탬프가 더 큰 연산은 실패하도록 사후에 결정할 수 있다. 노드는 이 요청이 당장 성공해야하는지는 알 수 없다. 노드는 이 요청 성공여부를 확신하려면 다른 노드를 모두 확인해야하고 장애나 네트워크 문제가 발생하면 내결함성이 떨어진다. 유일성 제약 조건 같은 것을 구현하려면 연산의 전체 순서와 순서의 확정 여부도 알아야 한다.3.3. 전체 순서 브로드캐스트 전체 순서 브로드캐스트, 원자적 브로드캐스트 처리량이 단일 리더가 처리할 수 있는 수준을 넘어 설 때 시스템을 확장하거나 리더에 장애가 발생했을 때 장애를 어떻게 복구할 것인가? 두 가지 안정성 속성을 항상 만족해야함 신뢰성 있는 전달: 메시지가 손실되지 않고 한 노드에 전달되면 모든 노드에도 전달된다. 전체 순서가 정해진 전달: 모든 노드에 같은 순서로 전달된다. 3.3.1. 전체 순서 브로드캐스트 사용하기 주키퍼나 etcd 같은 합의 서비스(코디네이터)는 전체 순서 브로드캐스트 구현한다. 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 일관성 있는 상태를 유지한다. (상태 기계 복제) 메시지가 전달되는 시점에 그 순서가 고정되어 후속 메시지가 이미 전달됐다면 그 순서 앞에 메시지를 끼워넣는 게 허용되지 않는다. (타임스탬프 순서화보다 강하다.) 복제 로그, 트랜잭션 로그, 쓰기 전 로그 등을 만드는 방법 중에 하나고 직렬성 트랜잭션을 구현하는 데도 쓸 수 있다. 잠금을 획득하는 모든 요청은 로그에 추가되고 순서대로 일련번호가 붙는다. 단조 증가하는 일련번호는 펜싱 토큰의 역할을 할 수 있다. (주키퍼에서 zxid)3.3.2. 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기 전체 순서 브로드캐스트는 비동기식이기 때문에 순서는 보장하지만 언제 전달될지는 보장하지 않는다. 선형성 저장소는 최신성을 보장해 읽기가 최근에 쓰여진 값을 보는 게 보장된다. 전체 순서 브로드캐스트에 추가 전용 로그를 사용하여서 선형성 CAS 연산을 구현하여 쓰기를 선형적으로 할 수 있다. 읽기를 선형적으로 만드려면? 로그를 통해 순차 읽기하여 로그를 읽어서 메시지가 되돌아왔을 때 실제 읽기를 수행한다. (etcd 정족수 읽기) 최신 로그 위치를 질의하고 그 위치까지 모든 항목이 전달되기를 기다린 후 읽기를 수행할 수 있다. (주키퍼 sync 함수) 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽을 수 있다. (연쇄 복제) 3.3.3. 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기 가장 쉬운 방법은 정수를 저장하고 원자적 increment-and-get 연산이 지원되는 선형성 레지스터가 있다고 가정하는 것이다. (CAS 로도 가능) 전체 순서 브로드캐스트를 통해 보내고 싶은 모든 메시지에 대해 성형성 정수로 increment-and-get 연산을 수행하고 그 값을 메시지에 붙여서 보내면 된다. 램포트 타임스탬프와는 다르게 정확한 순서를 보장한다. 메시지 4를 전달하고 6인 메시지를 받았다면 메시지 5를 기다려야 한다는 것을 알 수 있다. 노드와 네트워크 문제로 연결이 끊긴 상황을 처리하고 노드에 장애가 날 때 그 값을 복구하는데 어려움이 있다. 일반적인 선형성 일련번호 생성기에 대해 고민하다보면 필연적으로 합의 알고리즘에 도달하게 된다. 선형성 CAS 레지스터와 전체 순서 브로드캐스트는 합의와 동등하다고 증명할 수 있다.4. 분산 트랜잭션과 합의" }, { "title": "08장. 분산 시스템의 골칫거리", "url": "/posts/designing-data-chapter8/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2025-02-09 13:00:00 +0900", "snippet": " 어떤 것이든지 잘못될 가능성이 있다면 잘못된다.0. 분산 시스템의 골칫거리 분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다르다. 엔지니어로서의 우리의 임무는 모든게 잘못되더라도 사용자가 기대하는 보장을 만족시키는 제 역할을 해내는 시스템을 구축하는 것이다.1. 결함과 부분 장애 컴퓨터에 내부 결함이 발생하면 잘못된 결과를 반환하기보다는 완전히 동작하지 않기를 원한다. 단일 컴퓨터 기준 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다. (결정적이다.) 하드웨어 문제가 있으면 보통 시스템이 완전히 실패하는 결과를 낳는다. 분산 시스템 기준 네트워크 문제, 부분적인 실패, 타이밍 문제 등 다양한 문제가 발생할 수 있다. 부분 장애는 비결정적이다. 이러한 문제들은 예측하기 어렵고, 디버깅하기도 어렵다. 1.1. 클라우드 컴퓨팅과 슈퍼컴퓨팅 슈퍼 컴퓨팅 슈퍼컴퓨터에서 실행되는 작업은 보통 가끔씩 계산 상태를 지속성 있는 저장소에 체크포인트로 저장한다. 노드 하나에 장애가 발생했을 때 흔한 해결책은 그냥 전체 클러스터 작업부하를 중단하는 것이다. 슈퍼컴퓨터는 부분 장애를 전체 장애로 확대하는 방법으로 처리하는데 시스템의 어느 부분에 장애가 발생하면 그냥 전체가 죽게 한다. 분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다. 올바르게 동작하던 시스템도 시간이 지나면 어떤 부분에 결함이 생길 것이고 소프트웨어는 어떤 식으로든 그 결함을 처리해야 한다.2. 신뢰성 없는 네트워크 분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비다. 인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크다. 노드는 다른 노드로 패킷을 보낼 수 있지만 도착을 보장하지 않고 요청을 보내고 응답을 기다리는 사이에 여러 잘못이 생길 수 있다. 이런 문제를 다루는 가장 흔한 방법은 타임아웃이다.2.1. 현실의 네트워크 결함 네트워크 문제는 놀랄 만큼 흔하다. 중간 규모의 데이터센터에서 매달 12번의 네트워크 결함이 발생함을 발견했다. EC2 같은 공개 클라우드 서비스는 일시적으로 네트워크 결함이 자주 발생하는 것으로 알려져 있다. 소프트웨어는 예측하지 못하는 상황이지만 네트워크 결함을 반드시 견뎌내도록 처리할 필요는 없다. 네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야 한다. 고의로 네트워크 문제를 유발하여 시스템의 반응을 테스트해보는 것도 좋다. (카오스 몽키)2.2. 결함 감지 결함을 자동으로 감지할 수 있어야 한다. 네트워크는 불확실성이 있기 때문에 노드가 동작 중인지 아닌지 구별하기 어렵다. TCP가 패킷이 전달됐다는 확인 응답을 했더라도 애플리케이션이 그것을 처리하기 전에 죽을 수도 있다. 요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.2.3. 타임아웃과 기약 없는 지연 타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다. 타임아웃이 짧으면 결함을 빨리 발견하지만 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아진다. 빠른 타임아웃은 다른 노드로 역할을 넘겨주게 되고 해당 요청이 중복되어 실행될 수도 있다. 역할이 다른 노드로 전달되어 다른 노드와 네트워크에 추가적인 부하를 준다. 비동기 네트워크는 기약 없는 지연(unbounded delay)이 있다.2.3.1. 네트워크 혼잡과 큐 대기 네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을 때까지 잠시 기다려야할 수도 있는데 이를 네트워크 혼잡(Network Congestion)이라고 부른다. 패킷이 목적지에 도착했을 때 모든 CPU가 바쁜 상태라면 운영체제 큐에 넣어둔다. TCP는 혼잡 회피, 배압이라고 하는 흐름 제어를 수행하여 데이터가 네트워크로 들어가기 전에 송신을 제어하는 부가적인 큐 대기를 할 수 있다. TCP는 타임아웃이 발생하면 손실로 간주하고 자동으로 재전송하는데 애플리케이션에서는 패킷의 손실과 재전송이 보이지 않지만 지연은 확인할 수 있다. 다양한 요인으로 네트워크 지연의 변동성에 영향을 준다. 이런 환경에서는 실험적으로 타임아웃을 선택하는 수 밖에 없다. 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 그들의 변동성을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 하는 방법이 있다.2.4. 동기 네트워크 대 비동기 네트워크 전화 통화는 회선(circuit)을 만들어 고정되고 보장된 양의 대역폭이 할당된다. (동기식 네트워크) 큐 대기가 없으므로 네트어워크 종단 지연 시간의 최대치가 고정돼 있다. - 제한 있는 지연 (bounded delay) TCP 연결의 패킷은 가용한 네트워크 대역폭을 기회주의적으로 사용한다. (비동기식 네트워크) 웹 페이지 요청, 이메일/파일 전송 처럼 순간적으로 몰리는 트래픽의 경우 TCP 패킷 교환이 적절하다. 네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 것이라고 가정하고 타임아웃의 올바른 값은 실험을 통해 결정해야 한다.3. 신뢰성 없는 시계 분산 시스템에서는 통신이 즉각적이지 않으므로 시간을 다루기 까다롭다. 메시지가 네트워크를 거쳐 전달되는 데 시간이 걸리고 네트워크의 지연 변동성 때문에 얼마나 거릴지 알 수 없다. 개별 장비는 수정 발진기(quartz oscillator)라는 시계를 갖고 있지만 다른 장비와 차이가 있을 수 있다. 네트워크 시간 프로토콜(NTP) 메커니즘으로 서버 그룹 내에 시계를 조정할 수 있게 한다. GPS로 더 정확한 시간을 동기화시킬 수 있다.3.1. 단조 시계 대 일 기준 시계 일 기준 시계(Wall-Clock Time) 모두가 같이 보는 벽 시계 created_at 기록에 적합하다. 단조 시계(Monotonic Clock vs) 나 혼자 보는 손목 시계 elapsed_time 측정에 적합하다. 리눅스 서버 ntp 동기화 설정3.1.1. 일 기준 시계 일 기준 시계는 직관적으로 시계에 기대하는 일을 한다. 어떤 달력에 따라 현재 날짜와 시간을 변환한다. 리눅스: clock_gettime(CLOCK_REALTIME) 자바: System.currentTimeMillis() 에포크(epoch)부터 흐른 초(or 밀리초) 수를 반환한다. (에포크: 1970년 1월 1일 0시 0분 0초 - UTC) 일 기준 시계는 보통 NTP로 동기화되어 한 장비의 타임스탬프는 다른 장비의 타임스탬프와 동일한 의미를 지닌다는 뜻이다. 로컬 시계가 NTP 서버보다 너무 앞서면 강제 리셋되어 과거 시점으로 거구로 뛰는 것처럼 보일 수 있다.3.1.2. 단조 시계 단조 시계는 타임아웃이나 서비스 응답 시간 같은 지속 시간(시간 구간)을 재는 데 적합하다. 리눅스: clock_gettime(CLOCK_MONOTONIC) 자바: System.nanoTime() 두 시점의 단조 시계 값을 확인하여 두 값 사이의 차이로 시간이 얼마나 흘렀는지 알 수 있다. 그러나 시계의 절대적인 값은 의미가 없다. 컴퓨터가 시작한 이래 흐른 나노초 수일 수도 있고 비슷한 어떤 것일 수도 있다. 두 대의 다른 컴퓨터에서 나온 단조 시계 값은 동일한 것을 의미하지 않기 때문에 이 둘을 비교하는 것은 의미가 없다. 여러 개의 CPU 소켓이 있는 서버는 CPU마다 독립된 타이머가 있을 수 있다. 운영체제는 차이를 보정하여 스레드가 여러 CPU에 걸쳐 스케쥴링 되더라도 시계가 단조적으로 보이게 하려고 한다. 단조성 보장은 곧이 곧대로 받아들이지 않는게 현명하다. 단조 시계의 해상도는 좋은 편이기 때문에 마이크로초나 그 이하 단위로 측정할 수 있다. 분산 시스템의 경과 시간을 재는데 단조 시계를 쓰는 것은 측정이 약간 부정확해도 민감하지 않기 때문에 일반적으로 괜찮다.3.2. 시계 동기화와 정확도 단조 시계는 동기화가 필요 없지만 일 기준 시계는 NTP 서버나 다른 외부 시간 출처에 맞춰 설정돼야 유용하다. 하드웨어 시계와 NTP는 생각보다 정확하지 않다. 컴퓨터의 수정 시계는 장비 온도에 따라 더 빠르거나 느리게 실행되는 드리프트 현상이 생긴다. 컴퓨터 시계와 NTP 서버와 차이가 심하면 동기화가 거부되거나 강제로 리셋될 수 있다. 방화벽으로 NTP 서버가 차단되어 잘못된 설정이 얼마동안 알려지지 않을 수 있다. NTP 동기화는 잘해야 네트워크 지연만큼만 좋을 수 있다. (최소 오차 35ms) 어떤 NTP 서버들은 이상이 잇거나 설정이 잘못돼서 몇 시간 정도 차이 나는 시간을 보고하고 있다. 윤초가 발생하면 1분이 길이가 59-61초가 되어 윤초를 고려하지 않고 설계된 시스템에서는 시간에 관한 가정이 엉망이 돼 버린다. 가상 장비에서 하드웨어 시계는 가상화돼서 정확한 시간 엄수가 필요한 애플리케이션에게 추가적인 어려움이 생긴다. 완전히 제어할 수 없는 장치에서 소프트웨어를 실행하면 아마도 그 장치의 하드웨어 시계를 전혀 믿을 수 없을 것이다. 유럽 금융 규제 기관 초안은 고빈도 트레이딩 펀드는 모두 그들의 시계를 UTC와 100마이크로초 이내 동기화를 요구한다. GPS, 정밀 시간 프로토콜(PTP), 세심한 배포와 모니터링 상당한 노력과 전문 기술이 필요하며 시계 동기화가 잘못될 수 있는 수많은 가능성이 존재한다. 잘못된 NTP 대몬 설정, 방화벽 NTP 트래픽 차단 등 3.3. 동기화된 시계에 의존하기 하루는 정확히 86400초가 아닐 수도 있고, 일 기준 시계가 거꾸로 갈 수도 있으며, 노드 간 시간 차이가 많이 날 수도 있다. 소프트웨어는 네트워크 결함을 가정해서 설계돼야하며 시계도 마찬가지로 고려 대상이다. 견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다. 시계가 잘못된다는 것을 눈치채기 어렵다. 동기화된 시계가 필요한 소프트웨어를 사용한다면 모든 장비 사이의 시계 차이를 모니터링해야 한다. 시계 차이가 큰 노드는 죽은 것으로 간주하고 클러스터에서 제거돼야 한다.3.3.1. 이벤트 순서화용 타임스탬프 그림 8-3 다중 리더 복제를 쓰는 데이터베이스에서 일 기준 시간을 위험하게 사용하는 예 - 291p 노드 간 시계 차이로 데이터 수정의 순서가 변경될 수 있다. 최종 쓰기 승리 (last write win, LWW) 전략으로 충돌을 해소할 수 있고 다중 리더 복제, 리더 없는 데이터베이스에서 널리 사용된다. 타임스탬프를 서버가 아니라 클라이언트에서 생성하는 구현도 있지만 LWW에 존재하는 근본적은 문제를 바꾸지는 못한다. 시계가 뒤처지는 노드는 시계가 빠른 노드가 먼저 쓴 내용을 그들 사이에 차이나는 시간이 흐를 때까지 덮어쓸 수 없기 때문에 데이터베이스 쓰기가 사라질 수 있다. 순차적인 쓰기가 빠른 시간 내에 연속으로 실행되는 것과 진짜 동시에 쓰기가 실행되는 것을 구별할 수 없다. 두 노드가 독립적으로 동일한 타임스탬프를 가진 쓰기 작업을 만들 수도 있다. 가장 최근 값을 유지하고 다른 것들을 버림으로써 충돌을 해소하고 싶더라도 최근의 정의는 로컬 일 기준 시게에 의존하며 그 시게는 틀릴 수도 있다는 것을 아는게 중요하다. 잘못된 순서화가 발생하지 않을 정도로 NTP 동기화를 정확하게 하기는 거의 불가능하다. 올바른 순서화를 위해서는 시계 출처가 측정하려고 하는 대상(네트워크 지연)보다 훨씬 더 정확해야한다. 논리적 시계 (logical clock) 진동 수정 대신 증가하는 카운터 기반 일 기준, 경과한 초 수를 측정하지 않고 이벤트의 상대적인 순서만 측정 물리적 시계 (physical clock) 일 기준 시계와 단조 시계는 실제 경과 시간을 측정 순서화 보장 336p 3.3.2. 시계 읽기는 신뢰 구간이 있다 시계 읽기를 어떤 시점으로 생각하는 것보다 어떤 신뢰 구간에 속하는 시간의 범위로 생각하는 것이 좋다. 장비의 일 기준 시계를 마이크로초, 나노초 해상도로 읽을 수 있지만 그 값이 그런 정밀성을 제공할 만큼 정확하지 않다. 로컬 네트워크에 있는 NTP 서버와 매분 동기화하더라도 부정확한 수정 시계에서 발생하는 드리프트는 쉽게 몇 ms가 될 수 있다. 공개 인터넷 NTP 서버를 사용하면 달성 가능한 최선의 정확도는 아마 수십 ms 정도이고 네트워크가 혼잡하다면 100ms 이상이 될 수 있다. 불확실성 경계는 시간 출처를 기반으로 계산할 수 있다. GPS, 컴퓨터의 원자 시계: 제조사에서 제공하는 예상 오류 범위 NTP 서버: 마지막 동기화 시간 이후로 예상되는 시간 드리프트 + NTP 서버의 불확실성 + 네트워크 왕복 시간 clock_gettime()을 호출하더라도 예상 오차를 알려주지는 않는다. 스패너의 구글 트루타임 API는 로컬 시계의 신뢰 구간을 명시적으로 보여준다. 구글 스패너 3.3.3. 전역 스냅숏용 동기화된 시계 스냅숏 격리는 작고 빠른 읽기 쓰기 트랜잭션과 크고 오래 실행되는 읽기 전용 트랜잭션 모두를 지원해야 하는 데이터베이스에서 아주 유용한 기능이다. 가장 흔한 스냅숏 격리 구현은 단조 증가하는 트랜잭션 ID가 필요하다. 스냅숏보다 나중에 쓰기가 실행됐다면 그 내용은 스냅숏 트랜잭션에게 보이지 않는다. 단일 노드 데이터베이스에서는 단순한 카운터가 트랜잭션 ID를 생성하는데 충분하다. 분산 데이터베이스는 코디네이션이 필요하다. 분산 시스템에서 작고 빠른 트랜잭션이 많으면 트랜잭션 ID 생성은 방어할 수 없는 병목이 된다. 구글 스패너 예시 트루타임 API의 시계 신뢰 구간을 사용하여 신뢰 구간이 겹치지 않는다면 트랜잭션의 우선 순위를 보장할 수 있다. A-earliest &amp;lt; A-latest &amp;lt; B-earliest &amp;lt; A-earliest 트랜잭션 타임스탬프가 인과성을 반영하는 것을 보장하기 위해 읽기 쓰기 트랜잭션을 커밋하기 전에 의도적으로 신뢰 구간의 길이만큼 기다린다. 그 데이터를 읽을지도 모르는 트랜잭션은 충분히 나중에 실행되는 게 보장되므로 신뢰 구간이 겹치지 않는다. 시계 불확실성을 가능하면 작게 유지해야하기 때문에 각 데이터센터에 GPS 수신기나 원자 시계를 배치해서 약 7ms 이내로 동기화되게 한다. 3.4. 프로세스 중단 분산 시스템에서 리더가 안전하게 쓰기를 받을 수 있는 임차권(lease) 예제 - 295p 프로그램 실행 중에 예상치 못한 중단이 있어서 오랫동안 요청이 오랫동안 멈춰있다면 이미 임차권이 만료되어 다른 노드가 리더 역할을 맡고 있을 수 있다. 단일 장비에서는 뮤텍스, 세마포어, 원자적 카운터, 락프리, 블로킹 큐 등 다양한 스레드 안전 기법을 사용할 수 있지만 분산 시스템에서는 불가능 하다. 분산 시스템의 노드는 어느 시점에 실행이 상당히 멈출 수 있다고 가정해야 하고 심지어 함수 중간에 멈출 수도 있다.3.4.1. 응답 시간 보장 명시된 시간안에 응답하는 데 실패하면 심각한 손상을 유발할 수 있는 환경에서 실행되는 소프트웨어는 데드라인이 명시된다. 프로세스가 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케쥴링 해주는 실시간 운영체제가 필요하다. 라이브러리 함수는 최악의 실행 시간을 문서화해야 한다. 동적 메모리 할당은 제한되거나 완전히 금지될 수 있다. 보장 만족의 확신을 위해 막대한 양의 테스트와 측정을 해야 한다. 프로그래밍 언어, 라이브러리, 도구의 범위를 엄격하게 제한한다. 안전이 필수적인 임베디드 장치에서 가장 흔하게 사용된다. 실시간 시스템은 무엇보다도 제때에 응답하는 것을 우선시해야 하므로 처리량이 더 낮을 수도 있다. (실시간은 고성능과 동일하지 않다.)3.4.2. 가비지 컬렉션의 영향을 제한하기 언어 런타임은 객체 할당률과 시간에 따라 남아 있는 여유 메모리 공간을 추적할 수 있으므로 언제 GC 할지와 관련된 어느정도 유연성을 갖고 있다. GC 중단을 노드가 잠시 동안 계획적으로 중단되는 것으로 간주하고 노드가 GC 하는 동안 클라이언트 요청을 다른 노드들이 처리하게 한다. 런타임이 애플리케이션에게 노드가 곧 GC 중단이 필요하다는 경고를 할 수 있다면 애플리케이션은 그 노드로 새로운 요청을 멈추고, 그 노드가 요청 처리를 완료한 후 아무 요청도 처리 하지 않는 동안 GC를실행하기를 기다릴 수 있다. GC를 클라이언트로부터 감추고 응답 시간의 상위 백분위를 줄여준다. 지연 시간에 민감한 금융 거래 시스템 중에 이 방법을 쓰는 것도 있다. 수명이 짧은 객체만 GC를 사용하고 수명이 긴 객체의 전체 GC가 필요할 만큼 객체가 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법도 있다. GC 중단을 완전히 막을 수는 없지만 애플리케이션에 미치는 영향은 유용하게 줄일 수 있다.4. 지식, 진실, 그리고 거짓말 분산 시스템은 공유 메모리가 없고 지연 변동이 있는 네트워크로 통신하여 부분 장애, 신뢰성 없는 시계, 프로세스 중단 등 다양한 문제가 있다. 분산 시스템에서 동작(시스템 모델)에 관해 정한 가저을 명시하고, 이런 가정을 만족시키는 방식으로 실제 시스템을 설계할 수 있다. 어떤 시스템 모델 내에서 알고리즘이 올바르게 동작하는지 증명할 수 있다. 기반 시스템 모델이 매우 적은 보장만 제공하더라도 신뢰성 있는 동작을 달성할 수 있다. 그러나 신뢰성 없는 시스템 모델에서 잘 동작하는 소프트웨어를 만드는 게 가능할지라도 그것이 간단하지는 않다.4.1. 진실은 다수결로 결정된다 분산 시스템은 한 노드에만 의존할 수 없고 노드에 언제든 장애가 나서 잠재적으로 시스템이 멈추고 복구할 수 없게 될 수도 있다. 여러 분산 알고리즘은 정족수(quorum), 노드들 사이의 투표에 의존한다. 노드의 과반수 이상을 정족수로 삼는 게 가장 흔하다.4.1.1. 리더와 잠금 파티션의 리더, 잠금 획득, 식별자 어떤 노드가 스스로를 리더라고 믿더라도 정족수도 반드시 동의하지는 않고 다른 노드들이 그 노드가 죽었다고 선언하면 그 노드는 강등되고 다른 리더가 이미 선출되었을 수도 있다. 임차권 잠금 예시 임차권을 가진 클라이어트가 너무 오랫동안 멈춰 있어서 임차권이 만료된다. 다른 클라이언트가 임차권을 얻어서 쓰기를 시작할 수 있다. 멈췄던 클라이언트가 여전히 유효한 임차권을 갖고 있느 것으로 잘못 알고 파일에 쓴다. 두 클라이언트의 쓰기가 충돌되고 파일이 오염된다. 4.1.2. 펜싱 토큰 잠금(임차권)을 쓸 때 자신이 잠금을 얻었다고 잘못 믿고 있는 노드가 시스템을 방해할 수 없도록 보장하기 위한 단순한 기법이 펜싱이다. 잠금 서버가 잠금이나 임차권을 승인할 때마다 펜싱 토큰을 반환하고 클라이언트가 쓰기 요청을 할 때 펜싱 토큰을 포함하도록 한다. 오랫동안 중단된 클라이언트의 임차권은 만료되어 쓰기를 거부할 수 있다. 잠금 서비스로 주키퍼를 사용하면 트랜잭션 ID zxid나 노드 버전 cversion을 펜싱토큰으로 사용할 수 있고 이들은 단조 증가가 보장된다.4.2. 비잔틴 결함 노드가 고의로 시스템의 보장을 무너뜨리기 위해 가짜 펜싱 토큰을 포함한 메시지를 보낼 수 있다. 노드들은 느리거나 응답하지 않을 수 있고 그들의 상태는 뒤쳐질 수도 있지만 노드가 응답한다면 그 노드는 진실을 말한다고 가정한다. (프로토콜의 규칙에 따라 동작한다.) 분산 시스템의 노드가 거짓말을 할지도 모른다는 위험이 있다면 훨씬 더 어려워진다. 어떤 노드가 실제로 받지 않은 특정 메시지를 받았다고 주장하는 동작을 비잔틴 결함이라고 하며 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 비잔틴 장군 문제라고 한다. 비잔틴 장군 문제 - 두 장군 문제 (304p) 일부 노드가 오작동하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 이 시스템은 비잔틴 내결함성을 지닌다. 비잔틴 내결함성을 지닌 시스템은 비잔틴 장군 문제를 해결할 수 있다. 웹 애플리케이션은 최종 사용자가 제어하는 웹브라우저 같은 클라이언ㅌ의 행동이 임의적이고 악이적이라고 예상해야 한다. SQL 인잭션, 크로스 사이트 스크립팅, CSRF, 클릭재킹, DDoS 모든 노드가 동일한 소프트웨어를 실행하고 있기 때문에 공격자가 노드 하나를 침해한다면 모든 노드를 침해할 수 있다.4.2.1. 약한 형태의 거짓말 약한 형태의 거짓말: 하드웨어 문제, 소프트웨어 버그, 잘못된 설정으로 유효하지 않은 메시지 약한 형태의 거짓말로부터 보호해주는 메커니즘을 소프트웨어에 추가하는 게 가치가 있을 수 있다. 애플리케이션 수준 프로토콜에서 체크섬을 사용한다. 사용자 입력값을 신중하게 살균(검증)한다. NTP 서버를 사용할 때는 여러 개의 서버를 사용하고 그들의 응답을 비교한다. 4.3. 시스템 모델과 현실 알고리즘은 하드웨어와 소프트웨어 설정의 세부 사항에 너무 심하게 의존하지 않는 방식으로 작성해야 한다. 시스템에서 발생할 것으로 예상되는 결함의 종류를 어떻게 정형화해야한다. 시스템 모델을 정의해서 정형화하는데 시스템 모델은 알고리즘이 가정하는 것을 기술한 추상화다. 동기식 모델: 네트워크 지연, 프로세스 중단, 시계 오차 모두 제한이 있다고 가정 부분 동기식 모델: 대부분의 시간에는 동기식으로 동작하지만 때때로 네트워크 지연, 프로세스 중단, 시계 드리프트 한계치를 초과할 수 있다고 가정 비동기식 모델: 타이밍에 대한 어떠한 가정도 할 수 없음 노드 장애를 고려하기 위한 노드용 시스템 모델 죽으면 중단하는 결함 죽으면 복구하는 결함 비잔틴 결함 4.3.1. 알고리즘의 정확성 알고리즘의 정확하다는 게 어떤 의미인지 정의하기 위해 알고리즘의 속성을 기술할 수 있다. 정확하다는 게 어떤 뜻인지 정의하고 싶은 분산 시스템의 속성을 써볼 수 있다. 펜싱 토큰이라면 유일성, 단조 일련번호, 가용성 모든 노드가 죽거나 모든 네트워크 지연이 갑자기 무한히 길어진다면 어떤 알고리즘이라도 아무것도 할 수 없다.4.3.2. 안정성과 활동성 안정성(safety): 유일성, 단조 일련번호 활동성(liveness): 가용성 활동성은 eventually 라는 단어를 포함한다. (최종적 일관성: eventually consistency) 안정성이 위반되면 그 속성이 깨진 시점을 가리킬 수 있어야 한다. 위반된 후에는 취소할 수 없다. 활동성은 시점을 정하지 못할 수는 있지만 항상 미래에 만족시킬 수 있다는 희망이 있다. 분산 알고리즘은 시스템 모델의 모든 상황에서 안정성이 항상 만족되기를 요구하는게 일반적이다. 활동성 속성에 대해서는 경고를 하는게 허용된다. - 노드의 다수가 죽지 않고 네트워크가 복구됐을 때만 요청이 응답받아야 한다.4.3.3. 시스템 모델을 현실 세계에 대응시키기 안정성 및 활동성 속성과 시스템 모델은 분산 시스템의 정확성을 따져보는 데 매우 유용하다. 그러나 현업에서 알고리즘을 구현할 때 현실의 지저분한 사실들이 여러분을 곤란하게 만든다. 죽으면 복구하는 모델에서 디스크의 데이터가 오염되거나, 하드웨어 오류, 잘못된 설정으로 데이터가 삭제된다면? 정족수 알고리즘에서 노드가 저장했던 데이터를 잊어버리고 정족수 조건을 깨뜨린다면? 알고리즘이 올바르다고 증명됐더라도 반드시 현실 시스템에서의 구현도 언제나 올바르게 동작한다고 보장할 수 없다. 그렇지만 알고리즘을 이론적으로 분석하여 실제 시스템에 오랫동안 숨어 있다가 흔치 않은 상황 때문에 가정이 깨질 때만 나타나서 알고리즘의 문제를 드러낼 수 있다. 알고리즘의 이론적 분석과 경험적 실험은 똑같이 중요하다." }, { "title": "07장. 트랜잭션", "url": "/posts/designing-data-chapter7/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2025-01-12 09:30:00 +0900", "snippet": " 트랜잭션 잘 사용하기0. 트랜잭션 데이터 시스템은 다양한 문제가 발생할 가능성이 있다. 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다. 애플리케이션은 언제라도 죽을 수 있다. 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될수 있다. 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다. 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다. 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다. 이러한 결함이 발생하여 시스템에 치명적인 장애가 발생하지 않도록 막아야 한다. - 내결함성 트랜잭션은 여러 읽기와 쓰기를 논리적 단위로 묶어서 이러한 문제를 단순화하는 메커니즘이다. 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만들어졌다. 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다. - 안정성 보장1. 애매모호한 트랜잭션의 개념 트랜잭션의 개념은 1975년 첫 번째 SQL 데이터베이스인 IBM시스템 R 에서 소개되었고 대부분의 데이터베이스는 그 스타일을 따른다. NoSQL 데이터베이스의 발전과 분산 데이터베이스가 홍보되면서 시스템의 높은 성능과 고가용성을 유지하기 위해 트랜잭션은 과거의 인식보다 많이 약화되었다.1.1. ACID의 의미 데이터베이스의 내결함성 메커니즘을 나타내는 정확한 용어를 확립하기 위해 만들어졌다. 원자성(Atomicity) 일관성(Consistency) 격리성(Isolation) 지속성(Durability) 데이터베이스의 ACID 구현은 제각각이고 어떤 데이터베이스가 ACID를 준수한다고 할 때 그 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다. (ACID는 거의 마케팅 용어가 되어버렸다.) BASE이라고 불리우는 ACID 표준을 따르지 않는 ACID보다 더 모호한 정의가 있다. 기본적으로 가용성을 제공 (Basically Available) 유연한 상태를 가짐 (Soft state) 최종적 일관성 (Eventual consistency) 1.1.1. 원자성 원자적 더 작은 부분으로 쪼갤 수 없는 무언가 다중 스레드 프로그래밍에서 한 스레드는 다른 스레드에서 절반만 완료된 연산을 관찰할 수 없다. 시스템은 연산을 실행하기 전이나 실행한 후의 상태만 있을 수 있고 중간 상태에 머물 수 없다. 원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려고 할 때 무슨일이 생기는지 설명하지 않기 때문에 ACID의 맥락에서 보면 원자성은 동시성과 관련이 없다. ACID의 원자성은 클라이언트가 여러 쓰기 작업을 실행하려고 할 때 일부만 처리된 후 결함이 생기면 무슨 일이 생기는지 설명한다. 결함 때문에 완료될 수 없다면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야한다. ACID의 원자성은 오류가 발생했을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이다. - 어보트 능력(abortability)1.1.2. 일관성 다양한 의미로 일관성이 사용된다. ACID의 일관성은 항상 진실어야하는, 데이터에 관한 어떤 선언(불변식(invariant))이 있다는 것이다. 이 일관성은 데이터베이스가 보장하는 것이 아니라 애플리케이션이 책임이다. 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다. 애플리케이션은 일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수는 있지만 데이터베이스만으로 되는 것은 아니다.1.1.3. 격리성 데이터베이스에는 여러 클라이언트가 접속이 가능하고 클라이언트들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨리게 된다. e.g. 카운터를 동시에 증가시키는 경우 ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 고전적인 데이터베이스 교과서에서는 격리성 = 직렬성 직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다. 여러 트랜잭션이 동시에 실행되면 트랜잭션이 커밋됐을 때의 결과가 순차적으로(하나씩 차례로) 실행됐을 때의 결과와 동일하도록 보장한다. 직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않고 직렬성보다 보장이 약한 스냅숏 격리를 구현했다.1.1.5. 지속성 데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다. 지속성(durability)은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다. 디스크에 저장된 데이터 구조가 오염됐을 때 복구할 수 있게 해주는 쓰기 전 로그(write-ahead log)나 비슷한 수단을 동반한다. 복제 기능이 있다면 데이터가 다른 몇 개의 노드에 복사됐다는 것으로 지속성을 의미할 수 있다. 지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야한다.1.2. 단일 객체 연산과 다중 객체 연산 원자성, 격리성의 정의는 한 번에 여러 객체를 변경할 수 있다고 가정한다. 다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다. 관계형 데이터베이스의 트랜잭션은 BEGIN TRANSACTION, COMMIT 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다. 비관계형 데이터베이스에서는 다중 put 연산을 제공하지만 반드시 트랜잭션을 보장하지는 않기 때문에 일부만 성공하고 나머지는 실패하는 부분 갱신 상태가 될 수 있다.1.2.1. 단일 객체 쓰기 저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다. 원자성: 장애 복구용 로그 격리성: 객체 잠금 어떤 데이터베이스는 Compare-And-Set 같은 연산을 제공하기도 한다. 이러한 단일 객체 연산은 동시에 같은 객체를 쓰려고할 때 갱신 손실을 방지하지만 일반적으로 사용되는 트랜잭션과는 다르다. 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.1.2.2. 다중 객체 트랜잭션의 필요성 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 여러 파티션에 걸쳐서 구현하기 어렵다. 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오가 없다. 애플리케이션에 내에서 단일 객체 연산만 사용해서 다중 객체 트랜잭션인 것처럼 구현할 수 있다. 하지만 원자성이 없으면 오류 처리가 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.1.2.3. 오류와 어보트 처리 트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다. 하지만 모든 시스템이 이 철학을 따르지는 않는다. 리더 없는 복제를 사용하는 데이터스토어는 가능 한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다는 원칙을 가지고 있기 대문에 오류 복구는 애플리케이션에게 책임이 있다. 어보트의 취지는 안전하게 재시도를 할 수 있게 하는데 있고 어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.2. 완화된 격리 수준 동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다. 동시성은 추론하기도 매우 어렵다. 그래서 데이터베이스는 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다. 직렬성 격리 여러 트랜잭션이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않음 완화된 트랜잭션 격리 일부 동시성 이슈로부터 보호해주지만 모든 이슈로부터 보호해주지 않음 미묘한 동시성 버그를 유발할 수 있음 2.1. 커밋 후 읽기 read committed 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없음) 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)2.1.1. 더티 읽기 방지 커밋되지 않은 것을 읽는 것 - 더티 읽기 사용자는 읽지 않은 새 메일은 볼 수 있지만 갱신된 개수를 볼 수 없는 경우 나중에 롤백 될 데이터를 보는 경우2.1.2. 더티 쓰기 방지 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 것 - 더티 쓰기 동시에 같은 차를 사는 경우 구매자 반영과 구매자에게 판매 송장을 전송해야하는 경우 카운터를 증가시키는 경우2.1.3. 커밋 후 읽기 구현 다양한 데이터베이스에서 기본 설저으로 제공 로우 수준 잠금 사용으로 더티 쓰기 방지 동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 하여 더티 읽기 방지 위 방법은 어렵고 지연 시간으로 인해 잘 사용되지 않음 트랜잭션이 실행 중인 객체를 읽으면 과거의 값을 읽게 함 2.2. 스냅숏 격리와 반복 읽기 트랜잭션 처리 중에 데이터를 읽으면 비반복 읽기(nonrepeatable read), 읽기 스큐(read skew) 현상이 발생될 수 있다. 읽기 스큐는 커밋 후 읽기 격리에서는 받아들일 수 있는 것으로 여겨진다. 대용량 데이터 백업, 분석 질의와 무결성 확인 등 시간이 오래 걸리는 작업일 경우 작업 중에 데이터베이스 쓰기가 발생할 수 있다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 데이터를 읽어서 해결한다. 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 보고 데이터가 다른 트랜잭션에 의해 변경되더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다. 시간이 오래걸리는 읽기 질의에 유용하다.2.2.1. 스냅숏 격리 구현 스냅숏 격리의 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다. 데이터베이스는 객체마다 여러 커밋 버전을 유지할 수 있고 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 볼 수 있다. - 다중 버전 동시성 제어 (multi-version concurrency control, MVCC) 데이터베이스가 커밋 후 읽기 격리만 필요하다면 객체마다 두 개의 버전만 유지하면 충분하지만 스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다. 포스트그레스큐엘 예시 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID 할당 트랜잭션이 데이터베이스 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션 ID가 함께 붙음 로우를 테이블에 삽입함 트랜잭션 ID를 갖는 created_by 필드가 있고 비어 있는 deleted_by가 있음 트랜잭션이 로우를 삭제하면 DB에서 지우지 않고 deleted_by 필드를 삭제 요청 트랜잭션ID로 설정 어떤 트랜잭션도 삭제된 데이터에 접근하지 않으면 표시된 로우들을 삭제 2.2.2. 일관된 스냅숏을 보는 가시성 규칙 트랜잭션은 DB에서 객체를 읽을 때 트랜잭션ID를 사용해 볼 수 있는 것을 결정한다. 동작 방식 각 트랜잭션을 실행할 때 그 시점에 진행 중인 트랜잭션의 목록을 만들고 이 트랜잭션이 쓴 데이터와 커밋은 무시 어보트된 트랜잭션이 쓴 데이터는 모두 무시 트랜잭션ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계없이 모두 무시 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있음 볼수 있는 객체의 조건 읽기 실행 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태일 경우 읽기 대상 객체가 삭제된 것으로 표시되지 않음 읽기 대상 객체가 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않음 2.2.3. 색인과 스냅숏 격리 다중 버전 데이터베이스의 색인 동작 방식 단순하게 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 한다. 현실에서는 여러 구현 세부 사항에 따라 다중 버전 동시성 제어의 성능이 결정된다. 포스트그레스큐엘 동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화 카우치DB, 데이토믹, LMDB B트리를 사용하지만 추가 전용이며 쓸 때 복사되는(append-only/copy-on-write) 변종 사용 추가 전용 B트리를 사용하면 쓰기를 실행하는 모든 트랜잭션은 새로운 B트리 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다. 컴팩션과 가비지 컬렉션을 실행하는 백그라운드 프로세스가 필요하다. 2.2.4. 반복 읽기와 혼란스러운 이름 SQL 표준에 스냅숏 격리의 개념이 없기 때문에 이름이 혼란스럽다. 반복 읽기라는 SQL 표준의 정의되어있고 Postgresql, MySQL은 표준 요구사항을 만족시키기 때문에 스냅숏 격리 수준을 반복 읽기라고 한다. 하지만 SQL 표준 격리 수준 정의에는 결함이 있다. 결과적으로 반복 읽기가 무슨 뜻인지 실제로 아는 사람은 아무도 없다.2.3. 갱신 손실 방지 동시 실행 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 - 갱신 손실 (lost update) e.g. 카운터 증가 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다. (read-modify-write 주기) 나중에 슨 것이 먼저 쓴 것을 때려눕힌다(clobber).2.3.1. 원자적 쓰기 연산 여러 데이터베이스에서 원자적 갱신 연산을 제공하여 read-modify-write 주기를 구현할 필요를 없애준다. UPDATE counters SET value = value + 1 WHERE key = &#39;foo&#39;; 원자적 연산은 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. - 커서 안정성 (cursor stability) 그냥 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 방법이 있다. 애플리케이션에서 ORM을 사용하면 read-modify-write 코드 작성이 더 쉽다.2.3.2. 명시적인 잠금 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다. 애플리케이션에서 잠금을 얻은 후 read-modify-write 를 수행하고 완료되면 잠금을 푼다.2.3.3. 갱신 손실 자동 감지 병렬 실행을 하용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이다. 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다. 애플리케이션 코드에서 데이터베이스의 기능을 쓸 필요 없도록 도와준다. 잠금, 원자적 연산을 쓰는 것을 잊어버려서 버그를 유발할 수는 있지만 자동으로 갱신 손실이 감지되어 오류가 덜 발생하게 해준다.2.3.4. Compare-and-set 이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다. UPDATE ... SET ... WHERE id = 1234 AND content = &#39;old content&#39;;- content가 일치하지 않으면 이 갱신은 적용되지 않는다. DB에서 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다. 데이터베이스의 compare-and-set 연산에 의존하기 전에 먼저 안전한지 확인이 필요하다.2.3.5. 충돌 해소와 복제 여러 노드에 데이터 복사본이 있어서 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다. 잠금과 compare-and-set 연산은 최신 복사본이 하나만 있다고 가정한다. 다중 리더, 리더 없는 복제를 사용하는 DB는 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하기 때문에 최신 복사본이 하나라는 보장을 할 수 없다. - 잠금, compare-and-set 기법 적용 불가 복제 적용 DB에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전(형제(sibling))을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합한다. 원자적 연산은 복제 상황에서도 잘 동작한다. - 특히 교환 법칙이 성립하는 연산 최종 쓰기 승리(las write wins, LWW) 충돌 해소 방법은 갱신 손실이 발생하기 쉽다. 많은 복제 DB는 LWW가 기본 설정이다.2.4. 쓰기 스큐와 팬텀 두 의사가 호출 대기를 하는데 동시에 호출 대기를 끄는 동작 스냅숏 격리가 둘 다 두 명이상 대기중으로 알려줘서 둘다 호출대기가 꺼질 수 있음2.4.1. 쓰기 스큐를 특징짓기 두 트랜잭션이 같은 객체들을 읽어서 그 중 일부를 갱신할 때 나타날 수 있다. 다른 트랜잭션이 하나의 동일한 객체를 갱신하는 특별한 경우에 더티 쓰기나 갱신 손실 이상 현상을 겪게된다. 막는 방법 여러 객체가 관련되므로 원자적 단일 객체 연산은 도움이 되지 않는다. 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 도움이되지 않는다. 어떤 DB에서는 제약 조건을 설정할 수 있다. - 트리거, 구체화 뷰를 사용 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다. 2.4.2. 추가적인 쓰기 스큐의 예 회의실 예약 시스템: 겹치는 시간 예약 확인 다중플레이어 게임: 플레이어들이 두 개의 다른 물체를 옮기는 경우 사용자명 획득: 계정 생성 시 중복 체크 이중 사용 방지: 돈이나 포인트를 더 많이 지불하는 경우2.4.3. 쓰기 스큐를 유발하는 팬덤 스큐를 유발하는 패턴 SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정한다. 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 커밋한다. 의사 예시는 1단계 로우를 잠금으로써 (SELECT FOR UPDATE) 스큐를 회피할 수 있지만 2.4.2. 예제는 1단계 질의가 아무 로우도 반환하지 않으면 SELECT FOR UPDATE는 아무것도 잠글 수 없어서 다르다. 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 한다.2.4.4. 충돌 구체화 회의실 예약의 경우 회의실과 시간 범위의 모든 조합에 대해 로우를 미리 만들어 놓고 SELECT FOR UPDATE로 잠글 수 있도록 처리할 수 있다. 이런 방법을 충돌 구체화(materializing conflict)라고 한다. 충돌을 구체화하는 방법은 알아내기 어렵고 오류가 발생하기 쉽다. 동시성 제어 메커니즘이 애플리케이션데이터 모델로 새어 나오는 것도 보기 좋지 않다. 다른 대안이 불가능할 때 최후의 수단으로 고려해야 한다. 대부분 직렬성 격리 수준이 훨씬 더 선호된다.3. 직렬성 커밋 후 읽기, 스냅숏 격리 수준 등으로 특정 경쟁 조건을 방지할 수 있지만 쓰기 스큐와 팬텀과 관련된 까다로운 케이스는 방지하기 어렵다. 직렬성 격리는 가장 강력한 격리 수준으로 여겨진다. 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다. 모든 경쟁 조건을 막아준다.3.1. 실제적인 직렬 실행 동시성을 완전히 제거하고 한 번에 하나씩만 직렬로 단일 스레드에서 실행하여 충돌을 감지하고 방지하는 문제를 완전히 회피할 수 있다. 두 가지 발전으로 이 방법이 가능해졌다. 하드웨어 성능 향상 OLTP 트랜잭션이 보통 짧고 읽기, 쓰기의 개수가 적다는 것을 알게 됨 처리량은 CPU 코어 하나의 처리량으로 제한되기 때문에 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와는 다르게 구조화돼야 한다.3.1.1. 트랜잭션을 스토어드 프로시저 안에 캡슐화 하기 데이터베이스 초창기에는 트랜잭션이 사용자 활동 전체 흐름을 포함하려는 의도가 있었다. e.g. 항공권 예약 과정 대부분의 데이터베이스는 이를 효율적으로 처리할 수 없어서 모든 OLTP 애플리케이션은 트랜잭션 내에서 대화식으로 사용자 응답을 대기하는 것을 회피함으로써 트랜잭션을 짧게 유지한다. e.g. 1개 http 요청에 1개의 트랜잭션 이런 상호작용식 트랜잭션은 애플리케이션과 데이터베이스 사이의 네트워크 통신에 많은 시간을 소비하고 동시성을 허용하지 않고 한 번에 트랜잭션 하나씩만 처리하면 처리량이 매우 저하된다. 트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 만들어두어 사용하면 네트워크나 디스크 I/O 대기 없이 매우 빨리 실행된다고 가정한다. 기존에 PL/SQL을 사용했으나 현대에는 DB 벤더사 마다 자바, 그루비, 클로저 등 언어를 지원한다. I/O 대기가 필요 없고 다른 동시성 제어 오버헤드를 회피하므로 단일 스레드로 상당히 좋은 처리량을 얻을 수 있다. 단점 DB 마다 지원 언어가 다르고 라이브러리 생태계가 빈약함 디버깅이 어려움 버전 관리 및 배포가 불편함 테스트 까다로움 모니터링 어려움 DB는 공유 자원으로 애플리케이션보다 성능에 더 민감함 3.1.2. 파티셔닝 여러 CPU 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝할 수 있다. 각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝할 수 있다면 다른 파티션과 독립적으로 실행되는 트랜잭션 처리 스레드를 가질 수 있다. CPU 코어에 각자의 파티션을 할당해서 트랜잭션 처리량을 CPU 개수에 맞춰 선형적으로 확장할 수 있다. 여러 파티션에 접근해야 하는 트랜잭션이 있다면 데이터베이스가 트랜잭션이 접근하는 모든 파티션에 걸쳐서 코디네이션 해야 한다. 여러 파티션에 걸친 트랜잭션은 코디네이션 오버헤드로 매우 느리다.3.1.3. 직렬 실행 요약 트랜잭션 직렬 실행의 제약 사항 모든 트랜잭션은 작고 빨라야한다. 활성 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다. 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 사용할 수 잇는 정도에는 엄격한 제한이 있다. 3.2. 2단계 잠금(2PL) 직렬성을 구현하는 데 널리 쓰인 유일한 알고리즘이다. (2단계 커밋과 다르다.) 더티 쓰기를 막는데 잠금이 자주 사용된다. 2단계 잠금 요구 사항 쓰기를 실행하는 트랜잭션이 없는 객체는 여러 트랜잭션에서 읽을 수 있다. 객체에 쓰려고 하면 독점적인 접근이 필요하다. 예시 트랜잭션A가 객체 하나를 읽고 트랜잭션B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A의 커밋/어보트를 기다려야 한다. 트랜잭션A가 객체에 썼고 트랜잭션B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A의 커밋/어보트를 기다려야 한다. 스냅숏 격리는 읽는 쪽은 쓰는 쪽을 막지 않고 쓰는 쪽은 읽는 쪽을 막지 않지만 2PL은 막을 수 있기 때문에 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해준다.3.2.1. 2단계 잠금 구현 MySQL, SQL 서버의 직렬성 격리 수준 구현에 사용 DB2의 반복 읽기 격리 수준 구현에 사용 읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용해 구현한다. 잠금: 공유 모드 쓰기: 독점 모드 잠금이 아주 많이 사용되어 잠금 해제를 기다리는 상황이 매우 쉽게 발생할 수 있음 - 교착 상태 교착 상태를 감지하여 트랜잭션을 어보트하고 다른 트랜잭션이 진행할 수 있게 한다.3.2.2. 2단계 잠금 성능 완화된 격리 수준보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다. 잠금을 획득하고 해제하는 오버헤드가 발생한다. 트랜잭션 경쟁 조건이 유발되어 트랜잭션 완료를 기다려야 하기 때문에 동시성이 줄어든다. 어보트된 트랜잭션은 애플리케이션에서 재시도해야 한다.3.2.3. 서술 잠금 Predicate lock 한 트랜잭션이 다른 트랜잭션의 검색 질의 결과를 바꿔버리는 팬텀 문제가 발생한다. 검색 조건에 해당하는 모든 객체를 잠근다. 접근 제한 방법 어떤 조건에 부합하는 객체를 읽기 원한다면 조건에 대한 공유 모드 서술 잠금 획득이 필요하다. 어떤 객체를 삽입, 갱신, 삭제하길 원한다면 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 한다. 서술 잠금이 다른 트랜잭션이 잡고 있다면 해당 트랜잭션의 커밋/어보트를 기다려야한다. 2단계 잠금이 서술 잠금을 포함하면 모든 형태의 쓰기 스큐와 다른 경쟁 조건을 막을 수 있어서 직렬성 격리가 된다.3.2.4. 색인 범위 잠금 index-range locking. 다음 키 잠금(next-key locking) 이라고도 한다. 서술 잠금을 간략하게 근사한 것이다. 더 많은 객체가 부합하도록 서술 조건을 간략화하는 것은 안전하다. 오후 1시 123번 방 예약 - 모든 시간 범위에 123번 방 예약에 대한 잠금 쓰기 팬텀과 쓰기 스큐로부터 보호해주는 효과가 발생한다. 서술 잠금 보다 정밀하지는 않지만 오버 헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다. 적합한 색인이 없다면 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다.3.3. 직렬성 스냅숏 격리 (SSI) 직렬성 스냅숏 격리 알고리즘은 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있다. 역사가 짧지만 새로운 기본값이 될 수 있다.3.3.1. 비관적 동시성 제어 대 낙관적 동시성 제어 2단계 잠금은 비관적이지만 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다. 트랜잭션이 커밋되기를 원할 때만 격리가 위반됐는지 확인한다. 성능이 충분하고 트랜잭션 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 성능이 좋은 경향이 있다. 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.3.3.2. 뒤처진 전제에 기반한 결정 트랜잭션은 어떤 전제를 기반으로 어떤 동작을 한다. (전제: 일관된 스냅숏) 트랜잭션에서 실행하는 질의와 쓰기 사이에 인과적 의존성이 있을 수 있다. 직렬성 격리를 제공하려면 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 트랜잭션을 어보트시켜야 한다. 질의 결과 변경 감지 방법 오래된 MVCC 객체 버전을 읽었는지 감지하기 (읽기 전에 커밋되지 않은 쓰기가 발생했음) 과거의 읽기가 영향을 미치는 쓰기 감지하기 (읽은 후에 쓰기가 실행됨) 3.3.2.1. 오래된 MVCC 읽기 감지하기 트랜잭션이 MVCC 데이터베이스에서 일관된 스냅숏에서 읽음녀 스냅숏 생성 시점에 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시한다. 트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인하고 있다면 트랜잭션은 어보트돼야 한다. 다른 트랜잭션이 진행되면서 쓰기를 실행할지 알 수 없기 때문에 커밋할 때 까지 기다려야한다. SSI는 불필요한 어보트를 피해서 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지한다.3.3.2.2. 과거의 읽기에 영향을 미치는 쓰기 감지하기 다른 트랜잭션을 차단하지 않고 2단계 잠금과 비슷한 기법을 쓸 수 있다. 트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에게 확인해야 한다. 키 범위 쓰기 잠금을 획득하는 것과 비슷하지만 읽는 쪽에서 커밋될 때까지 차단하지 않는다. 읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려줄 뿐이다. 트랜잭션을 커밋할 때 충돌되는 쓰기가 이미 커밋됐으면 어보트돼야 한다.3.3.3. 직렬성 스냅숏 격리의 성능 한 가지 트레이드오프는 트랜잭션의 읽기 쓰기를 추적하는 세밀함의 정도이다. 상세하게 추적하면 어보트해야할 트랜잭션을 정확히 판별할 수 있지만 기록 오버헤드가 심해진다. 어떤 경우에는 다른 트랜잭션에서 덮어쓴 정보를 트랜잭션이 읽어도 괜찮다. 불필요한 어보트 개수를 줄일 수 있음 2단계 잠금과 비교 다른 트랜잭션이 잠금을 기다리느라 차단될 필요가 없음 읽기 전용 질의는 잠금 없이 일관된 스냅숏 위에서 실행될 수 있음 순차 실행과 비교 단일 CPU 코어의 처리량에 제한되지 않음 직렬성 충돌 감지를 여러 장비로 분산시켜서 처리량이 높도록 확장할 수도 있음 (파운데이션DB) 여러 장비에 파티셔닝돼 있더라도 트랜잭션은 직렬성 격리를 보장하면서 여러 파티션으로부터 읽고 쓸 수 있다. 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워 SSI는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구하지만 2단계 잠금이나 순차 실행보다는 느린 트랜잭션에 덜 민감할 것이다." }, { "title": "06장. 파티셔닝", "url": "/posts/designing-data-chapter6/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2025-01-08 22:00:00 +0900", "snippet": " 대용량 데이터셋을 파티셔닝하는 몇 가지 방법을 살펴보고 인덱스와 파티셔닝이 어떻게 상호작용하는지 살펴보자클러스터에 노드를 추가하거나 제거할 때 필요한 재균형화(리밸런싱)에 대해서 살펴보자데이터베이스가 어떻게 요청을 올바른 파티션에 전달하고 질의를 실행하는지 살펴보자0. 파티셔닝 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있는 이 작업을 샤딩이라고 함 여기서 말하는 파티션은? 몽고DB, 엘라스틱서치, 솔라클라우드의 샤드에 해당함 HBase: 리전 빅테이블: 테블릿 카산드라/리악: 브이노드(vnode) 카우치베이스: 브이버켓(vBucket) 파티셔닝의 주된 이유는 확장성 비공유 클러스터(shard-nothing cluster)에서 다른 파티션은 다른 노드에 저장될 수 있음 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있음 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가함으로써 질의 처리량을 늘릴 수 있음 여러 노드에서 병렬 실행이 가능함 1. 파티셔닝과 복제 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장 여러 다른 노드에 데이터를 저장하여 내결함성을 보장할 수 있다는 의미 한 노드에 여러 파티션을 저장할 수도 있음 리더/팔로워 복제 모델을 사용한다면 각 파티션의 리더는 하나의 노드에 할당됨 각 노드는 파티션에 따라 리더이면서 팔로워가 될 수 있음 5장 복제에 대한 모든 내용은 파티션의 복제에도 동일하게 적용됨2. 키-값 데이터 파티셔닝 파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것 트래픽이 동일하다면 10대의 노드를 사용하면 한 대를 사용할 때보다 10배의 데이터를 저장, 쓰기 요청 처리가 가능 (일단 복제 무시) 특정 파티션에 데이터가 많거나 질의를 많이 받으면 쏠렸다(skewed)고 말함 파티셔닝의 효과가 매우 떨어짐 모든 부하가 한 파티션에 몰려 병목이 될 수 있음 불균형하게 부하가 높은 파티션: 핫스팟 핫스팟을 회피하는 가장 단순한 방법 레코드를 할당할 노드를 무작위로 선택 어떤 레코드를 읽으려고 할 때 레코드가 어느 노드에 저장됐는지 알 수 없으므로 모든 노드 병렬 질의 필요 단순한 키-값 모델 기본키를 통해 레코드에 접근 예시) 백과사전 알파벳 순 정렬 2.1. 키 범위 기준 파티셔닝 백과사전처럼 각 파티션에 연속된 범위의 키를 할당하는 것 각 범위들 사이의 경계를 알면 키가 어느 파티션에 속하는지 쉽게 찾을 수 있음 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있음 키 범위가 동일할 필요는 없으나 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 함 파티션의 경계는 관리자가 수동으로 선택하거나 데이터베이스에서 자동으로 선택되게 할 수 있음 파티션 재균형화 빅테이블, HBase, 리싱크DB, 몽고DB 2.4 이전 각 파티션의 키를 정렬된 순서로 저장 가능 (SS테이블, LSM 트리) 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어오는데 사용 가능 (범위 질의) 다중 칼럼 색인 키를 타임스탬프로 사용하는 경우 키 범위 기준 파티셔닝은 패턴에 따라 핫스팟을 유발하는 단점이 존재 회피 방법 키의 첫 번째 요소로 타임스탬프가 아닌 다른 것을 사용 만약 이름을 첫 번째 키로 사용한다면 이름 마다 범위 질의가 필요함 2.2. 키의 해시값 기준 파티셔닝 핫스팟 위험으로 많은 분산 데이터스토어는 키의 파티션을 정하는 데 해시 함수를 사용함 좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 함 파티셔닝용 해시 함수는 암호적으로 강력할 필요 없음 카산드라, 몽고DB: MD5 볼드모트: 파울러 놀 보(Fowler-Noll-Vo) 자바의 Object.hashCode() 함수는 데이터마다 다른 해시 반환 가능하므로 적합하지 않음 각 파티션에 해시값 변위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당 키를 파티션 사이에 균일하게 분산시키는데 적합함 키의 해시값을 사용해서 파티셔닝하면 키 범위 파티셔닝의 장점인 효율적인 범위 질의가 불가능함 인접했던 키가 여러 파티션에 흩어져 정렬 순서 유지 불가 몽고DB: 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송됨 리악/카우치베이스/볼드모트: 기본키에 대한 범위 질의 불가 카산드라 두 가지 파티셔닝 전략 사이에서 타협 테이블을 선언할 때 복합 기본키 지정 가능 키의 첫 부분에만 해싱하고 파티션을 결정 남은 컬럼은 카산드라 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용 복합 키의 첫 번째 컬럼에 대해서는 값 범위로 검색하는 질의가 불가능하지만 첫 번재 컬럼에 고정된 값을 지정하면 다른 컬럼에 대해서는 범위 스캔을 효율적으로 실행 가능 연쇄된 색을 사용하여 일대다 관계를 표현하는 모델을 만들 수 있음 소셜미디어 사용자 한 명이 수정한 문서 여러개를 올리기 user_id, updated_timestamp 키로 특정 사용자의 시간 범위 문서 읽기 2.2.1. 일관성 해싱 CDN 규모의 캐시 시스템에서 부하를 균등하게 분산시키는 방법 중앙 제어나 분산 합의가 필요하지 않도록 파티션 경계를 무작위로 선택 일관성: 복제 일관성이나 ACID 일관성과는 관련이 없으며 특별한 재균형화 방법을 의미 데이터베이스에서 실제로는 잘 동작하지 않아서 현실에서 거의 사용되지 않음 일관성 해싱이라는 단어 대신 해싱 파티셔닝이라고 하는게 더 좋음2.3. 쏠린 작업부하와 핫스팟 완화 키를 해싱해서 파티션을 정하면 핫스팟을 줄이는데 도움이 되지만 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 됨 현대의 데이터스시템 대부분은 크게 쏠린 부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야함 간단한 해결책은 키의 시작이나 끝에 임의 숫자를 붙이는 것 다른 키에 쪼개서 쓰면 읽기를 수행할 때 여러개의 키에 해당하는 데이터를 읽어서 조합하는 추가적인 작업이 필요해짐 요청이 몰리는 소수의 키에만 적용하는게 적절함 쓰기 처리량이 낮은 대다수의 키에도 적용하면 불필요한 오버헤드 발생 애플리케이션에 대한 트레이드오프를 꼼꼼히 따져볼 필요가 있음3. 파티셔닝과 보조 색인 키-값 데이터 모델은 기본키를 통해서만 레코드에 접근한다면 키로부터 파티션을 결정하고 이를 사용해 해당 키를 담당하는 파티션으로 읽기, 쓰기 요청을 전달할 수 있음 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 검색하는 수단 보조 색인은 관계형 데이터베이스의 핵심 요소이며 문서 데이터베이스에서도 흔함 많은 키-값 저장소에서는 구현 복잡도가 추가되는 것을 피하려고 보조 색인을 지원하지 않지만 보조 색인은 데이터 모델링에 매우 유용하여 일부 저장소에서 추가함 보조 색인은 검색 서버에게는 존재의 이유임 (솔라, 엘라스틱 서치) 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 존재함3.1. 문서 기준 보조 색인 파티셔닝 각 문서에는 고유 ID가 존재하고 문서 ID 기준으로 파티셔닝 됨 ID 외의 특정 필드로 데이터를 검색하려면 보조 색인이 필요함 색인을 선언하면 데이터베이스가 자동으로 색인 생성 이런 색인을 사용하면 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당 데이터베이스에 문서 쓰기 작업을 실행할 때에는 쓰려고하는 문서 ID를 포함하는 파티션만 다루면 됨 파티셔닝 색인은 지역 색인이라고 함 문서 ID에 뭔가 특별한 작업을 하지 않는다면 특정한 조건의 데이터가 동일한 파티션에 저장되리라는 보장이 없음 모든 파티션으로 질의를 보내고 얻은 결과를 모두 모아야 함 파티셔닝된 데이터베이스에 이런식으로 질의를 보내는 방법: 스캐터/개더 (scatter/gather) 보조 색인을 써서 읽는 질의는 큰 비용이 들 수 있음 데이터베이스 벤더들은 대부분 보조 색인 질의가 단일 파티션에만 실행되도록 파티셔닝 방식을 권장하지만 항상 가능하지는 않음 특히 단일 질의에서 여러 보조 색인을 사용한다면…3.2. 용어 기준 보조 색인 파티셔닝 한 노드에만 색인을 저장하면 해당 노드가 병목이 되어 파티셔닝의 목적을 해칠 수 있음 전역 색인도 파티셔닝해야 하지만 기본키 색인과는 다른식으로 할 수 있음 알파벳 순처럼 특정 알파벳 범위에 따라 파티션을 나눌 수 있음 용어에 따라 색인의 파티션이 결정함 (term-partitioned) 용어: 문서에 등장하는 모든 단어 (전문 색인에서 나옴) 용어 자체, 용어의 해시값 사용 가능 용어 해시값을 사용하여 파티셔닝하면 부하가 좀 더 고르게 분산됨 문서 파티셔닝 색인에 비해 전역(용어 파티셔닝) 색인과 비교 읽기: 용어를 포함하는 파티션으로만 요청을 보내면 됨 쓰기: 쓸 문서의 색인이 여러 파티션에 영향을 줄 수 있음 용어 파티셔닝 색인을 사용하면 쓰기에 영향받는 모든 파티션에 걸친 분산 트랜잭션을 실행해야하는데 모든 데이터베이스에서 지원하지 않음 현실적으로는 전역 보조 색인은 대개 비동기로 갱신됨 다이나모DB는 전역 보조 색인을 갱신하는데 1초도 안걸리지만 인프라 결함이 생기면 지연이 길어질 수 있음 전역 용어 파티셔닝 색인의 다른 사용처로는 리악의 검색 기능, 오라클 데이터웨어하우스 오라클 웨어하우스는 지역 색인과 전역 색인 사이에서 선택 가능4. 파티션 재균형화 시간이 지나면서 데이터베이스의 변화 발생 부하가 늘어나 CPU 추가 데이터셋 크기 증가로 디스크, 램 추가 장비 장애로 교체 이러한 변화가 발생하면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 함 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화(rebalancing)이라고 함 재균형화 요구 사항 부하가 클러스터 내 노드들에 균등하게 분배 재균형화 요청 중에도 읽기, 쓰기 요청을 받아야함 빠르게 재균형화되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 데이터가 필요 이상으로 옮겨져서는 안됨 4.1. 재균형화 전략4.1.1. 쓰면 안되는 방법: 해시값에 모드 N 연산을 실행 해시값 기준으로 파티셔닝할 때는 사용 가능한 해시값 범위를 나누고 각 범위를 한 파티션에 할당하는게 최선 모드 연산을 사용하지 않는 이유는 노드 개수가 바뀌면 대부분의 키가 노드 사이에 옮겨져야 함 재균형화 비용이 지나치게 커짐4.1.2. 파티션 개수 고정 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션을 뺏어옴 노드가 제거되면 반대로 기존 노드에 파티션 할당 파티션은 노드 사이에서 이동만고 파티션 개수와 파티션 키는 변경되지 않음 유일한 변화는 노드에 어떤 파티션이 할당되는가 뿐 파티션 할당 변경은 네트워크를 통해 대량의 데이터를 전송해야 하므로 시간이 좀 걸리기 때문에 데이터 전송중인 동안에 읽기나 쓰기가 실행되면 기존 할당된 파티션을 사용 이론상으로 클러스터에 성능이 다른 하드웨어가 섞여있다면 성능이 좋은 노드에 파티션을 더 할당하여 부하를 분산할 수 있음 보통 데이터베이스가 처음 구축될 때 파티션 개수가 고정되고 이후에 변하지 않음 이론적으로는 파티션을 쪼개거나 합치는 게 가능하지만 파티션 개수가 고정되면 운영이 단순해지므로 고정 파티션을 사용하는 데이터베이스는 파티션 분할을 지원하지 않는 경우가 많음 처음 설정된 파티션 개수가 최대 노드 개수가 되므로 미래를 예측하여 충분히 높은 값으로 선택해야 함 너무 큰 수를 선택하면 개별 파티션 관리 오버헤드로 역효과가 발생할 수 있음 전체 데이터셋 크기 변동이 심하면 파티션 개수 예측이 어려움 파티션이 너무 크면 리밸런싱 때 노드 장애로부터 복구 비용이 커짐 파티션이 너무 작으면 오버헤드가 커짐4.1.3. 동적 파티셔닝 키 범위 파티셔닝을 사용하면 파티션 경계와 개수가 고정되어 불편함 파티션 경계를 수동으로 잘못 지정하면 데이터가 A 파티션에 몰리고 B 파티션은 빌 수도 있음 HBase, 리싱크DB 처럼 키 범위 파티셔닝을 사용하는 데이터베이스는 파티션을 동적으로 생성 파티션 크기가 설정 값을 넘어서면 기존 파티션의 절반 정도의 파티션 두개로 쪼갬 데이터가 많이 삭제되어 파티션 크기가 임곗값 아래로 떨어지면 인접한 파티션과 합쳐질 수 있음 B트리 최상위 레벨에서 실행되는 작업과 유사 각 노드는 여러 파티션을 담당할 수 있음 큰 파티션이 쪼개진 후 부하 균형을 위해 분할된 파티션이 다른 노드로 이동될 수 있음 HBase의 경우 HDFS를 통해 파티션 파일이 전송됨 이점 파티션 개수가 전체 데이터 용량에 맞춰 조정됨 데이터 양이 작으면 파티션 개수가 적어도 되어 오버헤드가 적음 데이터 양이 거대해지면 개별 파티션의 크기는 설정된 최대치로 제한 단점 빈 데이터베이스는 파티션 경계의 사전 정보가 없으므로 시작할 때는 파티션이 하나임 데이터셋이 작아지면 특정 노드만 트래픽을 받고 다른 노드들은 유휴 상태가 됨 이 문제 완화를 위해 HBase, 몽고DB는 초기 파티션 집합 설정 가능 -&amp;gt; 사전 분할 키 범위 파티셔닝의 경우 사전 분할을 하려면 키가 어떤 식으로 분할될지 미리 알아야 함4.1.4 노드 비례 파티셔닝 파티션 개수 고정: 파티션 크기가 데이터셋 크기에 비례함 동적 파티셔닝: 파티션 개수가 데이터셋 크기에 비례함 카산드라, 케타마에서 사용되는 방법은 파티션 개수가 노드 대수에 비례하게 함 노드 당 할당되는 파티션 개수 고정 노드 대수가 변함이 없다면 파티션 크기가 데이터셋 크기에 비례해서 증가 노드 대수를 늘리면 파티션 크기가 작아짐 개별 파티션 크기가 안정적으로 유지됨 새 노드가 추가되면 파티션을 무작위로 선택해 반으로 분할하여 새 노드에 할당 무작위로 선택하여 균등하지 않은 분할이 생길 수 있지만 평균적으로 기존 노드의 부하에서 균등한 몫을 할당 받음 카산드라 3.0에는 불균등한 분할을 회피할 수 있는 대안적인 재균형화 알고리즘 추가됨 파티션 경계를 무작위로 선택하려면 해시 기반 파티셔닝 사용 이 방법은 일관성 해싱의 원래 정의에 가장 가깝게 대응 (204p) 최근에 나온 해시 함수를 사용하면 메타데이터 오버헤드를 낮추면서도 비슷한 효과를 얻을 수 있음4.2. 운영: 자동 재균형화와 수동 재균형화 완전 자동 재균형화, 완전 수동 재균형화 사이에 중간 지점이 있음 완전 자동 재균형화는 자동 장애 감지와 조합되면 더 위험할 수 있음 노드 과부화로 일시적인 요청 지연 노드가 죽었다고 간주하고 자동 재균형화 하려고 함 과부화 걸린 노드, 다른 노드들, 네트워크 부하를 더한 연쇄 장애 가능성 존재 재균형화에는 사람이 개입하는게 더 좋을 수 있음 카우치베이스, 리악, 볼드모트: 자동 파티션 할당을 제안하고 관리자가 확정해야함5. 요청 라우팅 여러 노드에 여러 파티션이 할당이 됨 클라이언트에서 요청을 보낼 때 어떤 노드에 요청을 해야할까? 데이터베이스에 국한되지 않은 일반적인 문제인 서비스 찾기(service discovery)의 일종 주키퍼 같은 코디네이션 서비스를 사용 각 노드는 주키퍼에 자신을 등록 주키퍼는 파티션과 노드 사이의 할당 정보를 관리 라우팅 계층이나 파티션 인지 클라이언트 같은 구성요소들은 주키퍼에 있는 정보를 구독할 수 있음 파티션 소유자 변경, 노드 추가/삭제 가 발생하면 주키퍼는 라우팅 계층에 알려서 라우팅 정보를 최신으로 유지할 수 있게 함 링크드인 에스프레소: 헬릭스로 클러스터 관리, 헬릭스는 주키퍼에 의존 HBase, 솔라클라우드, 카프카: 파티션 할당을 추적하는데 주키퍼 사용 몽고DB: 설정 서버 구현에 의존, 몽고스 데몬을 라우팅 계층으로 사용 카산드라, 리악: 가십 프로토콜을 사용하여 클러스터 상태 변화를 노드 사이에 전파, 외부 코디네이터 서비스에 의존하지 않음 카우치베이스: 재균형화를 자동으로 하지 않음. 클러스터 노드로부터 변경된 라우팅 정보를 알아내는 목시(moxi) 라우팅 계층 설정 클라이언트는 라우팅 게층을 사용하거나 임의 노드의 IP를 알아내야 함5.1. 병렬 질의 실행 분석용 대규모 병렬 처리(massively parallel processing, MPP) 관게형 데이터베이스 제품은 훨씬 더 복잡한 질의 지원 MPP 질의 최적화기는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있음 데이터셋의 많은 부분을 스캔하는 연산을 포함하는 질의는 특히 병렬 실행의 혜택을 받음" }, { "title": "05장. 복제", "url": "/posts/designing-data-chapter5/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2024-12-08 14:00:00 +0900", "snippet": " 복제를 위한 데이터 변경 처리에 대한 어려움을 알아보자 잘못될 수 있는 것과 잘못될 수 없는 것 사이의 주된 차이점은 잘못될 수 없는 것이 잘못됐을 때는 잘못을 파악하거나 고치는 것은 거의 불가능하다는 점이다. - 더글라스 애덤스, 대체로 무해함(1992)0. 복제란? 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것복제가 필요한 여러 이유들 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄 시스템에 일부 장애가 발생하더라도 지속적으로 동작할 수 있게 해 가용성을 높임 읽기 질의에 제공하는 장비의 수를 확장해 읽기 처리량을 늘림복제 알고리즘 단일 리더 (single-leader) 다중 리더 (multiple-leader) 리더 없는 (leaderless)복제 트레이드오프 동기 식 vs 비동기식 잘못된 복제본을 어떻게 처리할지 데이터베이스의 설정 옵션으로 조절 가능 세부 사항은 데이터베이스마다 다양하지만 일반적인 원리는 유사함1. 리더와 팔로워 데이터베이스 복사본을 저장하는 각 노드: 복제 서버(replica) 데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리되어야 함 리더 기반 복제 리더 = 마스터 = 프라이머리 팔로워 = 슬레이브 = 세컨더리 = 읽기 복제 서버 = 핫 대기 리더가 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송 팔로워는 리더가 처리한 것과 동일한 순서로 몯ㄴ 쓰기를 적용하여 복사본을 갱신 클라이언트 입장 읽기: 리더 or 팔로워 쓰기: 리더만 가능 1.1. 동기식 대 비동기식 복제 동기식 리더는 팔로워가 쓰기를 수신했는지 확인해줄 때까지 기다림 장점 팔로워가 일관성 있게 최신 데이터 복사본을 가지는 것을 보장함 갑자기 리더가 작동하지 않아도 데이터가 팔로워에서 계속 사용할 수 있음을 확신할 수 있음 단점 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없음 리더는 모든 쓰기를 차단하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다려야함 비동기식 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않음 보통 리더 기반 복제는 완전히 비동기식으로 구성함 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실됨 쓰기가 클라이언트에게 확인된 경우에도 지속성을 보장하지 않는다는 의미 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있음 반동기식 (semi-synchronous) 동기식의 단점 때문에 모든 팔로워를 동기식으로 구성하는 것은 비현실적 하나의 팔로워만 동기식으로 구성하고 나머지는 비동기식으로 구성 동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 됨 적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장 1.2. 새로운 팔로워 설정 복제 서버 수를 늘리거나 장애 노드의 대체를 위해서는 새로운 팔로워 설정이 필요함 무중단으로 정확한 복제본을 가지고있는 새로운 팔로워를 추가하는 방법 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅샷을 일정 시점에 가져옴. 대부분의 데이터베이스는 백업이 필요하기 때문에 이 기능을 갖추고 있음 스냅샷을 새로운 팔로워 노드에 복사 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경을 요청. 스냅샷이 리더의 복제 로그의 정확한 위치와 연관되어야 함 (위치: 로그 일련번호, 이진로그 좌표) 팔로워가 스냅샷 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 알려주고 이제부터 리더에 발생하는 데이터 변화를 처리할 수 있음 1.3. 노드 중단 처리 모든 노드는 장애 또는 계획된 유지보수(보안 패치) 등으로 중단될 수 있음 중단시간 없이 개별 노드를 재부팅할 수 있다는 점은 운영과 유지보수에 큰 장점 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것이 목표 리더 기반 복제에서 고가용성을 달성하는 방법은?1.3.1. 팔로워 장애: 따라잡기 복구 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관함 팔로워가 죽어 재시작을 하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 매우 쉽게 복구할 수 있음 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션 확인 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있음 이 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있음 1.3.2. 리더 장애: 장애 복구 이건 까다로움 팔로워 중 하나를 새로운 리더로 승격해야 함 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야함 이 과정을 장애 복구라고 함 자동 장애 복구 과정 리더가 장애인지 판단 고장, 정전, 네트워크 문제 등 다양한 문제 확실한 방법이 없기 때문에 타임아웃 시간을 설정하여 초과하면 노드가 죽은 것으로 간주함 새로운 리더 선택 선출 과정을 통해 이뤄지거나 이전에 선출된 제어 노드에 의해 새로운 노드 임명 가장 적합한 후보는 보통 이전 리더의 최신 데이터 변경사항을 가진 복제 서버 새로운 리더 사용을 위해 시스템 재설정 클라이언트는 이제 새로운 쓰기 요청을 새로운 리더에게 보내야 함 이전 리더가 돌아오면 시스템은 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있게끔 해야함 장애 복구 과정은 잘못될 수 있는 것 투성이다. 비동기식 복제를 사용하면 새로운 리더는 실패하기 전에 이전 리더의 쓰기 일부를 수신하지 못할 수 있음 새로운 리더가 충돌하는 쓰기를 수신했을지도 모름 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 특히 위험함 깃허브에서 발생한 유효하지 않은 MySQL 팔로워가 리더로 승격한 사례가 있음 데이터베이스는 새로운 Row의 기본키를 할당하기 위해 auto increment를 사용했지만 새로운 리더의 카운터는 이전 리더보다 뒤처져 있었기 때문에 이전 리더가 예전에 할당한 기본키를 재사용함 이 기본키는 레디스 저장에도 사용했디 때문에 MySQL, 레디스 간 불일치를 일으킴 일부 개인 데이터가 잘못된 사용자에게 공개됨 (GitHub availability this week) 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있음 (스플릿 브레인) 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터가 유실되거나 오염됨 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 메커니즘이 있지만 이 메커니즘을 주의깊게 설계하지 않으면 두 개의 노드가 모두 종료될 수 있음 리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은? 긴 타임아웃은 리더가 작동하지 않을 때 부터 복구까지 오랜 시간이 소요된다는 의미 너무 짧으면 불필요한 장애 복구가 있을 수 있음 이런 이유로 일부 운영팀은 소프트웨어가 자동 장애 복구를 지원하더라도 수동으로 장애 복구를 수행하는 방식을 선호함1.4. 복제 로그 구현1.4.1. 구문 기반 복제 리더는 모둔 스기 요청(구문: statement)을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송 각 팔로워는 클라이언트에서 직접 받은 것 처럼 SQL 구문을 파싱하고 실행 복제가 깨질 수 있는 사례 NOW(), RAND() 등 비결정적 함수를 호출하는 구문 정확히 같은 순서로 실행되어야하는 구문 자동증가 컬럼을 사용하는 구문 데이터베이스 데이터에 의존하는 구문 (update ... where &amp;lt;condtion&amp;gt;) 부수 효과를 가진 구문 (트리거, 스토어드 프로시저, 사용자 정의 함수) 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있음 대안 해결책 리더는 구문을 기록할 때 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체할 수 있음 그러면 팔로워 모두 같은 값을 얻을 수 있음 하지만 엣지 케이스가 존재하여 다른 복제 방법을 선호 1.4.2. 쓰기 전 로그 배송 일반적으로 모든 쓰기는 로그에 기록 로그 그조화 저장소 엔진(SS테이블, LSM트리) 로그 자체가 저장소의 주요 부분 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 함 B 트리 개별 디스크 블록에 덮어 씀 모든 변경은 쓰기전 로그(Write-ahead log: WAL)에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원 두 경우 모두 데이터베이스의 모든 쓰기를 포함하는 추가 전용 바이트열 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있음 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 함 팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어짐 postgresql, oracle 등에서 사용 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점 WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 대개 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없음 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하게끔 복제 프로토콜이 허용된다면 팔로워를 먼저 업그레이드함으로써 중단시간 없이 데이터베이스 소프트웨어 업그레이드 수행이 가능 업그레이드된 노드 중 하나를 새로운 리더로 선정하기 위해 장애 복구를 수행할 수 있음 복제 프로토콜이 버전의 불일치를 허용하지 않는다면 업그레이드할 때 중단 시간이 필요함1.4.3. 논리적(로우 기반) 로그 복제 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것 이 같은 종류의 복제 로그를 저장소 엔진의 데이터 표현과 구별하기 위해 논리적 로그라고 부름 관계형 데이터베이스용 노리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드열 삽입된 로우의 로그는 모든 컬럼의 새로운 값을 포함 삭제된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함 일반적으로 기본키, 없다면 모든 컬럼의 예전 값 로깅) 갱신된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보와 모든 컬럼의 새로운 값을 포함 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시 MySQL 이진 로그는 이 접근 방식을 사용 논리적 로그를 저장소 엔진 내부와 부리했기 때문에 하위 호환성르더 쉽게 유지할 수 있음 팔로워에서 다른 버전의 데이터베이스 소프트웨어나 다른 저장소 엔진을 실행할 수 있음 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬움 오프라인 분석, 사용자 정의 색인, 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용 변경 데이터 캡쳐 (change data capture: CDC) 1.4.4. 트리거 기반 복제 애플리케이션 코드로 복제하는 방법 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 함 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행하는 애플리케이션 코드 트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가짐 이 테이블로부터 데이터 변경을 외부 프로세스가 읽을 수 있음 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제 오라클용 데이터버스, 포스트그레스큐엘용 부카르도 다른 복제 방식보다 오버헤드가 많음 데이터베이스 내장 복제보다 버그나 제한 사항이 더 많이 발생 그럼에도 유연성 때문에 매우 유용2. 복제 지연 문제 복제는 확장성과 지연 시간에 의한 문제가 발생할 수 있음 리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능 대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업 부하면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 매력적인 옵션이 있음 리더 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리할 수 있게 해줌 간단히 팔로워를 추가하여 읽기 전용 요청 처리 가용성을 늘릴 수 있음 읽기 확장(read-scaling) 아키텍처 비동기식 복제에서만 동작 동기식으로 모든 팔로워에 복제를 시도한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기 불가능 노드가 많아지면 다운될 가능성도 커져 완전한 동기식 설정은 매우 불안 비동기 팔로워가 뒤처지면 과거 데이터를 볼 수 있음 데이터베이스에서 쓰기를 멈추고 기다리면 팔로워가 따라잡아 리더와 일치되는 효과: 최종적 일관성2.1. 자신이 쓴 내용 읽기 새로운 데이터를 쓸 때는 리더에게 전송하지만 데이터를 볼 때는 팔로워에서 읽을 수 있는데 이 때 쓰기를 수행한 직후 데이터를 본다면 복제 서버에 반영되어 있지 않을 수 있는 문제 사용자 입장에서 데이터가 유실된 것처럼 보일 수 있음 쓰기 후 일관성을 보장해야함 (자신의 쓰기 읽기 일관성) 사용자가 수정한 내용을 읽을 때는 리더에서 읽고 나머지는 팔로워에서 읽음 리더에서 읽을지 말지 결정하기 위한 다른 기준을 사용 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분 동안은 리더에서 모든 읽기 수행 팔로워에서 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의 금지 클라이언트에서 가장 최근 쓰기 타임스탬프를 기억할 수 있음 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있음 복제 서버가 여러 데이터센터에 분산되었다면 복잡도가 증가함 리더가 제공해야하는 모든 요청은 리더가 포함된 데이터센터로 라우팅 되어야 함 동일한 사용자가 여러 디바이스로 접근할 때 다른 문제가 발생 디바이스 간 쓰기 후 일관성이 보장이 필요함 사용자의 마지막 갱신 타임스탬프를 기억해야하는 접근 방식은 더욱 어려움 다른 디바이스에서 발생한 갱신은 알 수 없으므로 중앙집중식으로 메타데이터를 관리해야함 복제 서버가 여러 데이터센터로 분산되어 있다면 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없음 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야함 2.2. 단조 읽기 비동기식 팔로워에서 읽을 때 시간이 거꾸로 흐르는 현상 팔로워간 지연 시간 차이가 크고 질의 때마다 다른 팔로워에 데이터를 바라볼 때 발생할 수 있음 각 사용자의 읽기를 동일한 복제 서버에서 수행되게 하여 단조 읽기를 달성할 수 있음 단조 읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 더 강한 보장임2.3. 일관된 순서로 읽기 데이터 A -&amp;gt; B 간의 순서나 인과가 있을 때 데이터 A: 지연이 긴 팔로워에게 전달 데이터 B: 지연이 거의 없는 팔로워에게 전달 위와 같은 상황이면 데이터 B가 데이터 A보다 먼저 읽게 될 수 있음 이 현상을 방지하기 위해 일관된 순서로 읽기가 보장되어야 함 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보기 때문에 이런 현상은 일어지는 않지만 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서가 없음 인과성이 있는 쓰기는 동일한 파티션에 기록되게끔 하는 방법 일부 애플리케이션에서는 효율적이지 않음2.4. 복제 지연을 위한 해결책 최종된 일관성 시스템이라면 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척하는 것이 문제 해결 방안 - 쓰기 후 읽기 애플리케이션에서 해결하는 방식이 있지만 코드로 다루기에는 너무 복잡하여 버그 발생 가능성이 높음 올바른 작업 수행을 위해 데이터베이스를 신뢰할 수 있는 이유 - 트랜잭션 단일 노드 트랜재션은 존재했지만 분산 데이터베이스에서는 트랜잭션 성능과 가용성이 너무 비싸기 때문에 최종적 일관성을 사용해야한다는 주장이 존재함3. 다중 리더 복제 리더가 하나만 존재하는 리더 기반 복제의 경우 리더가 죽으면 데이터베이스 쓰기가 불가함 쓰기 허용 노드를 하나 이상 두는 것으로 확장하는 것 다중 리더 설정 (마스터 마스터, 액티브 액티브) 각 리더는 동시에 다른 리더의 팔로워 역할도 함3.1. 다중 리더 복제의 사용 사례 다중 데이터센터의 경우 각 데이터센터에 리더가 하나씩 있고 각 리더별 팔로워를 둠 데이터센터 간 복제는 리더가 다른 데이터센터의 리더에게 변경 사항을 복제함 데이터베이스에서 기본적으로 다중 리더 설정 제공하거나 외부 구현 도구를 사용하기도 함 동일한 데이터를 다른 데이터센터에서 동시에 변경하여 쓰기 충돌이 발생할 수 있기 때문에 반드시 해소해야함3.1.1. 오프라인 작업을 하는 클라이언트 인터넷이 끊어진 동안 애플리케이션이 동작해야하는 경우 디바이스에 리더처럼 동작하는 로컬 데이터베이스가 존재 디바이스에서 로컬 데이터베이스로 쓰기 요청 디바이스에서 데이터센터의 각 리더에게 비동기 쓰기 복제 요청 디바이스 상에서 복제 서버 간 다중 리더 복제를 비동기 방식으로 수행하는 프로세스 (동기화)3.1.2. 협업 편집 구글 독스 편집 충돌 없음을 보장하려면 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻어야 함 다른 사용자가 같은 문서를 편집하려면 첫번재 사용자의 변경이 커밋되고 잠금이 해제될 때 까지 기다려야함 리더에서 트랜잭션을 사용하는 단일 리더 복제와 동일 더 빠른 협업을 위해 변경 단위를 매우 작게하여 잠금을 피할 수 있음 여러 사용자가 동시 편집이 가능하지만 충돌 해소가 필요한 경우를 포함해 다중 리더 복제에서 발생하는 모든 문제를 야기함 3.2. 쓰기 충돌 다루기 다중 리더 복제에서 제일 큰 문제는 쓰기 충돌 발생3.2.1. 동기 대 비동기 충돌 감지 단일 리더 데이터베이스에서 첫 번재 쓰기가 완료될 때까지 두 번째 쓰기를 차단하거나 두 번째 쓰기 트랜잭션을 중단하여 사용자가 재시도하게 할 수 있음 다중 리더 설정에서는 두 쓰기 모두 성공하여 충돌은 이후 특정 시점에 비동기로 감지하게 되는데 이 때 사용자에게 해소 요청을 하는 것은 너무 늦음 동기식 충돌 감지 쓰기 성공 응답을 모든 복제 서버에 복제하기를 기다림 다중 리더 복제의 주요 장점을 잃기 때문에 사실상 불가능 3.2.2. 충돌 회피 가장 간단한 충돌 처리 방법 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장하는 방법 많은 다중 리더 복제 구현 사례에서 자주 권장되는 방법 A 데이터센터가 고장나서 트래픽을 B 데이터센터로 다시 라우팅을 하거나 사용자가 다른 지역으로 이동해 현재는 다른 데이터센터가 가깝다면 리더를 변경하고 싶을 수 있음 충돌 회피 실패 다른 리더에서 동시 기록 가능성을 대처해야함 3.2.3. 일관된 상태 수렴 단일 리더 데이터베이스는 순차 쓰기 적용으로 마지막 갱신 값이 최종 값 다중 리더 설정은 쓰기 순서가 존재하지 않아 최종 값이 명확하지 않음 수렴(convergent) 방식으로 충돌 해소 모든 변경이 복제되 모든 복제 서버에 동일한 최종 값이 전달되게 해야 한다는 의미 각 쓰기 고유 ID를 부여하고 가장 높은 ID를 가진 쓰기를 고르고 다른 쓰기는 버림 타임스탬프를 사용하는 경우 최종 쓰기 승리 대중적이지만 데이터 유실 위험 존재 각 복제 서버에 고유 ID를 부여하고 가장 높은 ID의 복제 서버에서 생긴 쓰기가 우선 적용 데이터 유실 가능성 존재 어떻게든 값을 병합 e.g. 사전 순으로 정렬한 후 연결 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존하고 애플리케이션에서 코드로 충돌 해소3.2.4. 사용자 정의 충돌 해소 로직 애플리케이션에 따라 적합한 충돌 해소 방법이 다르기 때문에 대부분 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직 작성 쓰기 수행 중 충돌을 감지하면 충돌 핸들러 호출 사용자에게 충돌 내용을 표시하지 않고 백그라운드 프로세스에서 빠르게 실행 읽기 수행 중 충돌을 감지하면 모든 충돌 쓰기를 저장 읽을 때 여러 버전의 데이터가 반환되어 애플리케이션에서 사용자에게 보여주거나 자동 해소 3.3. 다중 리더 복제 토폴로지 복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명 두 리더가 있다면 가능한 토폴로지는 하나뿐이지만 리더가 둘 이상이라면 다양한 토폴로지가 가능 전체 연결 토폴로지 가장 일반적인 토폴로지 모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송 원형 토폴로지 MySQL 기본 제공 각 노드가 하나의 노드로 부터 쓰기를 받고 쓴 이후에 다른 한 노드에 전달 별 모양 토폴로지 지정된 루트 노드가 다른 모든 노드에 쓰기 전달 트리로 일반화 가능 원형 / 별 문제점 쓰기는 모든 복제 서버에 도달하기 전에 여러 노드를 거쳐야함 노드들은 다른 노드로부터 받은 데이터 변경 사항을 전달해야 함 무한 복제 루프를 방지하기 위해 각 노드에는 고유 식별자가 있고 복제 로그에서 각 쓰기는 거치는 모든 노드의 식별자가 태깅 데이터를 받았을 때 자신의 식별자 태깅 여부로 변경 사항 무시 가능 한 노드에 장애 발생 시 다른 노드 간 복제 메시지 흐름에 방해를 줌 장애 노드가 복구될 때까지 통신 불가 토플로지는 장애 노드를 회피하게끔 재설정 가능 이런 재설정은 대부분 수동으로 수행해야함 메시지가 여러 경로를 따라 이동할 수 있으면 단일 장애점을 피할 수 있기 때문에 조금 더 빽빽하게 연결한 토폴로지의 내결함성이 훨씬 더 좋음 전체 연결 문제점 일부 네트워크가 다른 연결보다 빠르다면 메시지 간의 추월 현상이 있을 수 있음 일관된 순서로 읽기에서 본 인과성의 문제 모든 쓰기에 타임스탬프를 추가하는 방식으로는 충분하지 않음 버전 벡터 기법으로 쓰기 이벤트를 올바르게 정렬 많은 다중 리더 복제 시스템에서 충돌 방지 기법은 제대로 구현되지 않음 다중 리더 복제 시스템을 사용할 때는 이런 문제를 인지하고 문서를 주의 깊게 읽은 다음 데이터베이스를 철저하게 테스트해 실제로 믿을 만한 보장을 제공하는지 확인하는 편이 좋음4. 리더 없는 복제 아마존의 다이나모 시스템 다이나모에서 영감을 받은 리악, 카산드라, 볼드모트 - 다이나모 스타일 직접 복제 서버에 쓰기를 하거나 코디네이터 노드가 이를 대신 수행하기도 함 리더와 다르게 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않음 설계에서 이런 차이는 데이터베이스 사용 방식에 중대한 영향을 미침4.1. 노드가 다운됐을 때 데이터베이스에 쓰기 복제 서버 중 하나를 사용할 수 없을 때 장애 복구가 필요하지 않음 클라이언트가 복제 서버에 병렬로 쓰기를 전송하면 장애 서버는 쓰기를 못하지만 쓰기가 성공한 것으로 간주 장애 노드가 복구되면 데이터가 누락되었기 때문에 이 노드에서 데이터를 읽으면 오래된(outdated) 값을 얻을 수 있음 읽기 요청을 병렬로 여러 노드에 전송하고 버전으로 최신 내용을 결정4.1.1. 읽기 복구와 안티 엔트로피 복구 게획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야함 장애 복구된 노드가 누락된 쓰기를 따라잡는 방법 읽기 복구 클라이언트가 여러 노드에서 병렬 읽기 수행 시 오래된 응답 감지 가능 클라이언트는 특정 서버의 값이 오래된 값이라는 사실을 알고 해당 복제 서버에 새로운 값을 다시 기록 값을 자주 읽는 상황에 적합 안티 엔트로피 처리 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 복사 리더 기반 복제의 복제 로그와 달리 특성 순서로 쓰기를 복사하기 때문에 상당한 지연이 있을 수 있음 4.1.2. 읽기와 쓰기를 위한 정족수 n개의 복제 노드 개수 w개의 노드에서 쓰기 성공 r개의 노드에서 읽기 요청 읽을 때 최신 값을 얻을 것으로 기대, 최소한 r개의 노드 중 하나에서 최신 값을 읽을 수 있음 w + r &amp;gt; n 다이나모 스타일에서 커스텀 가능 n을 보통 홀수로 w = r = (n + 1) / 2 쓰기가 적고 읽기가 많은 작업 부하는 w = n, r = 1 읽기가 빠르지만 노드 고장 시 모든 쓰기 실패 4.2. 정족수 일관성의 한계 n개의 복제 서버가 있고 w + r &amp;gt; n이 되게끔 w, r을 선택한다면 일반적으로 모든 읽기는 최신 값을 반환할 것을 기대함 - 쓰기 노드와 읽기 노드 셋이 겹치기 때문 보통 r, w 값으로는 노드의 과반수를 선택하여 n / 2 노드 장애까지 허용되도 w + r / n이 보장되기 때문 정족수가 다수일 필요는 없고 읽기와 쓰기 동작에서 사용하는 노드 셋 중 적어도 하나의 노드만 겹치면 됨 다른 정족수 할당이 가능하기 때문에 분산 알고리즘 설계에서 어느정도 유연성을 허용 w, r을 더 작은 수로 설정 w + r &amp;lt;= n 읽기와 쓰기를 계속 n개의 노드에 전송하지만 성공 응답 수는 더 적음 w, r이 작을수록 오래된 값을 읽을 확률이 높음 w + r &amp;gt; n 오래된 값 반환 엣지 케이스 느슨한 정족수 사용하여 쓰기와 읽기가 다른 노드에서 수행되는 경우 w, r 노드가 겹치지 않을 수 있음 두개의 쓰기가 동시에 발생하면 우선순위가 분명하지 않음 안전한 해결책은 동시 쓰기를 합치는 방법밖에 없음 타임스탬프 기반으로 결정되면 clock skew로 인해 유실될 수 있음 쓰기, 읽기 동시 발생 시 쓰기는 일부 복제 서버에만 반영될 수 있음 읽기가 예전 값 or 최신 값 반환하였는지 여부가 분명하지 않음 쓰기가 일부 복제 서버에서 실패하여 전체에서 성공한 서버가 w 복제서버보다 적다면 롤백하지 않음 새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨짐 모든 과정이 올바르게 동작해도 시점 문제로 엣지 발생 가능성 존재 4.2.1. 최신성 모니터링 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 어려움 데이터베이스가 읽기 복구만 사용한다면 자주 읽히지 않는 값이 얼마나 오래된 것인지 알 수 없음 복제 서버의 오래됨(staleness)을 측정하고 매개변수에 따라 오래된 값을 읽는 비율을 예측하는 연구 있음 최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 최종적을 정량화 할 수 있어야 함4.3. 느슨한 정족수와 암시된 핸드오프 적절히 설정된 정족수가 있는 데이터베이스는 장애복구 없이 개별 노드 장애 용인 요청은 w, r개의 응답만 기다리고 n개 모든 노드의 응답을 기다릴 필요가 없어서 느려지는 것도 허용 높은 가용성과 낮은 지연 시간이 필요 가끔 오래된 값 읽기를 허용하는 사용 사례에는 리더 없는 복제 기능 매력적임 하지만 정족수의 내결함성이 없기 때문에 생기는 트레이드 오프 w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 편이 좋을까? 아니면 일단 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할까? - 느슨한 정족수 네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 홈 노드로 전송 - 암시된 핸드오프 (내 집 열쇠를 다시 찾으면 이웃이 정중하게 소파에서 일어나 집으로 돌아가라고 요청) 느슨한 정족수는 쓰기 가용성을 높이는데 유용함 w개 노드를 사용하는 동안 쓰기를 받아들일 수 있음 w + r &amp;gt; n 인 경우에도 최신 값을 읽는다고 보장할 수 없음 최신 값이 일시적으로 n 이외의 일부 노드에 기록될 수 있기 때문 느슨한 정족수는 모든 일반적인 다이나모 구현에서 선택 사항 리악 기본 활성화, 카산드라, 볼드모트 비활성화 4.4. 동시 쓰기 감지 다이나모 스타일은 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌 발생 다중 리더 복제의 쓰기 충돌과 유사 문제는 다양한 네트워크 지연과 장애로 이벤트가 다른 노드에 다른 순서로 도착할 수 있음 최종적인 일관성을 달성하기 위해 복제본들은 동일한 값이 돼야 함4.4.1. 최종 쓰기 승리(동시 쓰기 버리기) 각 복제본이 가진 예전 값을 버리고 가장 최신 값으로 덮어쓰는 방법 클라이언트가 쓰기 요청을 데이터베이스 노드에 전송할 때 다른 클라이언트에 대해서는 아는 것이 없기 때문에 어떤 이벤트가 먼저 발생했는지 확실하지 않음 이벤트의 순서가 정해지지 않았기 때문에 동시 쓰기라고 해야함 타임스탬프로 임의 순서를 정하고 최종 쓰기 승리(LWW) 알고리즘을 제공할 수 있음 카산드라: 유일하게 제공, 리악: 선택적 기능 최종 쓰기 승리 알고리즘은 최종적 수렴 달성이 목표지만 지속성 희생 동일한 키에 여러 번 동시 쓰기가 있다면 클라이언트에 모두 성공으로 보고될지라도 쓰기 중 하나만 남고 다른 쓰기는 조용히 무시됨 동시 쓰기가 아니어도 쓰기가 삭제될 수 있음 캐싱과 같이 손실된 쓰기를 허용하는 상황이 있음 손실데이터를 허용하지 않으면 LWW는 적절하지 않음 LWW로 데이터베이스를 안전하게 사용하는 유일한 방법은 키를 한번만 쓰고 이후에는 불변 값으로 다루는 것 같은 키를 동시에 갱신하는 상황을 방지 e.g. 카산드라 추천 방법: 키로 UUID를 사용함 4.4.2. “이전 발생” 관계와 동시성 두 작업 동시 수행 여부 결정 방법은? 작업 B가 작업 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면? 작업 A는 작업 B의 이전 발생(happens-before) 한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심 사실 작업이 다른 작업보다 발생하지 않으면 단순히 동시 작업이라 말함 세 가지 가능성 B 이전에 A가 발생 B가 A 이전에 발생 A, B 동시 발생 동시성인지 아닌지 알 수 있는 알고리즘이 필요 한 작업이 다른 작업 전에 발생한다면 나중 작업은 이전 작업을 덮어쓸 수 있지만 작업이 동시에 발생하면 충돌 해소 필요4.4.3. 이전 발생 관계 파악하기 어떤 작업이 다른 작업 이전에 발생했는지와 나중 작업이 이전에 수행된 작업을 알거나 의존했다는 사실 알 수 있음 서버가 모든 키에 대한 버전 번호를 유지하고 키를 기록할 때마다 버전 번호를 증가 시킴 기록한 값은 새로운 버전 번호를 가지고 저장 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환 클라이언트는 쓰기 전에 키를 읽어야 함 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고 이전 읽기에서 받은 모든 값을 합쳐야 함 쓰기 요청이 현재 모든 값을 반환하기 때문에 읽기 요청과 같을 수 있음 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있음 이보다 높은 버전 번호의 모든 값은 유지해야 함 유입된 쓰기와 동시에 발생했기 때문에 쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있음 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않음4.4.4. 동시에 쓴 값 병합 여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 함 리악은 이런 동시 값을 형제(sibling) 값이라 부름 형제 값의 병합은 다중 리더 복제 충돌 해소 문제와 본질적으로 같음 간단한 접근 방식으로 버전 번호나 타임스탬프 기반으로 하나의 값을 선택하는 방법이 있지만 데이터 손실 가능성 있음 - 그래서 애플리케이션 코드 내에서 더욱 지능적으로 대처 필요 장바구니 예제에서 형제를 병합하는 합리적인 접근 방식은 합집합 하지만 상품 제거는 합집합으로는 올바른 결과를 얻을 수 없음 두 형제 장바구니를 합치고 그중 하나만 제거하면 형제의 합집합에 제거된 상품이 다시 나타남 데이터베이스에서 삭제하지 않고 제거했음을 나타내는 버전 표시 툼스톰, 소프트 삭제 4.4.5. 버전 벡터 모든 복제본의 버전 번호 모음 키당 버전 번호뿐 아니라 복제본당 버전번호를 사용 각 복제본은 쓰기를 처리할 때 자체 버전 번호를 증가시키고 각기 다른 복제본의 버전 번호도 계속 추적해야 함 이 정보는 덮어쓸 값과 형제로 유지할 값을 나타냄 버전 벡터는 값을 읽을 때 데이터베이스 복제본에서 클라이언트로 보냄 이후에 값이 기록될 때 데이터베이스로 다시 전송해야 함 이 버전 벡터를 사용하면 데이터베이스는 덮어쓰기와 동시 쓰기를 구분할 수 있음 버전 벡터 구조는 하나의 복제본을 읽은 당므 이어 다른 복제본에 다시 쓰는 작업이 안전함을 보장함 이러면 형제가 생성되어도 형제가 올바르게 병합되는 한 데이터 손실은 없음" }, { "title": "04장. 부호화와 발전", "url": "/posts/designing-data-chapter4/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2024-11-30 14:00:00 +0900", "snippet": " Encoding and Evolution데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자. 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다. 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.1. 데이터 부호화 형식 프로그램은 최소한 두 가지 형태로 표현된 데이터를 사용해 동작 객체, 구조체, 목록, 배열, 해시, 트리 등등 CPU에서 효율적으로 접근하고 조작할 수 있도록 최적화 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 바이트열 형태로 부호화 해야함 인 메모리 -&amp;gt; 바이트열: 부호화, 직렬화, 마샬링 바이트열 -&amp;gt; 인 메모리: 복호화, 역질렬화, 역마샬링, 파싱 바이트열 (바이트 순서 표식)1.1. 언어별 형식 많은 프로그래밍 언어는 인 메모리 객체를 바이트열로 부호화하는 기능을 내장 자바: java.io.Serializable 루비: Marshal 파이썬: pickle 문제점 부호화는 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 읽기 어려움 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야하는데 종종 보안 문제의 원인이 됨 데이터 버전 관리의 어려움 효율성 1.2. JSON과 XML, 이진 변형 XML은 너무 장황하고 불필요하게 복잡하여 비판 받음 JSON은 자바스크립트의 지원과 단순하여 많이 사용됨 둘다 텍스트 형식으로 사람이 읽을 수 있음 문제점 수(number) 부호화에 대한 애매함 JSON은 정수와 부동소수점을 구별하지 않고 정밀도를 지정하지 않음 2^53 보다 큰 정수는 IEEE 754 배정도 수 에서 정확하게 표현할 수 없으므로 이런 수는 파싱할 때 부정확해질 수 있음 유니코드는 잘 지원하나 바이트는 지원하지 않음 Base64 인코딩으로 제한을 피하는 방법이 있지만 정공법은 아니고 데이터 크기가 증가함 필수는 아니지만 스키마를 지원하지만 구현하기가 상당히 난해함 1.3. 이진 부호화 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식을 사용해야하는 부담감이 덜함 XML은 장황하고, JSON은 이진 형식에 비해 많은 공간을 사용하여 각 포맷에 사용가능한 이진 부호화가 개발됨 JSON: 메시지팩, BSON, BJSON, UBJSON, BISON, 스마일 등 XML: WBXML, 패스트 인포셋 틈새 시장에 채택되었으나 널리 채택되지는 않음 데이터타입 셋을 확장했지만 데이터 모델은 변경하지 않고 유지 부호화 대상 예제 { &quot;userName&quot;: &quot;Martin&quot;, &quot;favoritNumber&quot;: 1337, &quot;interests&quot;: [&quot;daydreaming&quot;, &quot;hacking&quot;]} 1.4. 스리프트와 프로토콜 버퍼 스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요 스키마를 각 라이브러리에 해당하는 형식으로 작성하고 다양한 프로그래밍 언어로 변환한 클래스를 생성하여 어플리케이션에서 부호화/복호화가 가능 JSON을 이진 부호화한 메시지 팩보다 더 다양한 형식으로 부호화가 가능 스리프트 바이너리 프로토콜 59 바이트 필드 타입 주석 길이 주석 문자열 ASCII 또는 UTF-8 부호화 필드 이름은 없고 필드 태그 컴팩트 프로토콜 34 바이트 필드 타입과 태그 숫자를 바이트로 줄임 가변 길이 정수를 사용해서 부호화 1337: 8바이트 -&amp;gt; 2바이트 각 바이트의 상위 비트는 앞으로 더 많은 바이트가 있는지 나타냄 -64 ~ 63: 1바이트 부호화 -8192 ~ 8191: 2바이트 부호화 프로토콜 버퍼 33 바이트 컴팩트 프로토콜과 비슷 required, optional, repeated 등 키워드가 존재함 1.4.1. 필드 태그와 스키마 발전 각 필드는 태그 숫자로 식별하고 데이터 타입을 주석으로 작성 필드 값을 설정하지 않은 경우는 부호화 레코드에서 생략 부호화된 데이터는 필드 이름을 전혀 참조하지 않기 때문에 스키마에서 필드 이름은 변경할 수 있음 필드 태그는 모든 부호화된 데이터를 인식 불가능하게 만들 수 있기 때문에 변경할 수 없음 새로운 태그 번호를 부여하는 방식으로 새로운 필드 추가 가능 예전 코드에서 새로운 코드로 기록한 데이터를 읽으려는 경우 해당 필드를 무시할 수 있음 데이터 타입 주석은 파서가 몇 바이트를 건너뛸수 있는지 알려줘 상위 호환성을 유지함 각 필드에 고유한 태그 번호가 있으면 태그 번호가 계속 같은 의미를 가지고 있기 때문에 새로운 코드가 예전 데이터를 항상 읽을 수 있음 하위 호환성을 유지하려면 새로운 필드를 추가하면 optional로 하거나 기본값을 가져야함 필드를 삭제할 때는 상/하위 호완성을 위해 optional 필드만 삭제하고 같은 태그 번호를 사용하지 않음1.4.2. 데이터타입과 스키마 발전 데이터 타입을 변경하는 것은 불가능하지는 않지만 값이 정확하지 않거나 잘릴 위험이 있음 32비트 정수에서 64비트 정수로 변경하면? 파서가 누락된 비트를 0으로 채울 수 있음 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있음 새로운 코드가 기록한 데이터를 예전 코드가 읽는 경우 예전 코드는 값을 유지하기 위해 32비트 변수를 계속 사용하여 잘리게 됨 프로토콜 버퍼에는 목록이나 배열 데이터 타입이 없지만 repeated 표시자가 존재함 레코드에 동일한 필드 태그가 여러번 나타남 optional 필드를 repeated 필드로 변경해도 문제가 없음 이진 데이터를 읽는 새로운 코드는 0~1개의 엘리먼트가 있는 목록으로 보게 됨 새로운 데이터를 읽는 예전 코드는 목록의 마지막 엘리먼트만 보게 됨 덮어 써지는 개념인듯 뭐가 멋진 건지는 진짜 모름 스리프트에는 전용 목록 데이터 타입이 있음 목록 엘리먼트의 데이터 타입을 매개변수로 받음 단일 값에서 다중 값으로 변경을 허용하지 않지만 중첩된 목록을 지원한다는 장점이 있음 1.5. 아브로 아브로도 부호화할 데이터 구조를 지정하기 위해 스키마 사용 Avro IDL, JSON 기반 스키마에 태그 번호가 존재하지 않음 앞에 살펴본 모든 부호화 중 길이가 가장 짧음 데이터 타입을 식별하기 위한 정보가 없음 부호화는 단순히 연결된 값으로 구성됨 아브로를 이용해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터 타입을 미리 파악해야함 읽는 코드가 기록한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있음을 의미 읽기, 쓰기 스키마 불일치 시 복호화가 정확하지 않다는 의미 1.5.1. 쓰기 스키마와 읽기 스키마 쓰기 스키마: 데이터를 아브로로 부호화할 때 알고 있는 스키마 버전을 사용해 데이터를 부호화 읽기 스키마: 데이터를 복호화할 때 데이터가 특정 스키마로 복호화하길 기대 어플리케이션 코드는 스키마에 의존함 복호화 코드는 애플리케이션을 빌드하는 동안 스키마로부터 생성됨 핵심 아이디어 쓰기 스카마와 읽기 스키마가 동일하지 않아도 되며 호환만 가능하면 됨 쓰기/읽기 스키마를 살펴본 다음 쓰기 스키마에서 읽기 스키마로 데이터를 변환해 그 차이를 해소 필드 순서가 달라도 스키마 해석에서 이름으로 필드를 일치시키기 때문에 문제 없음 데이터를 읽을 때 읽기 스키마에는 없고 쓰기 스키마에 존재하는 필드를 만나면 무시함 읽기 스키마에 존재하지만 쓰기 스키마에 포함되어 있지 않은 필드는 읽기 스키마에 선언된 기본값으로 채움 1.5.2. 스키마 발전 규칙 아브로의 상위 호환성: 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음 아브로의 하위 호환성: 새로운 버전의 읽기 스키마와 예전 버전의 쓰기 스키마를 가질 수 있음 호환성을 유지하기 위해서는 기본값이 있는 필드만 추가, 삭제 가능 새로운 스키마에 기본값이 있는 필드를 추가했다면 예전 스키마로 기록된 레코드를 읽으면 기본값으로 채워짐 기본값이 없는 필드를 추가하면 새로운 읽기는 에전 쓰기가 기록된 데이터를 읽을 수 없기 때문에 하위 호환성이 깨짐 기본값이 없는 필드를 삭제하면 예전 읽기는 새로운 쓰기가 기록된 데이터를 읽을 수 없기 때문에 상위 호환성이 깨짐 필드에 null을 허용하여면 유니온 타입을 사용해야 함 장황하지만 nullable, notnull을 명확하게 표현 가능 유니온 타입과 기본값 여부로 optional, required 표현 가능 필드의 데이터 타입 변경 가능 필드 이름도 변경 가능하지만 조금 까다로움 읽기 스키마는 필드 이름의 별칭을 포함할 수 있고 이를 통해 스키마 필드 이름을 매치할 수 있음 즉 필드 이름 변경은 하휘 호환성이 있지만 상위 호환성은 없다는 의미 유니온 타입 엘리먼트 추가하는 것도 하위 호환성은 있지만 상위 호환성은 없음1.5.3. 그러면 쓰기 스키마는 무엇인가? 읽기는 특정 데이터를 부호화한 쓰기 스키마를 어떻게 알 수 있을까? 모든 레코드에 전체 스키마를 포함시킬 수 없음 스키마는 부호화된 데이터보다 훨씬 클 가능성이 있기 때문 예시 많은 레코드가 있는 대용량 파일 동일한 스키마로 부호화된 수백만 개 레코드를 포함한 큰 파일을 저장할 때 파일 시작 부분에 한 번만 쓰기 스키마를 포함 시킴 개별적으로 기록된 레코드를 가진 데이터베이스 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에 스키마 버전 목옥을 유지 레코드를 가져와 버전 번호를 추출하여 버전 번호에 해당하는 쓰기 스키마를 가져와서 남은 레코드를 복호화 함 네트워크 연결을 통해 레코드 보내기 연결 설정에서 스키마 버전 합의 가능 이후 연결을 유지하는 동안 합의된 스키마를 사용 Avro RPC 1.5.4. 동적 생성 스키마 아브로 스키마는 스키마에 태그 번호가 포함되어 있지 않아 동적 생성 스키마에 더 친숙함 관계형 데이터베이스 데이터를 이진 형식으로 덤프한다면? 아브로 스키마를 JSON 형태로 쉽게 생성 가능 각 데이터베이스 테이블에 형태에 맞게 스키마를 생성하고 각 컬럼은 레코드의 필드가 됨 데이터베이스의 컬럼 이름은 아브로 필드 이름에 매핑 데이터베이스 스키마가 변경된다면 갱신된 데이터베이스 스키마로부터 새로운 아브로 스키마를 생성하고 새로운 아브로 스키마로 데이터를 내보냄 새로운 데이터를 읽는 사람은 레코드가 변경된 사실을 알게 되지만 필드 이름으로 식별되기 때문에 갱신된 쓰기 스키마는 여전히 읽기 스키마와 매칭 가능 스리프트나 프로토콜 버퍼를 사용한다면 필드 태그를 수동으로 할당해야함 데이터베이스 스키마가 변경되면 관리자는 데이터베이스 컬럼 이름과 필드 태그 매칭을 수동으로 갱신해야함 동적 생성이 스리프트, 프로토콜 버퍼의 설계 목표가 아니었음 1.5.5. 코드 생성과 동적 타입 언어 스리프트, 프로토콜 버퍼는 코드 생성에 의존 언어별 효율적인 인메모리 구조, IDE에서 타입 확인 및 자동 완성 가능 자바스크립트, 루비, 파이썬 등 동적 타입 언어는 명시적 컴파일 단계가 없기 때문에 코드 생성이 중요하지 않음 -&amp;gt; 좀 귀찮음 아브로는 정적 타입 언어를 위한 코드 생성을 선택적으로 제공 코드 생성을 하지 않더라도 객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 JSON 파일처럼 데이터를 볼 수 있음 아파치 피그 같은 동적 타입 데이터 처리 언어와 함께 사용할 때 유용함 피그에서는 아브로 파일만 있으면 즉시 분석 가능 스키마를 생각하지 않고도 아브로 형식으로 출력 파일에 파생 데이터 기록 가능 1.6. 스키마의 장점 프로토콜 버퍼, 스리프트, 아브로 스키마는 XML 스키마나 JSON 스키마보다 간단하며 더 자세한 유효성 검사 규칙 지원 및 광범위한 프로그래밍 언어 지원 많은 데이터 시스템이 독자적인 이진 부호화 구현 관계형 데이터베이스: ODBC, JDBC API 필드 이름 생략 가능하여 크기가 훨씬 작을 수 있음 스키마는 유용한 문서화 형식 복호화 할 때 스키마가 필요하기 때문에 최신 상태인지 확신할 수 있음 스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전에 상위/하위 호환성을 확인 가능 정적 타입 프로그래밍 언어 사용자에게 스키마로부터 코드를 생성하는 기능은 유용함 컴파일 시점 타입 체크 가능 스키마를 잘 발전 시키면 스키마리스, 문서모델이 제공하는 것처럼 동일한 종류의 유연성 제공, 데이터나 도구 지원도 더 잘 보장됨 위와 같은 도구가 없다면…?http://sjava.net/2015/10/%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-unsigned-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0/2. 데이터플로 모드 데이터플로는 매우 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 아주 많은데 그 중 보편적인 방법을 살펴본다2.1.데이터베이스를 통한 데이터플로 데이터베이스에 쓰는 데이터를 부호화하고 데이터베이스에서 읽는 데이터를 복호화 함 읽기는 동일 프로세스의 최신 버전 데이터베이스에 저장하는 일: 미래의 자신에게 메시지를 보내는 일 하위 호환성이 없으면 이전에 기록한 내용을 미래의 자신이 복호화 할 수 없음 애플리케이션이 롤링 배포 등으로 변경되는 환경이라면 데이터베이스의 값이 새로운 버전으로 쓰여지고 예전 코드로 읽을 가능성이 있기 때문에 상위 호환성도 필요함 레코드 스키마에 새로운 필드를 추가하고 새로운 코드는 새로운 필드를 위한 값을 데이터베이스에 쓰려고하면 여러 부호화 형식은 알지 못하는 필드 보존은 지원하지만 때로는 애플리케이션 차원에서 신경 써야하는 사레도 있음 애플리케이션에서 데이터베이스 값을 모델 객체로 복호화하고 나중에 이 모델 객체를 다시 재부호화 하면 알지 못하는 필드가 유실될 수 있음 2.1.1. 다양한 시점에 기록된 다양한 값 애플리케이션이 새로 배포하면 예전 버전을 새로운 버전으로 완전히 대체할 수 있지만 데이터베이스는 그렇지 않음 오래된 데이터는 그 이후로 명시적으로 다시 쓰지 않는 한 원래 부호화 상태로 있음 데이터가 코드보다 더 오래 산다 (Data outlives code) 데이터베이스 마이그레이션은 가능하지만 값비싼 작업이기 때문에 대부분 관계형 데이터베이스는 null을 기본값으로 갖는 새로운 컬럼을 추가하는 간단한 스키마 변경을 허용 링크드인 에스프레소 DB는 아브로를 사용함 스키마 발전은 기본 저장소가 여러 가지 버전의 스키마로 부호화된 레코드를 포함해도 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 보이게 함2.1.2. 보관 저장소 백업 목적이나 데이터 웨어하우스로 적재하기 위해 데이터베이스 스냅샷을 수시로 만든다면? 보통 최신 스키마를 사용해 부호화 해야함 데이터를 복사하기 때문에 데이터의 복사본을 일관되게 부호화하는 편이 나음 기록 후 변하지 않기 때문에 아브로 객체 컨테이너 파일 같은 형식이 적합 파케이와 같은 분석 친화적인 컬럼 지향 형식으로 데이터를 부호화할 좋은 기회2.2. 서비스를 통한 데이터플로: REST와 RPC 서버는 네트워크를 통해 API를 공개하고 이를 서비스라 함 웹, 모바일 디바이스, 데스크톱 컴퓨터 등 서버에 네트워크를 요청할 수 있음 http 프로토콜을 사용할 수 있지만 API는 애플리케이션마다 특화되어 있음 다른 서버가 다른 서비스의 클라이언트일 수 있음 서비스 지향 설계 (Service-Oriented Architecture, SOA) 마이크로서비스 설계 서비스 지향 및 마이크로서비스 설계의 핵심 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것 각 서비스가 자주 새로운 버전을 출시(배포)할 수 있기 때문에 서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능해야함2.2.1. 웹 서비스 REST HTTP 원칙을 토대로 한 설계 철학 간단한 데이터 타입을 강조 URL을 사용해 리소스 식별 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP 기능 사용 REST 원칙에 따라 설계된 API: RESTful Swagger로 알려진 오픈 API 같은 정의 형식을 사용해 문서를 기술함 SOAP XML 기반 프로토콜 HTTP 상에서 사용되지만 HTTP와 독립적이며 대부분 HTTP 기능을 사용하지 않음 다양한 기능을 추가한 광범위하고 복잡한 여러 관련 표준 제공 (WS-** 이라고 알려진 웹 서비스 프레임워크) 웹 서비스 기술 언어 또는 WSDL(XML 기반 언어) 사용하여 기술 정적 타입 프로그래밍 언어에는 유용하지만 동적 타입 언어에는 유용성이 떨어짐 WSDL은 사람이 읽을 수 있게 설계하지 않았고 SOAP를 수동으로 구성하기 복잡하기 때문에 도구 지원, 코드생성, IDE에 의존함 SOAP 벤더가 지원하지 않는 프로그래밍 언어는 SOAP 서비스와 통합이 어려움 2.2.2. 원격 프로시저 호출(RPC) 문제 다양한 웹 서비스는 RPC 아이디어를 기반으로 함 RPC 모델은 원격 네트워크 서비스 요청같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해줌 (위치 투명성: Location Transparency) 함수를 호출하는 것 처럼 보이지만 내부적으로는 네트워크 요청이므로 로컬 함수 호출과 다름 결함 네트워크 요청은 타임아웃으로 결과 없이 반환될 수 있음 원격 서비스로부터 응답을 받지 못한다면 요청을 제대로 보냈는지 아닌지 알 수 있는 방법이 없음 실패한 네트워크 요청을 다시 시도할 때 요청이 실제로 처리되고 응답만 유실될 수 있음 프로토콜에 멱등성을 적용하지 않으면 재시도가 여러번 수행되는 원인이 됨 네트워크 요청은 함수 호출보다 느리고 원격 서버 상황에 따라 지연 시간이 매우 다양함 네트워크 요청일 경우 모든 매개 변수를 바이트열로 부호화 해야함 RPC 프레임워크는 하나의 언어에서 다른 언어로 데이터타입을 변환해야하는데 모든 언어가 같은 타입을 가지는 것이 아니기 때문에 깔끔하지 않은 모습이 될 수 있음 2.2.3. RPC 현재 방향 스리프트와 아브로는 RPC 지원 기능을 내장하고 있음 gRPC는 프로토콜 버퍼를 이용한 RPC 구현 차세대 RPC 프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 더욱 분명히 함 피네글, Rest.li: Future, Promise로 실패 가능한 비동기 작업 캡슐화 gRPC: 하나의 요청과 하나의 응답뿐 아니라 시간에 따른 일련의 요청과 응답으로 구성된 스트림 지원 서비스 찾기 (Service Discovery) 제공 클라이언트가 특정 서비스를 찾을 수 있도록 IP 주소와 포트 번호 제공 RPC 디버깅이 어려움 최근 많은 지원이 있지만 도구에 대한 의존성이 강함 2.2.4. 데이터 부호화와 RPC의 발전 발전성이 있으려면 RPC 클라이언트와 서버를 독립적으로 변경하고 배포가 가능해야함 모든 서버를 먼저 갱신하고 나서 모든 클라이언트를 갱신해도 문제가 없다고 가정함 요청: 하위 호환성만 필요 응답: 상위 호환성만 필요 스리프트, gRPC, Avro RPC는 각 부호화 형식의 호환성 규칙에 따라 발전할 수 있음 SOAP에서 요청과 응답은 XML 스키마로 지정 발전 가능하지만 일부 미묘한 함정이 있음 (참고) RESTful은 JSON, form 형태를 요청/응답 형태로 사용 선택적 요청 매개변수 추가나 응답 객체의 새로운 필드 추가는 대게 호환성을 유지하는 변경으로 간주 2.3. 메시지 전달 데이터 플로 비동기 메시지 전달 시스템 클라이언트 요청(메시지)을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서 RPC와 비슷 메시지를 직접 전송하지 않고 임시로 메시지 브로커, 메시지 지향 미들웨어라는 중간 단계를 거쳐 전송하는 점은 데이터베이스와 유사함 일반적으로 단방향 통신으로 응답을 기대하지 않음 응답을 전송하는 것은 가능하지만 별도 채널에서 수행 장점 수신자가 사용 불가능하거나 과부화 상태라도 메시지 브로커가 버퍼 처럼 동작하여 시스템 안정성 향상 죽었던 프로세스에 다시 메시지 전달이 가능하여 메시지 유실 방지 가능 송신자의 IP, 포트 등을 알 필요 없음 하나의 메시지를 여러 수신자로 전송 가능 논리적으로 송신자(producer), 수신자(consumer) 분리 2.3.1. 메시지 브로커 과거 팁코, IBM 웹스피어, 웹메소즈 처럼 상용 기업 소프트웨어가 우위를 차지함 최근 RabbitMQ, ActiveMQ, HornetQ, NATS, Apache Kafka 등 오픈소스 구현 대중화 하나의 프로세스가 메시지를 큐/토픽으로 전송 브로커는 큐/토픽의 컨슈머/구독자에게 메시지를 전달 동일한 토픽에 여러 프로듀서와 컨슈머가 존재할 수 있음 토픽은 단방향 데이터플로만 제공 메시지 브로커는 특정 데이터 모델을 강요하지는 않음 메시지는 일부 메타 데이터를 가진 바이트열이므로 부호화 형식을 사용할 수 있음 부호화가 상하위 호환성을 모두 가진다면 프로듀서와 컨슈머를 독립적으로 변경해 배포할 수 있는 유연성을 갖게 됨2.3.2. 분산 액터 프레임워크 액터 모델은 단일 프로세스 안에서 동시성을 지원하기 위한 프로그래밍 모델 스레드를 직접 처리하는 대신 로직이 액터에 캡슐화 함 각 액터는 하나의 클라이언트나 엔티티를 나타냄 액터는 로컬 상태를 가질 수 있고 비동기 메시지의 송수신으로 다른 액터와 통신함 액터는 메시지 전달을 보장하지 않음 에러에 따라 유실될 수 있음 엑터는 한 번에 하나의 메시지만 처리하기 때문에 스레드 걱정은 필요없고 각 액터는 프레임워크와 독립적으로 실행 가능 분산 액터 프레임워크를 사용하여 여러 노드 간의 애플리케이션 확장에 사용됨 다른 노드에 있는 경우 메시지는 바이트열로 부호화되고 네트워크를 통해 전송되며 다른쪽에서 복호화 함 액터 모델은 단일 프로세스 안에서도 메시지가 유실될 수 있다고 가정하고 있기 때문에 위치 투명성은 RPC 보다 더 잘 동작 함 분산 액터 프레임워크는 메시지 브로커와 액터 프로그래밍 모델을 단일 프레임워크에 통합 액터 기반 애플리케이션에서 롤링 배포를 수행하면 상하위 호환성에 주의해야함 프레임워크 비교 아카 자바 내장 직렬화를 사용하지만 상하위 호환성을 제공하지 않음 프로토콜 버퍼 같은 부호화 형식으로 대체 가능 올리언스 사용자 정의 데이터 부호화 형식을 사용하지만 호환성 제공하지 않음 사용자 정의 직렬화 플러그인 사용 가능 얼랭 OTP 레코드 스키마를 변경하는 일은 의외로 어려움 순회식 업그레이드가 가능하지만 신중하게 계획해야 함 maps 데이터 타입은 롤링 배포를 더 쉽게 할 수 있게 만들 것 레퍼런스 모음" }, { "title": "03장. 저장소와 검색", "url": "/posts/designing-data-chapter3/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2024-11-22 01:00:00 +0900", "snippet": " 데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해 알아보자.0. 개발자가 주의해야하는 이유 사용 가능한 여러 저장소 엔진 중에 어플리케이션에 적합한 엔진을 선택하는 것이 필요 특정 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있음 (트랜잭션 / 분석) 관계형 vs NoSQL1. 데이터베이스를 강력하게 만드는 데이터 구조1.0. 색인 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요 -&amp;gt; 색인 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것 이정표 역할을 하여 원하는 데이터의 위치를 찾는데 도움을 줌 기본 데이터에서 파생된 추가적인 구조 트레이드 오프 색인을 잘 설계하여 읽기 성능의 향상 색인의 구조에 따라 데이터 쓰기 성능 하락 어플리케이션에서 질의 패턴을 이해하고 개발자와 DBA가 잘 협의하여 결정 1.1. 해시 색인 키-값 색인 매우 일반적이고 복잡한 색인을 위한 구성 요소로 유용 사전 타입과 유사 해시맵, 해시테이블1.1.1. 파일에 추가하는 전략 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략 새로운 키-값을 추가할 때마다 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야함 값을 조회하려면 해시맵을 이용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽음 비트캐스크 (Bitcask) 키를 저장하고 검색하기 위한 API를 제공하는 Erlang 어플리케이션 해시맵을 전부 메모리에 유지하기 때문에 램에 모든 키가 저장된다는 조건을 전제로 고성능 쓰기, 읽기 가능 한 번의 디스크 탐색으로 디스크에서 적재할 수 있기 때문에 사용 가능 메모리보다 더 많은 공간 사용 가능 데이터 파일의 일부가 이미 파일 시스템 캐시에 있다면 읽기에 디스크 입출력이 필요하지 않음 각 키의 값이 자주 갱신되는 상황에 적합 파일에 항상 추가만 한다면 결국 디스크 공간이 부족해짐1.1.2. 세그먼트 로그 특정 크기의 세그먼트로 로그를 나누는 방식 특정 크기의 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓰기 수행 컴팩션(compaction): 중복 키를 버리고 최신 갱신값만 유지 동시의 여러 세그먼트의 컴팩션이 가능 세그먼트가 쓰여진 후 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일에 수행 고정된 세그먼트 병합과 컴팩션은 백그라운드 스레드에서 수행 병합 후 병합된 세그먼트로 사용을 전환하고 이전 세그먼트 파일은 삭제 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖음 키를 찾을 대 최신화된 순으로 세그먼트 해시맵을 확인 병합으로 적은 세그먼트 수를 유지하여 많은 해시맵을 확인할 필요 없음1.1.3. 실제 구현에서 중요한 문제 파일 형식 레코드 삭제 고장 복구 부분적으로 레코드 쓰기 동시성 제어1.1.4. 제한 사항 메모리에 저장하기 대문에 키가 너무 많으면 문제가 됨 디스크를 사용하면? 성능 이슈 확장 비용 이슈 해시 충돌 이슈 범위 질의에 효율적이지 않음 개별 키 조회 필요 1.2. SS 테이블과 LSM 트리1.2.1. SS 테이블 정렬된 문자열 테이블 (Sorted String Table) 각 키는 병합된 세그먼트 파일 내에 한 번만 나타나야함 장점 (vs 해시 색인) 정렬된 순서로 세그먼트를 병합하고 새로운 세그먼트 파일도 키로 정렬되어 있음 파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없음 정렬이 되어 있기 때문에 특정 키의 오프셋만 알고 있으면 대략적인 위치를 알 수 있음 읽기 요청은 요청 범위 내에서 여러 키값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축하여 색인의 각 항목은 압축된 블록의 시작을 가르킴 디스크 공간을 절약하고 압축은 I/O 대역폭 사용도 줄임 1.2.2. SS 테이블 생성과 유지 메모리에 정렬된 구조를 저장 레드 블랙 트리 / AVL 트리 임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있음 쓰기가 들어오면 인메모리 균형 트리 데이터구조에 추가 멤테이블 (memtable) 멤테이블이 커지면 SS테이블 파일로 디스크에 기록 멤테이블이 이미 정렬된 키값쌍을 유지하고 있기 때문에 효율적으로 수행 가능 새로운 SS테이블 파일은 가장 최신 세그먼트가 됨 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록 읽기 요청하면 멤테이블에서 키를 찾음 -&amp;gt; 디스크 최신 세그먼트 순서 가끔 세그먼트 병합, 컴팩션을 백그라운드에서 수행 데이터베이스가 고장나면 디스크로 기록되지 않은 최신 쓰기가 손실됨 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크에 유지해야함 복원할 때만 필요하기 때문에 순서 정렬 필요 없음 멤테이블을 SS테이블에 기록하면 해당 로그는 버릴 수 있음 1.2.3. SS 테이블에서 LSM 트리 만들기 LSM 트리 로그 구조화 병합 트리 (Log Structured Merge Tree) 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진 -&amp;gt; LSM 저장소 엔진 루씬(Lucene) 엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진 용어 사전을 저장하기 위한 방법으로 LSM 트리 사용 키(용어) - 값(문서의 ID / 포스팅 목록) 용어와 포스팅 목록의 매핑은 SS 테이블 같은 정렬 파일에 유지 필요에 따라 백그라운드에서 병합 1.2.4. 성능 최적화 블룸 필터 (Bloom filter) 크기 계층 (Size Tiered) 레벨 컴팩션 (Leveled Compaction)1.3. B 트리 거의 대부분의 관계형 데이터베이스에서 표준 색인 구현으로 사용 많은 비관계형 데이터베이스에서도 사용 정렬된 키값 쌍을 유지하여 키값 검색과 범위 질의에 효율적 4KB의 고정 크기 블록이나 페이지로 세그먼트를 나누고 한 번에 하나의 페이지에 읽기/쓰기 수행 디스크가 고정 크기 블록으로 배열되기 때문에 하드웨어와 밀접한 관련이 있음 각 페이지는 주소나 위치를 이용해 식별 -&amp;gt; 하나의 페이지가 다른 페이지를 참조할 수 있음 색인에서 키를 찾기 시작하는 루트가 존재함 페이지는 여러 키와 하위 페이지의 참조 포함 각 하위 페이지는 키가 계속 이어지는 범위를 담당 참조 사이의 키는 해당 범위 경계가 어디인지 나타냄1.3.1. 신뢰할 수 있는 B 트리 만들기 B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 씀 데이터베이스 고장 상황에서 스스로 복구할 수 있게 만들려면 디스크 상에 쓰기 전 로그를 추가해 B 트리 구현 동시성 제어는 래치 (가벼운 잠금) 로 트리의 데이터 구조를 보호1.3.2. B 트리 최적화 페이지 덮어 쓰기와 고장 복구를 위해 쓰기 시 복사 방식을 사용 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 함 동시성 제어에도 유용 페이지에 전체 키를 저장하지 않고 축약하여 공간 절약 패이지 하나에 키를 더 많이 채우면 더 높은 분기 계수를 얻어 트리 깊이 수준을 낮을 수 있음 (B+ 트리) 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도 트리가 커지면 순서 유지에 어려움이 있음 LSM 트리는 병합 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기 더쉬움 트리에 포인터를 추가하여 양쪽 형제 페이지에 대한 참조를 가져 상위로 가지 않고 순서대로 키를 스캔할 수 있음1.3.3. B 트리와 LSM 트리 비교 구현 성숙도: B트리 쓰기: LSM 트리 읽기: B트리 어플리케이션에서 필요한 부하를 주고 적절하게 필요한 저장소 엔진을 선택해야함1.4. 기타 색인 기본키 색인 보조 색인 클러스터드 색인 커버링 색인 다중 컬럼 색인 전문 검색과 퍼지 색인2. 트랜잭션 처리나 분석? 트랜잭션 커머셜 트랜잭션: 판매, 공급 업체에 발주, 직원 급여 등 읽기, 쓰기 그룹 단위 트랜잭션이 반드시 ACID 속성을 가질 필요는 없음 지연 시간이 낮은 읽기아 쓰기를 가능하게 한다는 의미 OLTP OnLine Transaction Processing 어플리케이션에서 색인을 사용해 적은 수의 레코드를 찾을 때 사용자 입력을 기반으로 삽입/갱신할 때 OLAP OnLine Analytic Processing 많은 수의 레코드를 스캔해 해당 레코드의 일부 컬럼을 읽고 집계 통계를 계산할 때 2.1. 데이터 웨어하우징 OLTP는 어플리케이션에 직접 사용되므로 높은 가용성과 낮은 지연 시간의 트랜잭션이 기대됨 다양한 분석 질의를 위해 OLTP를 추출하고 변환하고 데이터웨어 하우스에 적재 -&amp;gt; ETL2.2. 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마 별모양 스키마 대부분 데이터 웨어하우스는 별 모양 스키마 (star schema) 사용 사실 테이블 (fact table): 특정 시각에 발생한 이벤트 차원 테이블 (demension table): 이벤트의 속성을 나타냄 (육하원칙) 사실 테이블은 일부 데이터와 차원 테이블의 외래키 참조들을 가지고 있음 눈꽃송이 모양 스키마 별 모양 스키마보다 더 정규화 되어 있음 2.3. 칼럼 지향 저장소SELECT dim_date.weekday, dim_product.category, SUM (fact_sales.quantity ) AS quantity_soldFROM fact_sales JOIN dim_date ON fact_sales.date_key = dim_date.date_key JOIN dim_product ON fact_sales.product_sk = dim_product.product_skWHERE dim_date.year = 2013 AND dim_product.category IN ( &#39;Fresh fruit&#39; , &#39;Candy&#39; )GROUP BY dim_date.weekday, dim_product.category; OLTP row 지향 데이터 배치하고 한 row의 모든 값은 서로 인접하게 저장 문서 데이터베이스에서 전체 문서는 보통 하나의 연속된 바이트 열로 저장 위 쿼리 시 모든 컬럼을 포함한 로우를 메모리 적재하고 필터링해야하여 비효율적임 데이터 웨어하우스의 사실 테이블은 100개 이상의 컬럼을 가지고 있지만 분석 질의에는 4~5개 컬럼만 사용함 컬럼 지향 저장소 모든 값을 하나의 로우에 함께 저장하지 않고 컬럼별로 모든 값을 함께 저장 질의에 사용되는 컬럼만 읽고 구분 분석이 가능하여 작업량이 줄어듬 2.3.1. 컬럼 압축 100p: 데이터를 압축하면 디스크 처리량을 더 줄일 수 있다. ????? 컬럼 지향 저장소의 많은 값은 반복해서 나타날 수 있기 때문에 압축하기 좋음 비트맵 부호화 (bitmap encoding) 컬럼에서 고유 값의 수는 로우 수에 비해 적음 n개의 고유 값을 가진 컬럼을 가져와 n개의 개별 비트맵으로 변환 고유값 하나가 하나의 비트맵이고 각 로우는 한 비트를 가짐 로우가 해당 값을 가지면 비트는 1, 아니면 0 n이 매우 작으면 로우당 하나의 비트로 저장 가능 n이 더 크면 대부분의 비트맵은 0이 더 많음 (희소 / sparse) 비트맵 색인은 데이터웨어하우스에서 일반적으로 사용되는 질의 종류에 매우 적합 2.3.2. 메모리 대역폭과 벡터화 처리 데이터 웨어하우스 질의는 디스크로부터 메모리로 데이터를 가져오는 대역폭이 큰 병목 메인 메모리에서 CPU 캐시로 가는 대역폭을 효율적으로 사용하고 CPU 명령 처리 파이프라인에서 분기 예측 실패와 버블을 피하며 최신 CPU에서 단일 명령 다중 데이터 명령(SIMD)을 사용하게끔 신경써야함 컬럼 저장소 배치는 CPU 주기를 효율적으로 사용하기에 적합 질의 엔진은 압축된 컬럼 데이터를 CPU L1 캐시에 덩어리로 나누어 가져오고 타이트 루프에서 반복 CPU는 함수 호출이 많이 필요한 코드나 각 레코드 처리를 위해 분기가 필요한 코드보다 타이트 루프를 훨씬 빨리 실행 가능 컬럼 압축을 사용하면 같은 양의 L1 캐시에 더 많은 로우를 저장할 수 있음 비트 AND, OR 같은 연산자는 압축된 컬럼 데이터 덩어리를 바로 연산할 수 있게 설계할 수 있음 벡터화 처리 2.3.3. 컬럼 저장소의 순서 정렬 로우가 저장되는 순서가 반드시 중요하지는 않고 삽입된 순서로 저장하는 방식이 가장 쉬움 SS 테이블에서 했던 것 처럼 순서를 도입해 색인 메커니즘으로 사용할 수도 있음 각 컬럼을 독립적으로 정렬할 수는 없음 -&amp;gt; 동일한 로우를 알 수 없음 컬럼별로 저장되었지만 한번에 전체 로우를 정렬해야함 정렬된 순서가 있다면 컬럼 압축에 도움이 됨 기본 정렬 컬럼에 고유 값을 많이 포함하지 않는다면 정렬 후 기본 정렬 컬럼은 연속해서 같은 값이 길게 반복됨 첫 번째 정렬 키에서 압축 효과가 가장 강력하고 이후 정렬 키는 그보다 뒤섞여 있어 반복된 값이 그렇게 길지 않음 초반 정렬된 몇 개의 컬럼을 합축하는 것은 전체적으로 여전히 이득임2.3.4. 다양한 정렬 순서 OLAP에서 여러 정렬 순서를 갖는 것은 OLTP에서 여러 2차 색인을 갖는 것과 약간 비슷 OLTP 한 곳에 모든 로우를 유지하고 2차 색인은 포인터만 포함 OLAP 포인터가 없고 값을 포함한 컬럼만 존재 2.3.5. 컬럼 지향 저장소에 쓰기 컬럼 지향 저장소는 일반적으로 읽기 질의를 더 빠르게 하지만 쓰기를 더 어렵게한다는 단점 존재 LSM 트리 처럼 모든 쓰기를 인 메모리 저장소로 이동해 정렬된 구조에 추가하고 디스크에 쓸 준비를 함 인 메모리 저장소는 로우 지향, 컬럼 지향 인지 중요하지 않음 충분히 쓰기를 모으면 컬럼 파일에 병합하고 대량으로 새로운 파일에 기록 질의는 디스크의 컬럼 데이터와 메모리의 최근 쓰기를 결합해야함 질의 최적화기는 이런 구별을 사용자에게 드러내지 않음2.3.6. 집계: 데이터 큐브와 구체화 뷰 구체화 뷰 자주 사용하는 일부 집계 (count, sum, …)를 캐시해둠 관계형 모델에서는 이런 캐시를 가상 뷰로 정의 (질의를 작성하는 단축키) 구체화 뷰(materialized view)는 디스크에 기록된 질의 결과의 복사본 원본 데이터를 변경하면 구체화 뷰 갱신이 필요해 쓰기 비용이 비쌈 데이터 큐브 (OLAP 큐브) 일반화된 구체화 뷰의 특별 사례 차원에 따라 특정 속성의 집계를 캐시함 특정 질의를 미리 계산했기 때문에 실제 질의 시 수행이 매우 빠름 특정 차원에 데이터가 존재하지 않으면 원시 데이터를 질의하는 것보다 유연성이 떨어짐 데이터 큐브와 같은 집계 값은 특정 질의에 대한 성능 향상에만 사용됨 " }, { "title": "02장. 데이터 모델과 질의 언어", "url": "/posts/designing-data-chapter2/", "categories": "Study, 데이터 중심 어플리케이션 설계", "tags": "study, data, design, architecture", "date": "2024-11-09 16:00:00 +0900", "snippet": " 소프트웨어에서 데이터를 저장, 표현, 조작하는 다양한 방법을 알아보자. 관계형 모델 문서 모델 그래프 기반 데이터 모델 1. 관계형 모델과 문서 모델1.1. 관계형 모델메인프레임 컴퓨터에서 수행된 비즈니스 데이터 처리, 트랜잭션 처리, 일괄처리를 하기 위해 사용됨.개발자는 DB 내부 데이터 표현에 대해 많이 고민해야 했지만 관계형 모델의 목표는 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것.60년대 부터 사용되기 시작했지만 요즘 대부분의 서비스들도 여전히 관계형 데이터베이스를 통해 제공됨.1.2. 객체 관계형 불일치 (일대다 관계) 객체지향 프로그래밍 언어의 확산 관계형 모델로 표현하기 복잡한 데이터 계층 구조 임피던스 불일치 json 모델 제시 NoSQL 데이터베이스 확산1.3. NoSQL오픈소스, 분산 환경, 비관계형 데이터베이스에 적절함.대규모 데이터셋, 높은 쓰기 처리량, 뛰어난 확장성을 가지고 있음.오픈소스 소프트웨어 선호도 확산.특수 질의 동작.동적이고 표현력이 풍부한 데이터 모델.관계형 + 비관계형 모델 = 다중 저장소 지속성 (polyglot persistence)1.4. 다대일과 다대다 관계중복된 데이터를 정규화하려면 참조키를 사용하는 다대일 관계가 필요함.관게형 모델은 조인이 쉽기 때문에 많이 사용됨.문서 모델에서는 조인에 대한 지원이 부족하기 때문에 많이 적합하지 않음.추천서 추천받은 사용자 이력서: 추천인의 이름, 사진 추천인의 이름 변경: 추천인이 작성한 모든 추천서에 새로운 사진 반영 추천서는 추천인의 프로필 참조1.5. 문서 데이터베이스는 역사를 반복하고 있나?70년대 가장 많이 사용된 데이터베이스는 IBM의 IMS.계층 모델을 사용. (문서 데이터베이스의 JSON 모델과 유사)조인을 지원하지 않아 다대다 관계 표현에 어려움이 있음. 데이터를 중복할 것인가, 수동으로 참조할 것인가해결책으로 네트워크 모델과 관계형 모델이 제시됨.1.5.1. 네트워크 모델계층 모델에서는 하나의 부모만 존재하지만 네트워크 모델의 레코드는 다중 부모가 있을 수 있음.최상위 레코드에서 부터 연속된 연결 경로를 따르는 방법.목록의 맨 앞에서 시작해서 원하는 레코드를 찾을 때까지 한 번에 하나의 레코드를 보는 방식.레코드 목록을 반복해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행.1.5.2. 관계형 모델관계(테이블)는 단순히 튜플(로우)의 컬렉션.중첩 데이터 구조를 여러 테이블에 데이터를 배치함.테이블의 로우로 배치된 데이터는 특정 조건에 일치만 한다면 외래키 관계에 대해 신경 쓰지 않고 읽고 쓸 수 있음.쿼리를 엔진이 알아서 최적화 해줌.1.5.3. 문서 데이터베이스와 비교관계형 모델에서는 외래키문서 모델에서는 문서 참조1.6. 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?애플리케이션 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋음. 문서와 비슷한 데이터를 관계형 데이터로 찢는 것은 복잡한 스키마와 애플리케이션 코드를 발생 시킴.애플리케이션에서 다대다 관계 처럼 상호 연결이 많은 데이터의 경우라면 관계형 모델이 더 적합함. 문서 모델을 사용하면 애플리케이션 내에 복잡한 조인 로직이 필요함.애플리케이션에서 어떤 데이터 구조를 사용하느냐에 따라 적합한 모델을 선택해야함.1.6.1. 문서 모델에서의 스키마 유연성기본적으로 JSON 데이터는 스키마를 강요하지 않음.문서 모델은 스키마리스라고 불리지만 강요하지 않을뿐 암묵적인 스키마 존재함. 쓰기 스키마: 정적(컴파일 타임) 타입 확인과 유사 읽기 스키마: 동적(런타임) 타입 확인과 유사문서 모델에서는 데이터 타입을 변경할 때 새로운 필드를 가진 문서를 작성하면 됨.관계형 모델에서는 데이터베이스에 새로운 컬럼을 먼저 추가해야함.1.6.2. 질의를 위한 데이터 지역성애플리케이션이 자주 전체 문서에 접근해야 할 때 저장소 지역성(storage locality)을 활용하면 성능 이점이 있음.지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용됨.문서를 갱신할 때 보통 전체 문서를 재작성 해야함.문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하는 것을 권장.이 성능 제한 때문에 문서 데이터베이스가 유용한 상황이 줄어듬. 구글 스패너: 부모 테이블 내에 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용하여 관계형 모델에 지역성 특성을 제공. 오라클: 다중 테이블 색인 클러스터 테이블 기능으로 지역성을 제공. HBase: 칼럼 패밀리 개념이 지역성 관리에 유사한 목적.1.6.3. 문서 데이터베이스와 관계형 데이터베이스의 통합관계형 데이터베이스인 MySQL, Postgresql 등에서 JSON 데이터 타입을 제공함.문서 데이터베이스의 리싱크DB는 관계형 조인 질의를 지원.몽고DB 드라이버는 자동으로 데이터베이스 참조를 확인. (클라이언트 조인)관계형, 문서 혼합 모델은 미래 데이터베이스들이 가야할 올바른 길.2. 데이터를 위한 질의 언어 선언형 질의 언어 SQL 목표 달성 방법이 아니라 데이터 패턴을 명시 명령형 API보다 간결하고 쉽게 작성 가능 질의를 변경하지 않고 데이터베이스 시스템 성능 향상 가능 특정 순서를 보장하지 않으므로 순서가 바뀌어도 상관없음 알고리즘이 아니라 패턴을 지정하기 때문에 병렬 실행에 적합함 명령형 질의 언어 IMS, 코다실 특정 순서로 특정 연산을 수행하도록 지시 데이터베이스는 코드가 순서에 의존하는지 확신할 수 없음 명령을 특정 순서대로 수행하게끔 지시하여 다중 코어, 다중 장비에서 병렬 처리가 매우 어려움 2.1. 웹에서의 선언형 질의스타일을 지정하는 방식의 차이 CSS: 선언형 질의 Javascript: 명령형 지의2.2. 맵리듀스 질의대량의 데이터를 처리하기 위한 프로그래밍 모델.일부 NoSQL 데이터 저장소는 제한된 형태의 맵리듀스 지원. (몽고DB)읽기 전용 질의를 수행할 때 사용.질의 로직은 처리 프레임워크가 반복적으로 호출하는 조각 코드로 표현.map, reduce 함수를 기반으로 함.2.2.1. 몽고DB 기준 map, reduce 제약 사항 두 함수는 순수 함수여야 함 입력으로 전달된 데이터만 사용 추가적인 데이터베이스 질의 수행할 수 없어야 함 부수 효과가 없어야함 이 제약으로 순서 상관없이 실행이 가능하고 장애가 발생해도 재실행 가능3. 그래프형 데이터 모델관계형 모델로도 다대다 관계를 다룰 수 있지만 데이터 간 연결이 더 복잡해지면 그래프로 데이터 모델링하기 시작하는 편이 더 자연스러움.그래프의 두 유형의 객체 정점(vertex): 노드나 엔티티 간선(edge): 관계나 호(arc)3.1. 속성 그래프3.1.1. 정점의 구성 요소 고유한 식별자 유출(outgoing) 간선 집합 유입(incoming) 간선 집합 속성 컬렉션 (key-value)3.1.2. 간선의 구성 요소 고유한 식별자 간선이 시작하는 정점 (꼬리 정점) 간선이 끝나는 정점 (머리 정점) 두 정점 간 관계 유형을 설명하는 레이블 속성 컬렉션 (key-value)3.1.3. 관계형 스키마로 속성 그래프 표현create table vertices ( vertex_id integer primary key, properties json);create table edges ( edge_id integer primary key, tail_vertex integer reference vertices (vertex_id), head_vertex integer reference vertices (vertex_id), label text, properties json);create index edges_tails on edges (tail_vertex);create index edges_heads n edges (head_vertex); 정점은 다른 정점과 간선으로 연결됨. 특정 유형과 관련 여부를 제한하는 스키마는 없음. 정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있음. 정점을 따라 앞뒤 방향으로 순회 가능. 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서 모델을 깔끔하게 유지 가능.https://www.devkuma.com/docs/neo4j/overview/3.2. 사이퍼 질의 언어속성 그래프를 위한 선언형 질의 언어.네오포제이 그래프 데이터베이스용.MATCH (person) - [:BORN_IN] -&amp;gt; () -[:WITHIN*0..] -&amp;gt; (us:Location {name: &#39;United States&#39;}), (person) - [:LIVES_IN] -&amp;gt; () -[:WITHIN*0..] -&amp;gt; (eu:Location {name: &#39;Europe&#39;})RETURN person.name데이터베이스에서 모든 사람을 훑어보는 작업을 시작으로 사람들의 출생지와 거주지를 확인해 기준에 맡는 사람들만 반환.name 속성에 색인이 있다면 동일하게 두 개의 Location 정점에서 시작해 반대 방향으로 수행도 가능. name 으로 미국과 유럽을 나타내는 두 개의 정점을 찾음. WITHIN 유입 간섭을 따라 미국과 유럽의 모든 위치 찾기 진행. 위치를 나타내는 정점 중 하나에서 BORN_IN, LIVES_IN 유입 간선을 통해 발견된 사람들을 구함.보통 선언형 질의 언어는 질의를 작성할 때 이처럼 수행에 자세히 지정할 필요가 없고 질의 최적좌기에서 효율적인 전략으로 선택해줌.3.3. SQL의 그래프 질의관계형 데이터베이스로 표현된 그래프 데이터는 SQL로 질의할 수는 있지만 질의에 필요한 조인을 미리 알고 있어야함.그래프 질의에서는 찾고자하는 정점을 찾기 전에 가변적인 여러 간선을 순회해야하여 미리 조인 수를 고정할 수 없음.재귀 공통 테이블 식 (with recursive) 를 사용할 수 있지만 사이퍼와 비교하면 문법이 매우 어려움.3.4. 트리플 저장소와 스파클트리플 저장소 모델은 속성 그래프 모델과 거의 동등.트리플 저장소에서는 모든 정보를 매우 간단한 세 부분 구문 (three-part statements) 형식으로 저장함. subject, predicate, object" }, { "title": "[fp-ts] 타입스크립트로 함수형 프로그래밍 시작하기: Eq", "url": "/posts/fp-ts-1/", "categories": "Functional Programming, fp-ts", "tags": "functional programming, fp-ts, typescript", "date": "2022-06-05 20:40:00 +0900", "snippet": "이 포스팅은 DEV Community에서 참고하여 공부하면서 정리한 문서입니다. 현재 주 개발 언어로 사용 중인 스칼라 코드가 갑작스럽게 등장할 수 있습니다.fp-tsfp-ts는 타입스크립트로 타입이 있는 함수형 프로그래밍을 할 수 있도록 제공하는 라이브러리이다.타입스크립트에서 제공하지 않는 Option, Either, IO, Task, Functor, Applicative, Monad 등 함수형 타입을 제공한다.타입 클래스 (Type Class)타입 클래스란 구현하려는 기능을 나타내는 인터페이스 혹은 API 이다. 타입스크립트에서는 타입 클래스를 인터페이스로 작성할 수 있다.먼저 동등성(equality)을 평가하는 기능을 가지고 있는 Eq 타입 클래스를 작성해보자.interface Eq&amp;lt;A&amp;gt; { readonly equals (x: A, y: A) =&amp;gt; boolean} 타입 A는 Eq 타입 클래스에 속해있으며 equals 함수에 정의되어 있다.스칼라에서는 아래와 같이 트레이트를 사용하여 작성할 수 있다.trait Eq[A] { def equals(x: A, y: A): Boolean} 트레이트는 자바의 인터페이스와 비슷하지만 더 확장된 개념으로 자바에서는 인터페이스를 구현(implementation) 한다고 하지만 스칼라에서는 트레이트를 믹스인(mixin) 한다고 한다.인스턴스 (Instance)인스턴스는 타입 클래스의 구현을 제공하며 Eq 클래스 기준으로 A 타입에 대한 구현을 제공한다.const eqNumber: Eq&amp;lt;number&amp;gt; = { equals: (x, y) =&amp;gt; x === y}eqNumber 인스턴스는 몇 가지 규칙을 지켜야 한다. 반사성(Reflexivity): x가 무엇이든 equals(x, x) === true 이어야 한다. 대칭성(symmetry): equals(x, y) === true 라면 equals(y, x) === true 이어야 한다. 전이성(Transitivity): equals(x, y) === true, equals(y, z) === true 라면 equals(x, z) === true 이다.스칼라에서는 인스턴스를 이렇게 정의할 수 있다.// implicit에 대해서는 아래에서 살펴보자...implicit val eqNumber: Eq[Int] = new Eq[Int] { override def equals(x: Int, y: Int): Boolean = x == y}다음과 같이 배열에 특정 요소가 존재하는지 평가하는 elem 함수를 정의할 수 있다.function elem&amp;lt;A&amp;gt;(E: Eq&amp;lt;A&amp;gt;): (a: A, as: Array&amp;lt;A&amp;gt;) =&amp;gt; boolean { return (a, as) =&amp;gt; as.some(item =&amp;gt; E.equals(item, a))}elem(eqNumber)(1, [1, 2, 3]) // trueelem(eqNumber)(4, [1, 2, 3]) // false elem 함수는 Eq 타입 클래스를 구현한 eqNumber 인스턴스를 사용하여 as 배열에서 a가 존재하는지 평가한다.이렇게 A에 대한 Eq 인스턴스를 인자로 넘겨서 함수에서 동등성에 대한 평가를 할 수 있다. 이 예제는 단순한 예제일 뿐이다.만약 특정 기능을 타입 클래스로 추상화 해두고 필요에 따라 구현해둔다면 로직의 재사용성과 일관성, 함수 합성 등 다양한 함수형 프로그래밍의 장점을 보게 될 것이다.스칼라에서는 이렇게 할 수 있다.def elem[A](a: A, as: Seq[A])(implicit E: Eq[A]): Boolean = { as.exists(item =&amp;gt; E.equals(item, a))}elem(1, Seq(1, 2, 3)) // trueelem(4, Seq(1, 2, 3)) // false eqNumber를 암시적(implicit)으로 정의했기 때문에 생략이 가능하다. 스칼라의 특징 중 하나이다.복합 타입에 대한 Eq 타입 클래스의 인스턴스도 정의할 수 있다.type Point = { x: number y: number}const eqPoint: Eq&amp;lt;Point&amp;gt; = { equals: (p1, p2) =&amp;gt; p1.x === p2.x &amp;amp;&amp;amp; p1.y === p2.y}반사성을 고려한다면 아래와 같이 코드를 최적화 할 수 있다.const eqPoint: Eq&amp;lt;Point&amp;gt; = { equals: (p1, p2) =&amp;gt; p1 === p2 || (p1.x === p2.x &amp;amp;&amp;amp; p1.y === p2.y)}함수 조합기 (Combinator)그런데 이렇게 모든 타입의 동등성 평가를 위한 인스턴스를 만드는 것은 너무 번거롭다.Point 타입의 프로퍼티들은 모두 number 타입이고 우리는 이미 eqNumber 인스턴스를 구현했으므로 이를 사용하여 Point 타입의 동등성 비교를 하는 것이 좋겠다.fp-ts는 이런 것들을 하기 위한 함수 조합기(combinator)를 제공한다.import {struct, Eq} from &#39;fp-ts/Eq&#39;const eqPoint: Eq&amp;lt;Point&amp;gt; = struct({ x: eqNumber, y: eqNumber})const p1: Point = { x: 1, y: 2 }const p2: Point = { x: 1, y: 2 }eqPoint.equals(p1, p2) // true 참고 문서에서 사용한 getStructEq는 deprecated 되었다. 사실 Eq도 fp-ts에서 제공하는 타입 클래스다.Point 타입을 가지는 다른 복합 타입이 있다면 eqPoint 를 조합하여 Eq 인스턴스를 정의할 수 있다.type Vector = { from: Point to: Point}const eqVector: Eq&amp;lt;Vector&amp;gt; = struct({ from: eqPoint, to: eqPoint})const v1: Vector = { from: { x: 1, y: 2 }, to: { x: 1, y: 2 }}const v2: Vector = { from: { x: 2, y: 4 }, to: { x: 1, y: 2 }}eqVector.equals(v1, v2) // falsefp-ts/Eq 패키지의 struct를 사용하여 이렇게 Eq 인스턴스를 조합할 수 있었다.배열을 위한 Eq 인스턴스를 만들기 위한 함수 조합기도 제공한다.import {getEq} from &#39;fp-ts/Array&#39;const eqArrayOfPoints: Eq&amp;lt;Array&amp;lt;Point&amp;gt;&amp;gt; = getEq(eqPoint)const points1: Array&amp;lt;Point&amp;gt; = [{x: 1, y: 1}, {x: 2, y: 2}]const points2: Array&amp;lt;Point&amp;gt; = [{x: 1, y: 1}, {x: 2, y: 2}]eqArrayOfPoints.equals(points1, points2) // true만약 어떤 타입이 있을 때 특정 프로퍼티의 동등성 비교로 해당 타입의 동등성을 평가하고 싶다면 contramap 함수 조합기를 사용할 수 있다.import {contramap, Eq} from &#39;fp-ts/Eq&#39;import {Eq as eqNumber} from &#39;fp-ts/number&#39; // 기본 타입의 Eq 인스턴스도 fp-ts에서 기본 제공한다.type User = { userId: number name: string}// userId를 평가하여 User의 동등성을 비교한다.const eqUser: Eq&amp;lt;User&amp;gt; = contramap((user: User) =&amp;gt; user.userId)(eqNumber)const u1 = { userId: 1, name: &#39;alan&#39; }const u2 = { userId: 1, name: &#39;baegoon&#39; }eqUser.equals(u1, u2) // trueconst u3 = { userId: 1, name: &#39;Bae Sangwoo&#39; }const u4 = { userId: 2, name: &#39;Ryu Songyi&#39; }eqUser.equals(u3, u4) // false특정 프로퍼티를 비교한다고 설명했지만 정확한 의미는 아니다. contramap의 시그니처를 보자.const contramap: &amp;lt;A, B&amp;gt;(f: (b: B) =&amp;gt; A) =&amp;gt; (fa: Eq&amp;lt;A&amp;gt;) =&amp;gt; Eq&amp;lt;B&amp;gt;B에 대한 동등성 평가를 할 때 특별한 평가 규칙이 있다면 규칙으로 사용될 함수 f를 제시하고 그 반환 타입인 A를 평가하는 Eq 인스턴스로 동등성을 평가한다. Github 참고다른 예로 위에서 작성한 Vector 타입의 다른 규칙의 Eq 인스턴스를 만들어보자.// Vector 타입의 from 프로퍼티만 비교한다. -&amp;gt; eqPoint 인스턴스 사용const eqVector2: Eq&amp;lt;Vector&amp;gt; = contramap((v: Vector) =&amp;gt; v.from)(eqPoint)// Vector 타입의 from 프로퍼티의 x, y의 합을 비교한다. -&amp;gt; eqNumber 인스턴스 사용const eqVector3: Eq&amp;lt;Vector&amp;gt; = contramap((v: Vector) =&amp;gt; v.from.x + v.from.y)(eqNumber)contramap에 대해서 지금은 이 정도로만 간단히 사용법을 알아보는 것으로 마무리하자. (더 많은 이해가 필요하다.)이렇게 Eq 타입 클래스를 알아보면서 간단히 fp-ts 라이브러리에 대해 알아보고 함수형 프로그래밍에서 타입을 처리하는 법을 간단히 알아봤다.다음은 대소 비교를 하는 Ord 타입 클래스에 대해 알아보자." }, { "title": "[Live Study] 15주차 과제: 람다식", "url": "/posts/java-livestudy-15week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, lambda", "date": "2021-03-06 16:11:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 람다식에 대해 학습하세요.람다식 사용법람다식은 자바8에서 도입된 기능으로 자바 플랫폼에 큰 변화를 주었습니다. 더 표현력있는 프로그래밍 더 좋은 라이브러리 간결한 코드 향상된 프로그래밍 안전성 잠재적으로 증가된 데이터 병렬처리또한 람다에는 기능의 필수 특성을 정의하는데 도움이 되는 주요 특징이 있습니다. 리터럴로 코드를 작성할 수 있음 타입 추론을 사용하여 자바 코드의 엄격한 네이밍 규칙을 완화함 자바 프로그래밍의 더 기능적인 스타일을 용의하게 하기 위함자바8 이전에는 익명 클래스를 사용하던 것을 람다를 사용하여 더 간결한 코드를 작성할 수 있습니다. 람다가 익명 클래스의 문법 설탕은 아닙니다. 람다는 메소드 핸들과 invokedynamic이라는 특별한 바이트 코드를 사용하여 구현됩니다.Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;run Runnable...&quot;); }};이런 익명클래스를 람다식으로 바꾸면 아래와 같습니다.Runnable runnable = () -&amp;gt; System.out.println(&quot;run Runnable...&quot;);함수형 인터페이스람다식은 특정한 타입에서만 사용이 가능한데 이것을 함수형 인터페이스(Functional Interface) 라고 합니다. 인터페이스(interface)이어야 함 default 메소드가 아닌 메소드가 하나만 있어야 함// 함수형 인터페이스@FunctionalInterfacepublic interface MyListener { void listen(String data);}// 함수형 인터페이스를 파라미터로 받는 메소드public void onAction(MyListener listener) { listener.listen(&quot;data&quot;);}// 함수형 인터페이스 람다로 구현MyListener listener = data -&amp;gt; System.out.println(&quot;listening data : &quot; + data);// 함수 실행onAction(listener);listening data : data만약 MyListener가 재사용되지 않는다면 이렇게 작성도 가능합니다.// 함수형 인터페이스@FunctionalInterfacepublic interface MyListener { void listen(String data);}// 함수형 인터페이스를 파라미터로 받는 메소드public void onAction(MyListener listener) { listener.listen(&quot;data&quot;);}// 메소드 파라미터에 람다로 바로 구현onAction(data -&amp;gt; { System.out.println(&quot;data : &quot; + data); System.out.println(&quot;data length : &quot; + data.length());});data : datadata length : 4Variable Capture람다식에서 내부의 파라미터를 제외한 외부의 변수를 참조하는 것을 Variable Capture 라고 합니다.이 때 참조할 수 있는 변수의 제약 조건이 있습니다. final 변수이어야 함 final 변수가 아니라면 값이 재할당 되지 않아야 함 (Effectively final)public class LambdaApp { public void run() { final String str = &quot;this is local variable&quot;; // final 변수 int num = 10; // final은 아니지만 정의 이후 재할당 되지 않는 변수 onAction(data -&amp;gt; { System.out.println(&quot;str : &quot; + str); System.out.println(&quot;num : &quot; + num); }); } public void onAction(MyListener listener) { listener.listen(&quot;data&quot;); } public static void main(String[] args) { LambdaApp app = new LambdaApp(); app.run(); }}str : this is local variablenum : 10만약 num 변수의 값이 재할당 된다면 컴파일 에러가 발생 합니다.public class LambdaApp { public void run() { final String str = &quot;this is local variable&quot;; // final 변수 int num = 10; // final은 아니지만 정의 이후 재할당 되지 않는 변수 num = 20; // num 재할당 onAction(data -&amp;gt; { System.out.println(&quot;str : &quot; + str); System.out.println(&quot;num : &quot; + num); // 컴파일 에러 발생! }); } ...}만약 재할당된 값을 람다식에서 사용하고 싶다면 해당 값을 다른 변수로 할당하여 처리할 수 있습니다.public class LambdaApp { public void run() { final String str = &quot;this is local variable&quot;; // final 변수 int num = 10; // final은 아니지만 정의 이후 재할당 되지 않는 변수 num += IntStream.range(0, 5).sum(); int finalNum = num; // 새 변수에 할당 onAction(data -&amp;gt; { System.out.println(&quot;str : &quot; + str); System.out.println(&quot;num : &quot; + finalNum); // 새 변수 사용 }); } ...}str : this is local variablenum : 20다만 인스턴스 변수라면 상황이 다릅니다.public class LambdaApp { private int instanceInt = 100; // 인스턴스 변수 선언 public void run() { final String str = &quot;this is local variable&quot;; int num = 10; onAction(data -&amp;gt; { System.out.println(&quot;str : &quot; + str); System.out.println(&quot;num : &quot; + num); System.out.println(&quot;instanceInt : &quot; + instanceInt); // 람다에서 인스턴스 변수 사용 }); } public void onAction(MyListener listener) { listener.listen(&quot;data&quot;); } public static void main(String[] args) { LambdaApp app = new LambdaApp(); app.run(); }}str : this is local variablenum : 10instanceInt : 100이렇게 람다에서 인스턴스 변수인 instanceInt를 사용할 수 있고 중간에 instanceInt 값이 재할당된다고 하더라도 람다에서 사용이 가능합니다.public class LambdaApp { private int instanceInt = 100; public void run() { final String str = &quot;this is local variable&quot;; int num = 10; instanceInt += 200; // 인스턴스 변수 재할당 onAction(data -&amp;gt; { System.out.println(&quot;str : &quot; + str); System.out.println(&quot;num : &quot; + num); System.out.println(&quot;instanceInt : &quot; + instanceInt); // 컴파일 에러가 나지 않고 정상 실행 }); } ...}str : this is local variablenum : 10instanceInt : 300 이게 가능한 이유는 JVM의 메모리 구조와 관련이 있습니다.지역 변수는 스택 영역에 저장이 되며 스택 영역은 스레드마다 별도로 생성이 됩니다.인스턴스 변수는 힙 영역에 생성이 되며 스레드끼리 공유가 가능합니다.람다식에서는 스택에 저장되는 지역 변수를 바로 참조하는 것이 아니라 복사된 값을 사용하게 되는데 멀티 스레드 환경에서 문제가 되기 때문에 재할당된 변수를 람다에서 사용할 수 없게 처리하였습니다.메소드, 생성자 레퍼런스람다에서 조금 더 간결한 문법을 사용할 수 있는 방법으로써 기존 메소드를 람다식으로 사용하는 방법 입니다.람다식의 파라미터의 타입을 추론하여 해당 타입의 메소드를 사용하는 것입니다.// 함수형 인터페이스@FunctionalInterfacepublic interface ButtonClickListener { void onClick(String data);}public class Button { // 함수형 인터페이스를 받는 메소드 public void click(ButtonClickListener listener) { listener.onClick(data); }}Button button = new Button();이러한 함수형 인터페이스와 그 것을 받는 메소드가 있다면 다음과 같이 람다식으로 사용할 수 있을 겁니다.Button button = new Button();button.click(data -&amp;gt; data.length()); // data의 메소드 사용button.click(data -&amp;gt; System.out.println(data)); // data를 파라미터로 사용button.click(data -&amp;gt; Integer.parseInt(data)); // 스태틱 메소드에서 data를 파라미터로 사용이 것들을 모두 메소드 레퍼런스로 변경하면 다음과 같습니다.Button button = new Button();// Unbound Method Referencebutton.click(String::length); // Bound Method Referencebutton.click(System.out::println);// Static Bound Method Referencebutton.click(Integer::parseInt); 생성자 레퍼런스를 사용할 수도 있습니다.// 기존 람다식button.click(data -&amp;gt; new StringBuilder(data));// 생성자 레퍼런스button.click(StringBuilder::new);" }, { "title": "[Live Study] 14주차 과제: 제네릭", "url": "/posts/java-livestudy-14week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, generic", "date": "2021-03-01 13:43:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 제네릭에 대해 학습하세요.제네릭 사용법제네릭(Generic)은 자바에서 유용한 기능 중 하나로 특히 공통 데이터 구조를 만들 때 주로 사용 됩니다.List&amp;lt;String&amp;gt; hobbies = new ArrayList&amp;lt;String&amp;gt;();hobbies.add(&quot;baseball&quot;);hobbies.add(1);String hobby1 = (String) hobbies.get(0);String hobby2 = (String) hobbies.get(1); // ClassCastException 발생hobbies 리스트의 문제는 아래와 같습니다. 아무 타입의 데이터를 add 할 수 있음. 어떤 데이터 타입을 포함 하는지 알 수 없음. 데이터를 사용하려면 타입 캐스팅이 필요함. 잘못된 데이터를 넣을 때 컴파일 타임에서 예측하기 어렵고 잘못된 타입 캐스팅으로 런타임 예외인 ClassCastException이 발생할 수 있음.hobbies 리스트에서 처리할 수 있는 데이터를 제한함으로써 위와 같은 문제를 해결할 수 있습니다.List&amp;lt;String&amp;gt; hobbies = new ArrayList&amp;lt;&amp;gt;();hobbies.add(&quot;baseball&quot;);hobbies.add(1); // 컴파일 에러 발생제네릭의 주요 개념제네릭 타입, 타입 파라미터List를 사용할 때 타입을 제한해서 처리가 가능한 이유는 이미 List 인터페이스에 제네릭 타입으로 타입 파라미터를 받고 있기 때문입니다.// 자바에서 제공되는 List 인터페이스public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; { // ...} E : 제네릭 타입 &amp;lt;E&amp;gt; : 타입 파라미터다이아몬드 연산자제네릭 타입의 인스턴스를 생성할 때 타입 파라미터를 생략할 수 있습니다.컴파일러가 타입 파라미터를 추론할 수 있기 때문인데 이를 다이아몬드 연산자, 다이아몬드 구문이라고 합니다.List&amp;lt;String&amp;gt; hobbies1 = new ArrayList&amp;lt;String&amp;gt;();List&amp;lt;String&amp;gt; hobbies2 = new ArrayList&amp;lt;&amp;gt;(); // String 생략바운디드 타입(Bounded Type)public class Wrapper&amp;lt;T&amp;gt; { private final T value; public Wrapper(T value) { this.value = value; }}Wrapper&amp;lt;String&amp;gt; wrapper1 = new Wrapper&amp;lt;&amp;gt;();Wrapper&amp;lt;Integer&amp;gt; wrapper2 = new Wrapper&amp;lt;&amp;gt;();이 Wrapper 클래스에서 타입 파라미터의 타입을 제한을 하고싶을 때 바운디드 타입을 사용할 수 있는데 extends 키워드를 사용하여 적용할 수 있습니다.public class Wrapper&amp;lt;T extends Number&amp;gt; { private T value; public byte getByteValue() { return value.byteValue(); }}Wrapper&amp;lt;String&amp;gt; wrapper1 = new Wrapper&amp;lt;&amp;gt;(); // 컴파일 에러 발생Wrapper&amp;lt;Integer&amp;gt; wrapper2 = new Wrapper&amp;lt;&amp;gt;();이렇게 &amp;lt;T extends Number&amp;gt;를 사용하여 Number와 호환되는 타입만 받도록 제한할 수 있습니다.또한 타입이 제한되어 있어서 value.byteValue() 처럼 해당 타입의 메소드를 사용할 수도 있습니다.Wildcard만약 타입 파라미터에 구체적인 값을 제공하지 않고 모든 타입을 의미하는 값을 넣고 싶을 때 와일드카드를 사용할 수 있고 와일드카드는 물음표(?)로 나타냅니다.List&amp;lt;?&amp;gt; list = Arrays.asList(&quot;alan&quot;, 1, 100L, new User(&quot;bsw&quot;, &quot;bsw@ss.com&quot;));List&amp;lt;?&amp;gt; hobbies = new ArrayList&amp;lt;String&amp;gt;(); 리스트의 데이터 타입에 대해 모르지만 코드에 문제는 없습니다.Bounded Wildcard와일드카드를 사용하는 예제에서 왜 Object를 사용하지 않고 와일드카드를 사용할까요?바운디드 와일드카드를 사용하여 알려지지 않은 타입 파라미터의 상속 계층을 표현하는 데 사용합니다.Upper Bounded Wildcard (Type covariance)공변적이라고도 표현하며 extends 키워드를 사용하여 특정 클래스의 동일 클래스나 자식 클래스만 사용할 수 있음을 나타냅니다.List&amp;lt;? extends String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();String s = list.get(0);list.add(&quot;&quot;); // 컴파일 에러Loer Bounded Wildcard (Type contravariance)반공변적이라고 표현하며 super 키워드를 사용하고 특정 클래스의 부모 클래스만 가진다는 의미를 나타냅니다.List&amp;lt;? super String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();String s = list.get(0); // 컴파일 에러list.add(&quot;&quot;);제네릭 메소드 만들기제네릭 메소드는 어떤 레퍼런스 타입의 인스턴스를 사용할 수 있는 메소드 입니다.클래스나 인터페이스에 제네릭 타입 파라미터가 없더라도 사용할 수 있습니다.// 제네릭 메소드public &amp;lt;T&amp;gt; String getClassName(T a) { return a.getClass().getSimpleName();}List&amp;lt;?&amp;gt; list = List.of(&quot;This is String&quot;, 1, 2.0, (byte) 3, 4f, 5L, new Child());list.forEach(el -&amp;gt; { String className = getClassName(el); System.out.println(className);});StringIntegerDoubleByteFloatLongChild제네릭 메소드에도 동일하게 바운디드 타입을 사용할 수 있습니다.public &amp;lt;T extends Number&amp;gt; String getClassName(T a) { return a.getClass().getSimpleName();}getClassName(1);getClassName(2.0);getClassName((byte) 3);getClassName(4f);getClassName(5L);getClassName(&quot;This is String&quot;); // 컴파일 에러getClassName(new Child()); // 컴파일 에러또한 클래스에 정의된 제네릭 타입 파라미터를 메소드에서 파라미터로 사용할 수 있습니다.public class Parent&amp;lt;T&amp;gt; { public String getClassName(T p) { return p.getClass().getSimpleName(); }}Parent&amp;lt;String&amp;gt; p1 = new Parent&amp;lt;&amp;gt;();p1.getClassName(&quot;only string&quot;); // String만 입력 가능p1.getClassName(1); // 컴파일 에러Parent&amp;lt;Integer&amp;gt; p2 = new Parent&amp;lt;&amp;gt;();p2.getClassName(1); // Integer만 입력 가능p2.getClassName(&quot;string no&quot;); // 컴파일 에러Erasure제네릭은 자바5에서 추가된 기능 입니다.그럼 이전 버전의 제네릭이 없는 컬렉션과 제네릭이 추가된 버전의 컬렉션이 함께 사용될 때 호환성 문제가 발생할 수 있습니다.그래서 자바는 타입 소거(Type Erasure)를 통해 호환성을 해결 하였습니다.제네릭 타입 파라미터는 컴파일이 되면 없어지고 바이트코드에 반영되지 않습니다.public interface TypeErasure { int getSize(List&amp;lt;String&amp;gt; list); int getSize(List&amp;lt;Integer&amp;gt; list);}이런 인터페이스가 있을 때 두 개의 getSize 메소드를 오버로딩했다고 생각할 수 있습니다.그러나 getSize 메소드는 오버로딩 되지 않고 컴파일 에러가 발생합니다.이유는 타입 소거 때문입니다.제네릭 타입은 컴파일 후 바이트 코드를 보면 제네릭 타입이 생략되어 있는 것을 볼 수 있습니다.public interface TypeErasure { int getSize(List&amp;lt;String&amp;gt; list);}// class version 58.0 (58)// access flags 0x601public abstract interface dev/baesangwoo/livestudy/week14/TypeErasure { // compiled from: TypeErasure.java // access flags 0x401 // signature (Ljava/util/List&amp;lt;Ljava/lang/Integer;&amp;gt;;)I // declaration: int getSize(java.util.List&amp;lt;java.lang.Integer&amp;gt;) public abstract getSize(Ljava/util/List;)I}그리고 제네릭 타입으로는 Primitive Type이 아니라 Reference Type만 사용할 수 있는데 그 이유 또한 타입 소거 때문 입니다.컴파일 후에 타입 소거가 발생하기 때문에 내부적으로 타입 파라미터를 Object 타입으로 처리하게 되는데 Primitive Type은 Object 클래스를 상속받지 않기 때문에 Reference Type을 사용해야 합니다." }, { "title": "[Live Study] 13주차 과제: I/O", "url": "/posts/java-livestudy-13week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, io", "date": "2021-02-27 20:17:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 Input과 Output에 대해 학습하세요.스트림(Stream), 버퍼(Buffer), 채널(Channel) 기반의 I/O스트림(Stream)I/O 스트림(Stream)은 디스크 또는 기타 소스의 순차적 바이트 스트림을 처리하는 방법으로 자바1.0부터 존재 했습니다.스트림은 단방향 통신만 가능하고 그 때문에 입출력을 모두 처리하려면 입력 스트림과 출력 스트림 모두 필요합니다.System.in, System.out은 자주 사용되는 표준 입출력 스트림입니다.System.out.println(&quot;this is stream!&quot;); 대표적인 출력 스트림 입니다.자바8에 추가된 컬렉션 API의 Stream과 다릅니다.NIO (New I/O)자바1.4에 추가된 API로 java.nio 패키지에 포함되어 있으며 자바7부터는 NIO.2 API가 추가 되었습니다.NIO는 넌블로킹(Non-Blocking) 처리가 되며 스트림(Stream)이 아닌 채널(Channel)을 사용 합니다.버퍼(Buffer)Buffer는 특정한 원시자료형(Primitive Type)을 저장하는 컨테이너이며 필수 속성은 capacity, limit, position 입니다.채널을 통해서 소켓, 파일 등에 데이터를 전송하거나 읽어올 때 버퍼를 사용하여 가비지량을 최소화 시킬 수 있으며 GC 회수를 줄여 서버 전체의 처리량(throughput)을 즐가시켜 줍니다.ByteBuffer, CharBuffer, ShortBuffer, IntBuffer, LongBuffer 등이 있습니다.채널(Channel)채널은 데이터가 통과하는 통로이며 이 때 사용되는 것이 버퍼 입니다.SocketChannel, FileChannel 등이 있습니다.InputStream, OutputStreamInputStream과 OutputStream은 스트림의 핵심적인 API 입니다.이 둘은 모두 데이터를 바이트(byte) 단위로 입출력을 하는 스트림 입니다.다양한 구현체가 있지만 ByteArrayInputStream, ByteArraayOutputStream으로 예제를 작성 했습니다.InputStreamInputStream은 입력 스트림으로 데이터를 읽는 역할을 하며 핵심 메소드인 read() 메소드를 사용하여 순차적으로 데이터를 읽을 수 있습니다.// 핵심 메소드public abstract int read() throws IOException;public int read(byte b[]) throws IOException;public int read(byte b[], int off, int len) throws IOException; 리턴 타입이 int인 이유는 0~255까지는 데이터이고 스트림의 끝을 나타내는 데이터는 -1 입니다.OutputStreamOutputStream은 출력 스트림으로 데이터를 쓰기위해 사용할 수 있습니다.// 핵심 메소드public abstract void write(int b) throws IOException;public void write(byte b[]) throws IOException;public void write(byte b[], int off, int len) throws IOException;Byte, Character 스트림Byte 스트림1바이트 단위로 데이터를 처리하는 스트림으로 위 예제가 바이트 스트림의 예제 입니다.http://javadevwannabe.blogspot.com/2012/02/high-level-streams.htmlCharacter 스트림바이트가 아닌 문자(Character) 단위로 처리하는 스트림으로 개발자에게 더 친숙하고 인코딩이나 유니코드 등의 문제를 숨긴 API를 제공 합니다.Reader, Writer 클래스를 사용하고 다양한 하위 클래스가 존재 합니다.http://javadevwannabe.blogspot.com/2012/02/reader-and-writer-classes.html표준 스트림 (System.in, System,out, System.err)표준스트림은 java.lang.System 클래스에 정의되어 있습니다. System.out: 콘솔에 출력하기 위함 System.in: 키보드로 입력을 받기 위함 System.err: 에러 출력을 위함파일 읽고 쓰기InputStream, OutputStream 사용try (InputStream is = new FileInputStream(&quot;input.png&quot;); OutputStream os = new FileOutputStream(&quot;output.png&quot;)) { int line; while ((line = is.read()) &amp;gt; -1) { os.write(line); }} catch (IOException e) { e.printStackTrace();}Reader, Writer 사용try (BufferedReader in = new BufferedReader(new FileReader(&quot;input.txt&quot;)); BufferedWriter out = new BufferedWriter(new FileWriter(&quot;output.txt&quot;))) { String line; while ((line = in.readLine()) != null) { out.write(line); }} catch (IOException e) { e.printStackTrace();}" }, { "title": "[Live Study] 12주차 과제: 애노테이션", "url": "/posts/java-livestudy-12week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, annotation", "date": "2021-02-05 19:03:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 애노테이션에 대해 학습하세요.애노테이션이란?애노테이션(annotation)은 자바의 특수한 인터페이스 이며 기본적으로 이름처럼 주석을 다는 역할을 합니다.다만 일반적인 주석과는 다르게 추가적인 작업을 덧붙일 수 있으며 IDE에 유용한 힌트를 줄 수도 있습니다.예를 들어 메소드에 @Override 애노테이션이 붙으면 오버라이딩 메소드라고 알려주는 주석의 역할을 하면서 만약 오버라이딩 메소드가 아니라면 IDE 단에서 알려주는 힌트의 역할을 합니다.그 외 특징은 아래와 같습니다. 모든 애노테이션은 암묵적으로 java.lang.annotation.Annotation 인터페이스를 상속합니다. 다른 인터페이스를 상속할 수 없습니다. 예외를 던지는 메소드를 정의할 수 없습니다. 메소드의 리턴 타입에 대한 제약 조건이 있습니다. 메소드에 기본 리턴값을 가질 수 있습니다.애노테이션 정의애노테이션은 @interface 키워드를 사용하여 정의할 수 있습니다.@Retention(RetentionPolicy.SOURCE)@Target(ElementType.METHOD)public @interface Logger { String value() default &quot;&quot;;}위와 같은 애노테이션이 적용 되었다면 코드에 적용할 수 있습니다.public class MyService { @Logger public void process() { // business... }}메타 애노테이션메타 애노테이션은 개발자가 새로운 애노테이션을 만들 때 사용할 위치나 자바 컴파일러나 런타임에서 어떻게 처리될지 정책을 명시하는 애노테이션을 말합니다.위 @Logger 예제에서 @Retention과 @Target이 이에 해당하며 가장 기본적인 메타 애노테이션 입니다.@Retention위 예제를 컴파일하여 MyService.class 파일을 열어보면 애노테이션이 빠져있는 것을 볼 수 있습니다.이 이유는 @Logger 애노테이션에 붙어있는 @Retention 애노테이션 때문 입니다.@Retention 애노테이션은 자바 컴파일러와 자바 런타임이 커스텀 애노테이션을 어떻게 처리해야하는지 알려주는 역할을 합니다.3가지 열거 상수가 정해져 있는 java.lang.annotation.RetentionPolicy Enum으로 이를 표현 합니다. SOURCE : 소스 상에서만 애노테이션이 보이고 컴파일 되면 사라집니다. CLASS : 애노테이션이 클래스 파일에 존재하지만 JVM을 통한 자바 런타임이 접근할 수 없습니다. 잘 사용되지는 않지만 바이트 코드를 분석할 때 사용될 수 있습니다. RUNTIME : 자바 런타임이 애노테이션을 접근할 수 있고 그를 통해 무언가 추가적인 작업이 가능함을 의미 합니다.이와 같은 이유로 @Logger 애노테이션은 컴파일된 클래스 파일에서는 볼 수 없었던 것이고 만약 RUNTIME으로 변경한다면 클래스 파일에서도 애노테이션을 볼 수 있습니다.@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Logger { String value() default &quot;&quot;;}컴파일 되었기 때문에 당연히 FQCN으로 보입니다.@Target예제에서 @Logger 애노테이션을 클래스에 붙인다면 컴파일 에러가 발생합니다.이유는 애노테이션에 정의되어 있는 @Target 애노테이션 설정 때문입니다.이 애노테이션은 java.lang.annotation.ElementType Enum을 사용하여 표현합니다. TYPE : 클래스, 인터페이스, 어노테이션, Enum, 레코드(jdk14 이상) FIELD : 필드, Enum 상수 METHOD : 메소드 PARAMETER : 파라미터 CONSTRUCTOR : 생성자 LOCAL_VARIABLE : 지역 변수 ANNOTATION_TYPE : 애노테이션 PACKAGE : 패키지 이외 TYPE_PARAMETER, TYPE_USE, MODULE@Target은 값을 배열로 받기 때문에 애노테이션을 여러 타겟에 달도록 지정할 수 있습니다.클래스에 @Logger 애노테이션을 추가할 수 있도록 TYPE을 추가 하였습니다.@Target({ElementType.METHOD, ElementType.TYPE}) // 메소드와 타입에 애노테이션 설정 가능@Retention(RetentionPolicy.RUNTIME)public @interface Logger { String value() default &quot;&quot;;}@Logger // 컴파일 이상 없음.public class MyService { @Logger public void process() { // business... }}@Documented애노테이션에 @Documented가 붙어있다면 Javadoc에 해당 애노테이션 정보를 표시합니다.@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Logger { String value() default &quot;&quot;;}@Loggerpublic class MyService { ...}이후에 MyService 클래스의 javadoc을 보면 애노테이션 정보가 있는 것을 볼 수 있습니다. Gradle Wrapper 기준 ./gradlew javadoc을 프로젝트 루트에서 실행시키면 javadoc이 생성됩니다.@Documented 애노테이션 붙이기 전@Documented 애노테이션 붙인 후@Inherited@Inherited를 적용한 애노테이션을 클래스에 적용하면그 클래스를 상속한 자식 클래스도 해당 애노테이션을 가지게 됩니다.애노테이션 프로세서애노테이션은 기본적으로 주석의 역할만 하지만 애노테이션 프로세서가 있다면 애노테이션을 통해 어떤 작업을 할 수 있게 됩니다.하나의 예로 롬복의 애노테이션들은 가장 많이 사용하는 애노테이션 프로세서가 적용된 애노테이션 모음 입니다.애노테이션 프로세서 만들기javax.annotation.processing.Processor 인터페이스를 구현하여 만들 수 있지만 자바가 제공하는 기본적인 추상 클래스인 AbstractProcessor를 사용할 수 있습니다. 애노테이션은 위에서 예제로 사용한 @Logger 애노테이션을 사용하겠습니다.public class LoggerProcessor extends AbstractProcessor { /** * 이 프로세서로 처리할 애노테이션 */ @Override public Set&amp;lt;String&amp;gt; getSupportedOptions() { return Set.of(Logger.class.getName()); } /** * 어떤 소스코드 버전을 지원할 것인지 명시 (필요하지 않다면 재정의하지 않아도 됨) */ @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } /** * 애노테이션을 처리하기 */ @Override public boolean process(Set&amp;lt;? extends TypeElement&amp;gt; annotations, RoundEnvironment roundEnv) { Set&amp;lt;? extends Element&amp;gt; elements = roundEnv.getElementsAnnotatedWith(Logger.class); elements.forEach(el -&amp;gt; { if (el.getKind() != ElementKind.METHOD) { processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, &quot;Cannot use this annotation!&quot;); // 애노테이션이 메소드에 붙어있지 않다면 에러 발생! } else { processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, &quot;Processing...&quot;); } }); return true; // 애노테이션이 이 프로세서에 특화되어있다면 true, 다른 프로레서에서도 처리가 가능하다면 false }}애노테이션 프로세서 등록하기이제 src/main/resources/META-INF/services 디렉토리에 javax.annotation.processing.Processor 라는 파일을 생성하고 이 애노테이션 프로세서의 FQCN을 입력한 후 컴파일 합니다.그러나 컴파일 한다면 에러가 발생합니다. 아직 프로세서가 컴파일되지 않은 시점에 javax.annotation.processing.Processor 파일의 설정을 읽으려고하기 때문에 문제가 됩니다.해결책은 아래와 같습니다. javax.annotation.processing.Processor 파일의 프로세서를 주석을 건다. 컴파일 한다. javax.annotation.processing.Processor 파일에서 프로세서 주석을 제거한다. 다시 컴파일 한다. (이 때 clean 명령은 사용하지 않는다.)구글에서 만든 AutoService를 사용한다면 이 과정이 간단해 집니다.더 자세히 보려면…인프런에서 백기선님 강의인 더 자바, 코드를 조작하는 다양한 방법 강의에서 더 자세하게 알아볼 수 있습니다." }, { "title": "[Live Study] 11주차 과제: Enum", "url": "/posts/java-livestudy-11week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, enum", "date": "2021-01-29 21:12:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 열거형에 대해 학습하세요.Enum 이란?Enum은 제한된 기능을 까지고 허용하는 값이 적은 클래스의 변형된 유형입니다.흔히 열거형 클래스라고도 하며 어떤 데이터 집합에서 유일한 값을 표현할 때 사용할 수 있습니다.예를 들어 색상을 표현하는 집합에서 어떤 색상인지 나타내면서 그 값이 집합에서 유일하게 표현된다면 사용할 수 있습니다.Enum은 아래와 같이 몇가지 특성이 있습니다. 모든 Enum은 암묵적으로 java.lang.Enum을 상속 합니다. 인터페이스를 구현할 수 있습니다. (상속은 불가능) Enum을 상속할 수 없습니다. new 키워드를 통해 인스턴스화 될 수 없습니다.Enum 정의 하기enum 키워드를 사용하여 Enum을 정의할 수 있습니다.public enum Color { RED, GREEN, BLUE}이렇게 Enum 클래스를 정의하고 각 RED, GREEN, BLUE는 정적(static) 필드인 것처럼 참조할 수 있으며 열거 상수(enum constant)라고 합니다.Color r = Color.RED;Color g = Color.GREEN;Color b = Color.BLUE;열거형 클래스인 Enum을 정의하면 암묵적으로 java.lang.Enum을 상속하므로 이 부모 클래스의 메소드들을 사용이 가능하게 됩니다.java.lang.Enum 클래스의 name, ordinal 필드가 있습니다.name 필드에는 정의한 열거 상수명이 String으로 들어가 있고ordinal에는 열거 상수의 정의 순서가 int로 있습니다.이 필드들은 private 하기 때문에 직접 접근을 하지 못하지만 메소드를 제공합니다.Color r = Color.RED;Color g = Color.GREEN;Color b = Color.BLUE;System.out.println(r.name()); // REDSystem.out.println(g.name()); // GREENSystem.out.println(b.name()); // BLUESystem.out.println(r.ordinal()); // 0System.out.println(g.ordinal()); // 1System.out.println(b.ordinal()); // 2ordinal 필드는 EnumSet, EnumMap과 같은 enum 기반 데이터 구조에서 사용하기 위해 설계 되어 있습니다.Enum의 필드와 메소드Enum은 키워드가 다르긴 하지만 클래스이기 때문에 생성자, 필드, 메소드를 가질 수 있습니다.만약 필드와 메소드가 존재한다면 Enum 상수 목록 마지막에 세미콜론(;)을 입력한 후 아래에 정의할 수 있습니다.public enum Color { // 생성자 파라미터 대로 적용 RED(&quot;빨강&quot;), GREEN(&quot;초록&quot;), BLUE(&quot;파랑&quot;); // 필드 private String desc; // 메소드 public String getDesc() { return desc; } // 생성자 Color(String desc) { this.desc = desc; }}Color r = Color.RED;Color g = Color.GREEN;Color b = Color.BLUE;// 메소드에 접근System.out.println(r.getDesc()); // 빨강System.out.println(g.getDesc()); // 초록System.out.println(b.getDesc()); // 블루 RED와 같이 열거 상수를 정의하는 것이 Color 인스턴스 생성과 비슷하다고 생각할 수 있습니다. 그렇기 떄문에 생성자 포맷대로 정의 합니다.열거 상수는 자바 런타임에 의해 생성되고 생성자는 자동으로 private으로 선언되기 때문에 외부에서 인스턴스화는 불가능 합니다.생성자를 private으로 선언한 적은 없지만…Enum 비교동일성 비교Enum 상수 간의 동일성 비교는 ==을 사용하여 비교가 가능합니다.Color r = Color.RED;Color r2 = Color.RED;Color g = Color.GREEN;Color b = Color.BLUE;r == r2; // truer == g; // falsecompareTo()compareTo() 메소드를 사용한다면 동일성 부터 대소 비교까지 가능합니다.이 메소드 또한 java.lang.Enum 클래스에서 Comparable 인터페이스를 구현하여 정의되어 있습니다.Color r = Color.RED;Color r2 = Color.RED;Color g = Color.GREEN;Color b = Color.BLUE;System.out.println(g.compareTo(r)); // -1System.out.println(g.compareTo(g1)); // 0System.out.println(g.compareTo(b)); // 1values(), valueOf()Enum 클래스를 정의하면 static한 메소드인 values()와 valueOf() 메소드를 제공 합니다.values()values() 메소드는 해당 Enum 클래스의 모든 열거 상수 목록을 리턴합니다.Color[] values = Color.values();for (Color value : values) { System.out.println(value);}REDGREENBLUEvalueOf()valueOf() 메소드는 Enum의 기본 필드인 name 필드를 기반으로 동일한 열거 상수를 반환하고 존재하지 않을 때엔 IllegalArgumentException 예외를 던집니다.Color.valueOf(&quot;RED&quot;); // REDColor.valueOf(&quot;BLACK&quot;); // IllegalArgumentException 예외 발생!EnumSet, EnumMapEnumSetEnumSet은 Enum과 함께 사용할 수 있는 특별한 Set 구현체 입니다.EnumSet 계층구조HashSet의 경우 데이터를 내부적으로 표현할 때 해시 테이블(Hash Table)을 사용하지만EnumSet의 경우에는 비트 벡터(Bit Vector)로 표현합니다.또한 이 클래스의 모든 기본적인 작업은 상수 시간이 걸리기 때문에 HashSet과 비교하여 더 빠를 수 있습니다.벌크 연산일 경우에도 마찬가지로 인수가 열거 집합일 경우에는 상수 시간이 걸립니다.EnumSet은 추상 클래스이므로 직접 new를 사용한 인스턴스화가 불가능하지만 다양한 static 메소드를 제공하므로 그를 통해 사용할 수 있습니다.// Color의 모든 열거 상수를 EnumSet으로 가져오기EnumSet&amp;lt;Color&amp;gt; colors = EnumSet.allOf(Color.class);// Color의 열거 상수 중 선택적으로 EnumSet으로 가져오기EnumSet&amp;lt;Color&amp;gt; red = EnumSet.of(Color.RED, Color.BLUE);// Color의 열거 상수를 범위로 지정하여 해당 범위 모든 열거 상수 가져오기EnumSet&amp;lt;Color&amp;gt; range = EnumSet.range(Color.RED, Color.BLUE);EnumMapEnumMap은 맵의 키의 타입을 열거형으로 가지는 특수한 Map 입니다.EnumMap 계층구조이 맵은 내부적으로 배열로 표현되며 특정 Enum만을 키로 가지기 때문에 작고 효율적입니다.이 맵은 순서가 보장되는데 이 순서는 put 메소드를 사용하여 입력한 순서가 아닌 Enum 내부의 열거 상수의 순서인 ordinal의 순서에 따릅니다.EnumMap&amp;lt;Color, String&amp;gt; colorStringEnumMap = new EnumMap&amp;lt;&amp;gt;(Color.class);colorStringEnumMap.put(Color.RED, &quot;빨간색&quot;);colorStringEnumMap.put(Color.BLUE, &quot;파란색&quot;);colorStringEnumMap.put(Color.GREEN, &quot;초록색&quot;);colorStringEnumMap.forEach((k, v) -&amp;gt; { System.out.println(&quot;key: &quot; + k + &quot;, value: &quot; + v);});key: RED, value: 빨간색key: GREEN, value: 초록색key: BLUE, value: 파란색 맵에 데이터를 입력할 떄는 RED, BLUE, GREEN 순으로 입력하였지만 순차적으로 출력을 해보면 RED, GREEN, BLUE 순으로 출력되는 것을 확인할 수 있습니다." }, { "title": "[Live Study] 10주차 과제: 멀티스레드 프로그래밍", "url": "/posts/java-livestudy-10week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, thread", "date": "2021-01-24 10:05:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 멀티스레드 프로그래밍에 대해 학습하세요.프로세스와 스레드https://www.javaquery.com/2016/07/what-is-difference-between-process-and.html프로세스프로세스는 자체적으로 실행 환경을 가지고 있으며 프로그램의 인스턴스를 프로세스라고 말합니다. 각 프로세스에는 자체 주소 공간이 있습니다. 각 프로세스는 다른 프로세스와 통신하기 위해 파이프 및 소켓과 같은 IPC(Inter Process Communication) 리소스를 사용해야 합니다. 새 프로세스에는 상위 프로세스의 복제가 피요합니다. 프로세스에는 상당한 오버 헤드가 있습니다. 프로세스에는 상위 프로세스의 데이터 세그먼트에 대한 자체 사본이 있습니다. 프로세스는 하위 프로세스를 제어 합니다. 상위 프로세스의 변경 사항은 하위 프로세스에 영향을 주지 않습니다. 프로세스는 운영 체제에 의해 제어됩니다. 프로세스는 독립적 입니다.스레드스레드는 프로세스 내에서 실행되는 작업의 단위로 경량 프로세스라고 불리기도 합니다. 스레드는 자신을 생성한 프로세스의 주소 공간을 공유 합니다. 스레드는 프로세스의 다른 스레드와 직접 통신할 수 있습니다. 새 스레드를 쉽게 만들 수 있습니다. 스레드에는 오버 헤드가 거의 없습니다. 스레드는 프로세스의 데이터 세그먼트에 직접 엑세스할 수 있습니다. 스레드는 동일한 프로세스의 스레드를 상당히 제어 합니다. 주 스레드의 변경 (취소, 우선순위 변경 등)은 프로세스의 다른 스레드 동작에 영향을 미칠 수 있습니다. 스레드는 프로그램의 프로그래머가 제어합니다. 스레드는 종속적입니다.Thread 클래스와 Runnable 인터페이스Thread 클래스와 Runnable 인터페이스 모두 새로운 쓰레드를 생성하는데 사용할 수 있습니다.Thread 클래스는 Runnable 인터페이스의 구현체입니다.// Thread 상속public class MyThread extends Thread { @SneakyThrows @Override public void run() { Thread.sleep(1000); System.out.println(&quot;MyThread run&quot;); }}// Runnable 구현public class MyRunnable implements Runnable { @SneakyThrows @Override public void run() { Thread.sleep(1000); System.out.println(&quot;MyRunnable run&quot;); }}// 실행public class MultiThreadApp { public static void main(String[] args) { MyThread thread = new MyThread(); MyRunnable runnable = new MyRunnable(); Thread thread2 = new Thread(runnable); thread.start(); thread2.start(); }}위 예제처럼 Thread를 사용하는게 더 간단하지만 다른 클래스를 상속할 수 없기 때문에 Runnable를 구현해서 사용할 수도 있습니다.스레드의 상태 (라이프사이클)[O’REILLY] Java in a Nutshell, 7th Edition모든 운영체제는 스레드에 대한 뷰가 있습니다. 세부 사항이 다를 수는 있지만 대부분의 경우 높은 수준에서 대체로 유사 합니다.자바는 이러한 세부 정보를 추상화 하기 위해 스레드 상태를 나타내는 Thread.State라는 Enum을 제공합니다. NEW: 스레드가 생성되었지만 start() 메소드가 호출되지 않은 상태로 모든 스레드는 이 상태에서 시작. RUNNABLE: 쓰레드가 실행중이거나 운영체제가 예약하여 실행이 가능할 때. BLOCKED: 동기화된(synchronized) 메소드 또는 블록에 들어갈 수 있도록 락을 얻으려고(aquire) 대기 중이기 때문에 스레드가 샐행중이 아닌 상태. WAITING: Object.wait(), Thread.join() 메소드가 호출되어 스레드가 실행되고 있지 않는 상태. TIMED_WAITING: Thread.sleep()를 호출했거나 타임아웃을 사용하여 Object.wait(), Thread.join()을 호출했을 때 스레드가 실행되고 있지 않는 상태. TERMINATED: run() 메소드가 정상적으로 종료되었거나 예외가 발생하여 스레드가 실행이 완료된 상태. 스레드의 우선순위Thread 클래스의 getPriority(), setPriority() 메소드를 사용하여 스레드의 우선순위를 컨트롤할 수 있습니다.스케쥴러는 스레드 우선순위를 처리하는 방법을 결정합니다.우선 순위가 높은 스레드가 대기중인 동안 낮은 우선 순위 스레드가 실행되지 않도록하는 전략이 있습니다.대부분의 경우 스케쥴러가 우선 순위를 해석하는 방법에 영향을 줄 수 없습니다.스레드 우선 순위는 1 ~ 10 사이의 정수로 표시되며 10이 가장 높습니다.public class FirstThread extends Thread { @Override public void run() { System.out.println(&quot;FirstThread Priority : &quot; + getPriority()); }}public class SecondThread extends Thread { @Override public void run() { System.out.println(&quot;SecondThread Priority : &quot; + getPriority()); }}public class MultiThreadApp { public static void main(String[] args) { FirstThread firstThread = new FirstThread(); SecondThread secondThread = new SecondThread(); firstThread.setPriority(1); secondThread.setPriority(10); firstThread.start(); secondThread.start(); }}SecondThread Priority : 10FirstThread Priority : 1 실제 출력 순서는 다를 수 있습니다.메인 스레드https://www.geeksforgeeks.org/main-thread-java/자바 프로그램이 시작되면 하나의 스레드가 즉시 실행되며 이렇게 프로그램이 시작될 때 실행되는 스레드를 일반적으로 메인 스레드라고 합니다.public class MultiThreadApp { public static void main(String[] args) { // ... }} 사용하던 예제의 메인스레드스레드 그룹 (Thread Group)ThreadGroup 클래스를 사용하여 스레드 그룹을 만들 수 있으며 여러 스레드를 그룹 단위로 관리하는 방법을 제공합니다.특히 여러 스레드를 일시 중단하거나 재개할 때 유용합니다.public class FirstThread extends Thread { // 스레드 그룹을 위한 생성자 추가 public FirstThread(@Nullable ThreadGroup group, @NotNull String threadName) { super(group, threadName); } @Override public void run() { System.out.println(&quot;FirstThread Priority : &quot; + getPriority()); }}public class SecondThread extends Thread { // 스레드 그룹을 위한 생성자 추가 public SecondThread(@Nullable ThreadGroup group, @NotNull String threadName) { super(group, threadName); } @Override public void run() { System.out.println(&quot;SecondThread Priority : &quot; + getPriority()); }}public class MultiThreadApp { public static void main(String[] args) { ThreadGroup threadGroup = new ThreadGroup(&quot;thread-group&quot;); // 스레드 그룹 생성 FirstThread firstThread = new FirstThread(threadGroup, &quot;first-thread&quot;); SecondThread secondThread = new SecondThread(threadGroup, &quot;second-thread&quot;); firstThread.start(); secondThread.start(); System.out.println(&quot;threadGroup.activeCount() : &quot; + threadGroup.activeCount()); }}FirstThread Priority : 5SecondThread Priority : 5threadGroup.activeCount() : 2데몬 스레드 (Daemon Thread)데몬 스레드는 메인 스레드를 보조하는 스레드를 말하며 가비지 수집과 같은 작업을 수행하기 위해 백그라운드에서 실행되는 우선 순위가 낮은 스레드 입니다.JVM은 데몬 스레드가 실행 중인지 여부를 신경쓰지 않습니다.동기화 (synchronized)멀티 스레드 프로그램은 여러 스레드가 동일한 리소스에 접근하려고 할 때 예기치 않는 결과를 생성하게 될 수도 있습니다.따라서 필요에 따라 특정 시점에 하나의 스레드만 리소스에 접근할 수 있도록 처리해야 합니다.자바는 동기화된 블록을 사용하여 스레드를 생성하고 작업을 동기화하는 방법을 제공하는데 이때 synchronized 키워드를 사용할 수 있습니다./** * 출금만 가능한 계좌 */public class Account { private int balance; public Account(int money) { this.balance = money; } private boolean hasBalance() { return balance &amp;gt; 0; } public void withdraw(int money) { if (!hasBalance()) { System.out.println(&quot;Insufficient balance&quot;); return; } balance -= money; System.out.println(&quot;balance is : &quot; + balance); }}/** * 100원씩 출금하는 스레드 */public class AccountWithdrawThread extends Thread { private final Account account; public AccountWithdrawThread(Account account) { this.account = account; } @Override public void run() { account.withdraw(100); }}public class AccountApp { public static void main(String[] args) { Account account = new Account(1000); // 스레드 여러개 만들어서 실행하기 IntStream.range(0, 15).forEach(i -&amp;gt; new AccountWithdrawThread(account).start()); }}Insufficient balanceInsufficient balanceInsufficient balanceInsufficient balanceInsufficient balancebalance is : 0balance is : 600balance is : 900balance is : 500balance is : 300balance is : 100balance is : 700balance is : 400balance is : 200balance is : 800위 예제에서 보면 출력 순서가 엉망인 것을 볼 수 있습니다.이 상태에서 Account 클래스의 withdraw 메소드에 synchronized 키워드를 붙여주면 동시접근이 되지 않기 때문에 순차적으로 출력이 되는 것을 볼 수 있습니다./** * 출금만 가능한 계좌 */public class Account { // ... public synchronized void withdraw(int money) { // ... }}balance is : 900balance is : 800balance is : 700balance is : 600balance is : 500balance is : 400balance is : 300balance is : 200balance is : 100balance is : 0Insufficient balanceInsufficient balanceInsufficient balanceInsufficient balanceInsufficient balance데드락 (Deadlock)https://www.geeksforgeeks.org/deadlock-in-java-multithreading/데드락(Deadlock) 또는 교착상태란 최소 두개의 스레드가 다른 리소스에 대해 락(lock)을 유지하고 있고 둘 다 다른 리소스가 작업을 완료할 때까지 기다리는 상황입니다.그리고 어느 누구도 자신이 보유하고 있는 리소스에 대한 잠금을 해제할 수 없는 상태입니다.데드락 발생 조건아래 조건이 동시에 성립하는 경우에 데드락이 발생 합니다.즉, 하나의 조건이라도 불충족해야 데드락이 발생하지 않습니다. 상호 배제(Mutual Exclusion): 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다. 점유 대기(Hold and Wait): 자원을 점유하면서도 다른 프로세스가 사용하고 있는 자원에 대해대기 비선점(No Preemption): 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없음. 순환 대기(Circular Wait): 락 자원 획득이 T1(A -&amp;gt; B), T2(B -&amp;gt; C), T3(C -&amp;gt; D), T4(D -&amp;gt; A) 로 되어 있고, 서로가 물려 있는 상태를 뜻함." }, { "title": "[Live Study] 9주차 과제: 예외 처리", "url": "/posts/java-livestudy-9week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, exception", "date": "2021-01-10 18:05:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 예외 처리에 대해 학습하세요.Error / Exception자바 예외의 계층 구조 (출처: https://www.geeksforgeeks.org/exceptions-in-java/) 계층 구조를 보시면 Error와 Exception 모두 Throwable의 서브 클래스인 것을 볼 수 있습니다.ErrorError는 어플리케이션 내에서 핸들링 할 수 없으므로 예외처리가 불가능하거나 할 수 없는 심각한 문제입니다.주로 JVM에서 발생되는 것이 많으며 어플리케이션에서 처리를 할 수 없습니다.자주 보는 에러로는 OutOfMemoryError, StackOverflowError 등이 있습니다.IDE에서 Error 클래스를 찾아서 자식 클래스들을 확인할 수 있습니다.ExceptionError가 어플리케이션에서 핸들링할 수 없었다면 Exception은 어플리케이션에서 처리를 할 수 있는 에러들을 얘기하며 예외라고 합니다.NullPointerException, IllegalArgumentException 등이 이에 해당합니다.Checked / Unchecked Exception위에서 공부한 Exception은 또 다시 Checked Exception과 Unchecked Exception으로 구분 됩니다.Checked ExceptionChecked Exception은 확인된 예외로 컴파일 시점에 확인되는 예외를 말합니다.그렇기 때문에 Checked Exception은 명확하고 잘 정의된 특정 상황에 발생하고 어플리케이션이 부분적 또는 전체적으로 복구될 수 있는 상태의 예외 입니다.InputStream is = new FileInputStream(&quot;&quot;);이런 코드를 작성한다면 이 상태로는 컴파일이 불가하다는 것을 알 수 있습니다.저 코드에 처리해야할 확인된 예외가 있기 때문입니다.try { InputStream is = new FileInputStream(&quot;&quot;);} catch (FileNotFoundException e) { e.printStackTrace();}간단한 예시 이지만 이렇게 예외 처리를 컴파일 시점에 강제 합니다.Unchecked ExceptionChecked Exception과 반대로 컴파일 시점에 확인할 수 없는 예외를 말합니다.모든 Unchecked Exception은 RuntimeException을 상속합니다.List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();list.get(0);List의 get 메소드에서 IndexOutOfBoundsException 예외가 발생할 수 있습니다.이 예외는 RuntimeException을 상속하고 있고 이름답게 컴파일 시점에 처리를 강제하지 않기 때문에 확인이 어렵고 런타임 시점에 예외를 발생시켜 장애를 유발할 수 있습니다.예외 처리를 하는 이유private void process(String str) { System.out.println(&quot;str의 길이 : &quot; + str.length());}process(null);위 코드는 컴파일 에러가 나지 않고 실행이 가능하지만 실제로 실행한다면 어떻게 될까요?str.length()를 호출할 때 NullPointerException이 발생하여 프로그램이 비정상적으로 종료가 됩니다.NullPointerException은 Unchecked Exception 입니다.이렇게 어떠한 예외가 발생했을 때 그에 대응하는 코드를 작성하여 비정상적인 종료를 방지하고 장애에 대비할 수 있습니다.위 예제를 통해 예외 처리하는 방법을 알아보겠습니다.try / catch / finally자바는 기본적인 예외 처리 문(statement)인 try/catch/finally 문을 지원합니다.trytry 블럭은 예외를 처리할 대상이 되는 코드를 입력하기 위해 사용 됩니다.try 블럭 자체로는 특별한 역할을 하지 않지만 이어서 catch 블럭 혹은 finally 블럭이 필수로 필요합니다.기본적인 사용 방법은 아래와 같습니다.private void process(String str) { try { System.out.println(&quot;str의 길이 : &quot; + str.length()); }} try 블럭을 단독으로 사용하면 컴파일 에러가 발생합니다.catchcatch 블럭은 try 블럭에서 발생한 예외를 처리하기 위해 사용되며 여러 catch 블럭을 사용하여 다양한 예외를 처리할 수 있습니다.catch 블럭이 처리할 수 있는 타입은 Throwable의 서브클래스들 입니다.try 블럭에서 예외가 던져지면(throw) Java 인터프리터는 던져진 예외와 동일한 타입 혹은 예외의 슈퍼 클래스가 파라미터로 있는 catch 절을 찾습니다.private void process(String str) { try { System.out.println(&quot;str의 길이 : &quot; + str.length()); } catch (NullPointerException e) { System.out.println(&quot;str는 null 입니다.&quot;); }}process(null); // str는 null 입니다.process(&quot;sangwoo&quot;); // str의 길이 : 7NullPointerException 예외는 RuntimeException의 자식 클래스 입니다.그러므로 catch 블럭에서 처리할 예외를 RuntimeException으로 변경하여도 동일하게 동작합니다.private void process(String str) { try { System.out.println(&quot;str의 길이 : &quot; + str.length()); } catch (RuntimeException e) { // NullPointerException을 RuntimeException으로 변경 System.out.println(&quot;str는 null 입니다.&quot;); }}process(null); // str는 null 입니다.process(&quot;sangwoo&quot;); // str의 길이 : 7여러 예외를 별도로 처리하려면 catch 블럭을 여러개 추가하면 됩니다.만약 List 객체에서 요소가 없는 인덱스에 접근하면 IndexOutOfBoundsException이 발생합니다.이 예시를 추가해보면 아래와 같아집니다.private void process(String str) { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); try { System.out.println(&quot;str의 길이 : &quot; + str.length()); System.out.println(&quot;list.get(1) : &quot; + list.get(1)); // 요소가 없는 인덱스 접근 } catch (NullPointerException e) { System.out.println(&quot;str는 null 입니다.&quot;); } catch (IndexOutOfBoundsException e) { System.out.println(&quot;IndexOutOfBoundsException이 발생하였습니다.&quot;); }}process(null); // str는 null 입니다.process(&quot;sangwoo&quot;); // str의 길이 : 7, IndexOutOfBoundsException이 발생하였습니다.만약 여러 예외를 공통 처리하려면 하나의 catch 블럭으로 처리하면 됩니다.private void process(String str) { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); try { System.out.println(&quot;str의 길이 : &quot; + str.length()); System.out.println(&quot;list.get(1) : &quot; + list.get(1)); } catch (NullPointerException | IndexOutOfBoundsException e) { // 여러 예외를 하나의 catch로 처리 System.out.println(&quot;NullPointerException 또는 IndexOutOfBoundsException 발생&quot;); }}process(null); // NullPointerException 또는 IndexOutOfBoundsException 발생process(&quot;sangwoo&quot;); // str의 길이 : 7, NullPointerException 또는 IndexOutOfBoundsException 발생NullPointerException, IndexOutOfBoundsException 두 예외 모두 RuntimeException의 자식 클래스에 해당하므로 아래와 같이 한 번에 처리도 가능합니다.private void process(String str) { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); try { System.out.println(&quot;str의 길이 : &quot; + str.length()); System.out.println(&quot;list.get(1) : &quot; + list.get(1)); } catch (RuntimeException e) { // NullPointerException, IndexOutOfBoundsException 둘다 캐치 됨 System.out.println(&quot;RuntimeException 발생&quot;); }}process(null); // RuntimeException 발생process(&quot;sangwoo&quot;); // str의 길이 : 7, RuntimeException 발생finallyfinally 블럭은 일반적으로 try 블럭의 코드를 정리하는데 사용합니다.try 블럭의 코드의 완료 방식과 상관 없이 try 블럭이 일부만 실행되더라도 finally 블럭의 실행은 보장됩니다.즉 중간에 예외 발생으로 catch 블럭으로 빠지더라도 finally 블럭은 실행됩니다.InputStream is = null;try { is = new FileInputStream(&quot;&quot;); // is 사용하기...} catch (FileNotFoundException e) { e.printStackTrace();} finally { is.close();} 이렇게 파일을 닫거나 네트워크 연결을 종료할 때 유용합니다.위 예제처럼 catch 블럭이 없더라도 finally 블럭이 적용 가능합니다.private void processFinally() { String str = null; try { str = &quot;여기는 try 블럭&quot;; } finally { str = &quot;여기는 finally 블럭&quot;; } System.out.println(str);}processFinally(); // 여기는 finally 블럭throwthrow 문(statement)은 특정 시점에 예외를 던져서 호출한 곳에 예외를 알리는 것 입니다.던질 수 있는 타입은 Exception을 포함한 하위 타입 입니다.private void printInt(int i) { if (i &amp;lt; 5) { throw new IllegalArgumentException(&quot;i는 5 이상이어야 합니다.&quot;); } System.out.println(&quot;i : &quot; + i);}printInt(6); // i : 6printInt(1); // 예외 발생!위 예제에서 printInt(1) 문장에서 예외가 발생하고 아래와 같이 로그가 나옵니다.이를 처리하기 위해서는 위에서 공부한 것 처럼 try/catch 블럭을 사용하면 됩니다.try { printInt(1);} catch (IllegalArgumentException e) { System.out.println(e.getMessage());}// i는 5 이상이어야 합니다.위 문장을 실행하면 catch 블럭으로 빠지고 예외에 정의된 메시지를 가져오는 e.getMessage()를 출력하게 되는데 이 에러 메시지는 printInt() 메소드에서 에러를 던지는 부분에 정의되어 있습니다.throw new IllegalArgumentException(&quot;i는 5 이상이어야 합니다.&quot;); IllegalArgumentException 생성자의 파라미터가 에러 메시지 입니다.throwsChecked Exception은 명시적으로 에러를 처리하기를 강제하고 이 예외를 처리하기 위해서 try/catch 절을 사용할 수 있습니다.그런데 만약 이 메소드에서 예외 처리를 하지 않고 호출하는 메소드로 예외를 전파시키고 싶다면 사용할 수 있는 것이 바로 throws 절 입니다.메소드 시그니처 끝에 붙일 수 있고 호출하는 메소드로 예외 처리를 전파시켜 떠넘기는 개념으로 볼 수 있습니다.메소드가 하나 이상의 Checked Exception을 throw 하고 있다면 throws에 명시해야 합니다.단, Uncheked Exception의 경우에는 예외 처리가 강제되지 않기 때문에 throws 절을 명시하지 않더라도 예외가 전파됩니다.private void doCheckedException() throws Exception { // Exception은 Checked Exception throw new Exception();}private void processException() { doCheckedException();}위와 같이 작성했다면 doCheckedException 부분에서 컴파일 에러가 발생 합니다.이 때 throws 절을 사용하여 예외를 전파 시킵니다.private void processException() throws Exception { doCheckedException();}private void receive() { try { processException(); } catch (Exception e) { e.printStackTrace(); }} processException에서 던진 예외를 호출하는 쪽에서 처리하도록 강제합니다.만약 Unchecked Exception이라면 throws 절을 명시하지 않아도 됩니다.private void doUncheckedException() { // RuntimeException은 Unchecked Exception throw new RuntimeException();}private void processException() { doUncheckedException();} 단, 예외로 인해 프로그램이 장애가 발생할 수 있는 것은 동일 합니다.try-with-resources만약 리소스를 더이상 사용하지 않아 자원을 정리하거나 닫아야할 때 일반적으로는 finally 문에서 is.close() 메소드를 사용하는 것처럼 자원을 해제해야 합니다.InputStream is = null;try { is = new FileInputStream(&quot;&quot;); // is 사용하기...} catch (IOException e) { e.printStackTrace();} finally { is.close();}예제의 문제점 자원 처리를 위해 InputStream 객체를 상단에 null로 선언이 필요함. 개발자는 잊지말고 finally에서 자원해제를 해줘야함. (실수하면 메모리 누수가 발생함.) is.close() 메소드는 Checked Exception을 던지고 있기 때문에 예외 처리가 필요함. (주로 throws로 처리함)위 문제들을 쉽게 해결하기 위해 Java 7 이상에서 지원하는 문법이 등장했는데 바로 try-with-resources (줄여서 TWR) 입니다.try-with-resources를 사용한다면 위 예제에 비해 깔끔한 코드를 볼 수 있습니다.try (InputStream is = new FileInputStream(&quot;&quot;)) { // is 사용하기...} catch (IOException e) { System.out.println(&quot;IOException 발생 : &quot; + e.getMessage());} 예외 처리는 필요하다면 해주어야 합니다!try-with-resources의 핵심은 AutoCloseable 인터페이스 입니다.이 인터페이스는 Closable의 부모 클래스이며 close() 메소드를 가지고 있습니다.이 인터페이스를 통해 리소스는 try 블럭으로 스코프가 한정되고 올바른 순서로 자동으로 닫히게 됩니다.assertassert 문(statement)는 주로 코드에서 설계를 검증하는 기능을 제공합니다.boolean 타입의 표현식을 만들어 평가할 수 있고 결과가 false일 경우 검사가 실패하고 java.lang.AssertionError를 발생시킵니다.assert &amp;lt;검사식&amp;gt; : &amp;lt;에러코드&amp;gt;assertion 활성화assert를 사용하기 위해서는 assertion을 활성화시켜야하는데 필요한 옵션은 -ea 입니다.콘솔로 실행할 경우 아래와 같이 옵션을 줄 수 있습니다.java -ea &amp;lt;클래스명&amp;gt;Intellij의 경우엔 아래와 같이 옵션을 줄 수 있습니다.Edit Configurations - Modify options - Add VM optionsassert 사용assertion이 활성화되었고 아래와 같이 코드에 assert 문이 존재한다면 검사할 수 있습니다.private void doAssert(int i) { assert i &amp;gt; 1; System.out.println(&quot;i : &quot; + i);}doAssert(2); // 정상 통과doAssert(0); // AssertionError 발생!doAssert(2)는 정상 통과 한 것을 볼 수 있습니다.만약 에러코드를 추가하여 실행하면 아래와 같습니다.private void doAssert(int i) { assert i &amp;gt; 1 : &quot;i는 1보다 커야함&quot;; System.out.println(&quot;i : &quot; + i);}doAssert(0); // AssertionError 발생!readable한 에러 코드가 있습니다.예외처리 전략위에서 알아본 다양한 예외처리를 위한 문법을 사용하여 예외처리 전략에 따라 적용해 볼 수 있습니다. 출처 : 토비의 스프링 3.1 Vol.1 4장 예외예외 복구예외 복구는 문제를 파악하고 해결하여 정상 상태로 돌려놓는 방법 입니다.어떤 예외로 발생하였을 때 다른 작업 흐름으로 자연스럽게 유도해주는 것입니다.가장 대표적으로 try/catch/finally 절을 사용할 수 있습니다.private void printStr(String str) { try { System.out.println(&quot;str length : &quot; + str.length()); } catch (NullPointerException e) { System.out.println(&quot;str is null!&quot;); }}printStr(&quot;hello&quot;); // 5 (정상 케이스)printStr(null); // str is null! (예외 처리되어 다른 작업 흐름으로 이어짐)예외처리 회피예외처리 회피는 자신이 직접 예외처리하지 않고 호출하는 메소드로 전파시키는 방법 입니다.throws 문으로 예외를 회피하는 방법과 catch 블럭으로 일단 예외를 잡은 후에 로그를 남기고 다시 throw 하는 방법이 있습니다.// throws로 회피하기public void process() throws SQLException { // jdbc 로직...}// catch 후 로그 남기고 다시 throwpublic void process2() throws SQLException { try { // jdbc 로직... } catch (SQLException e) { System.out.println(e.getMessage()) throw e; }} Unchecked Exception이라면 throws 없이 회피가 가능합니다.예외 전환예외 전환은 예외 회피와 비슷하다고 볼 수 있지만 발생한 예외를 그대로 넘기지 않고 더 적절한 예외로 전환하여 던지는 특징이 있습니다.내부에서 발생한 예외가 모호하여 의미가 명확한 예외를 던지기 위해 전환할 수 있습니다.// 예외의 에러 코드에 따라 분기하여 예외 전환public void add(User user) throws DuplicateUserIdException, SQLException { try { // code .. } catch (SQLException e) { if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) { throw new DuplicateUserIdException(); } throw e; }}이렇게 예외를 전환할 때는 기존 예외를 담아서 중첩 예외로 만드는 것이 좋습니다.catch (SQLException e) { throw new DuplicateUserIdException(e);}예외를 처리하기 쉽게 포장하기 위해 전환할 수 있습니다.예를 들어 Checked Exception을 잡아서 Unchecked Exception으로 던져서 해당 메소드를 사용 하는 곳에서 일일히 에러 처리를 할 필요가 없습니다.private void process() { try { // code ... } catch (Exception e) { throw new RuntimeException(e); }}커스텀한 예외 만드는 방법커스텀 예외가 필요한 이유는 다음과 같습니다. 비즈니스 로직이나 업무 흐름과 관련된 예외를 만들어 개발자나 사용자가 정확한 문제를 파악하기 더 쉽습니다. (커스텀 Checked Exception으로 예제 코딩) 기존 예외 집합의 특정 처리를 제공하기 위해서 커스텀 예외를 만들 수 있습니다. (커스텀 Unchecked Exception으로 예제 코딩)Checked Exception 커스텀Exception 클래스를 상속 받아서 간단하게 만들 수 있습니다.Exception 클래스에는 다양한 생성자가 존재하니 요구사항에 맞춰 사용할 수 있습니다.Exception 클래스의 생성자들이렇게 만든 예외를 필요에 따라 광범위한 예외에서 일부분의 경우의 예외로 분리할 수 있습니다.이 예제는 예외 전환 예제와 비슷합니다.// 커스텀한 Checked Exceptionpublic class InvalidFileNameException extends Exception { public InvalidFileNameException(Throwable e) { // 예외 중첩을 사용하기 위한 생성자 super(e); }}// 적용하기private void processFile(String fileName) throws InvalidFileNameException, FileNotFoundException { try { new FileInputStream(fileName); } catch (FileNotFoundException e) { if (fileName.length() &amp;lt; 1) { throw new InvalidFileNameException(e); } throw e; }} Checked Exception 이기 때문에 throws 절에 입력해줘야 합니다.또한 예외 전환 뿐만 아니라 일반적인 비즈니스 로직에서 예외를 발생시키고 싶을 때도 사용이 가능합니다.private void printFileName(String fileName) throws InvalidFileNameException { if (fileName.length() &amp;lt; 1) { throw new InvalidFileNameException(e); } System.out.println(fileName);}Unchecked Exception 커스텀Unchecked Exception을 커스텀하려면 RuntimeException을 상속해야 합니다.실제 개발 중에 예외를 커스텀 해야할 일이 있다면 대부분 이 경우에 해당합니다.만약 한 메소드에서 여러 예외를 발생시키는데 하나의 예외로 처리할 수 있습니다.// Unchecked Exception 상속public class AddContentException extends RuntimeException { private final String code; public AddContentException(Throwable cause, String code) { super(cause); this.code = code; } public String getCode() { return code; }}// 적용하기private void addContent() { try { // logic........... } catch (SomeException1 | SomeException2 e) { throw new AddContentException(e, e.getCode()); } catch (SomeException3 e) { throw new AddContentException(e, &quot;SE3&quot;); }} 예제의 SomeException 시리즈는 모두 가상입니다!결론그동안 결론은 작성하지 않았었는데 이번에는 포스팅이 꽤 길어져 써 봅니다.완벽한 프로그램은 없다고 생각하기 때문에 언제든지 장애가 발생할 수 있다고 생각합니다.그럴 때 예외 처리를 잘 한다면 장애에 대응하고 복구하고 개선하는 작업까지 조금 더 수월하게 할 수 있을 것이라고 생각합니다.모두 열공하세요!" }, { "title": "[Live Study] 8주차 과제: 인터페이스", "url": "/posts/java-livestudy-8week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, interface", "date": "2021-01-04 18:05:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 인터페이스에 대해 학습하세요.인터페이스를 정의하는 방법인터페이스란?자바는 클래스를 하나만 상속이 가능한 특성이 있는데 이는 객체지향 프로그래밍에서 큰 제약이기 때문에 인터페이스(Interface)라는 개념을 도입하였습니다.인터페이스라는 이름답게 디자인(설계)적인 요소를 위한 유형이므로 메소드를 정의하지만 기본적으로 구현 코드는 제공하지 않습니다.다만 인터페이스를 구현(implementation)하는 클래스에서 메소드의 내용을 구현해야합니다.인터페이스 정의 인터페이스의 모든 메소드는 추상적입니다. 인터페이스는 공용 API를 정의하기 때문에 암시적으로 public 이므로 생략하는 것이 일반적입니다. 인스턴스 필드를 정의할 수 없습니다. (필드는 구현의 세부사항이고 인터페이스는 구현이 아니라 사양입니다.) 인터페이스는 인스턴스화 할 수 없으므로 생성자가 필요 없습니다. 인터페이스는 중첩될 수 있습니다. Java 8부터 인터페이스에 static 메소드를 정의할 수 있습니다. (Java의 설계 결함으로 알려져 있습니다.) Java 8부터 인터페이스에 default 메소드를 정의할 수 있습니다. Java 9부터 인터페이스에 private 메소드를 정의할 수 있습니다.public interface Animal { String getName(); int getLegs();} 메소드 정의만 있고 구현은 없습니다.인터페이스를 구현하는 방법인터페이스를 구현하는 클래스를 만드는 방법은 상속과 비슷하지만 키워드가 다릅니다.상속과 개념적으로 다르고 인터페이스를 구현하는 의미이기 때문에 implements 키워드를 사용합니다.그리고 인터페이스에 정의되어 있는 메소드를 필수적으로 구현해야 합니다.public class Cat implements Animal { @Override public String getName() { return &quot;고양이&quot;; } @Override public int getLegs() { return 4; }} 필수적으로 getName(), getLegs() 메소드를 구현해야 합니다.인터페이스 레퍼런스를 통해 구현체를 사용하는 방법먼저 위에서 Animal 인터페이스를 구현한 Cat 클래스처럼 다른 구현체를 만들어보겠습니다.public class Bird implements Animal { @Override public String getName() { return &quot;새&quot;; } @Override public int getLegs() { return 2; }}이제 Animal 인터페이스의 구현체인 Cat, Bird 클래스가 있습니다.이 두 클래스를 인스턴스화 하여 메소드를 호출 해보겠습니다.Cat cat = new Cat();Bird bird = new Bird();System.out.println(cat.getName()); // 고양이System.out.println(cat.getLegs()); // 4System.out.println(bird.getName()); // 새System.out.println(bird.getLegs()); // 2cat, bird 인스턴스는 Animal 타입으로도 생성 가능합니다.Animal cat = new Cat();Animal bird = new Bird();Animal 인터페이스를 파라미터로 받는 메소드가 있다면 Cat, Bird 타입의 인스턴스를 파라미터로 사용할 수 있습니다.public void printAnimal(Animal animal) { System.out.println(&quot;이름 : &quot; + animal.getName()); System.out.println(&quot;다리 개수 : &quot; + animal.getLegs());}Cat cat = new Cat();Bird bird = new Bird();printAnimal(cat);printAnimal(bird);인터페이스 상속인터페이스는 다른 인터페이스를 상속(확장)할 수 있습니다.클래스가 다른 클래스를 상속하는 것과 동일하게 extends 키워드를 사용하여 인터페이스를 상속할 수 있습니다.부모 인터페이스의 모든 메소드와 상수를 상속하고 새 메소드와 상수를 정의할 수 있습니다.public interface PrintableAnimal extends Animal { void print();}// 구현 클래스public class Puppy implements PrintableAnimal { // Animal 인터페이스 메소드 구현 @Override public String getName() { return &quot;강아지&quot;; } // Animal 인터페이스 메소드 구현 @Override public int getLegs() { return 4; } // PrintableAnimal 인터페이스 메소드 구현 @Override public void print() { System.out.println(&quot;이름 : &quot; + getName()); System.out.println(&quot;다리개수 : &quot; + getLegs()); }} PrintableAnimal의 구현체를 만들면 PrintableAnimal의 부모 인터페이스인 Animal 인터페이스의 메소드도 구현해야 합니다.또한 클래스는 단 하나의 클래스만 상속이 가능하지만 인터페이스는 여러 인터페이스를 상속할 수 있습니다.public interface PrintableAnimal extends Animal, Comparable&amp;lt;PrintableAnimal&amp;gt; { void print();}// 구현체public class Puppy implements PrintableAnimal { // Animal 인터페이스 메소드 구현 @Override public String getName() { return &quot;강아지&quot;; } // Animal 인터페이스 메소드 구현 @Override public int getLegs() { return 4; } // PrintableAnimal 인터페이스 메소드 구현 @Override public void print() { System.out.println(&quot;이름 : &quot; + getName()); System.out.println(&quot;다리개수 : &quot; + getLegs()); } // Comparable 인터페이스 메소드 구현 @Override public int compareTo(PrintableAnimal o) { return getLegs() - o.getLegs(); }}Puppy 클래스의 계층 구조Puppy 클래스는 계층 구조에 따라 Animal, PrintableAnimal 타입으로 인스턴스화가 가능합니다.그리고 위에서 사용했던 printAnimal 메소드도 사용할 수 있습니다.Puppy puppy1 = new Puppy();PrintableAnimal puppy2 = new Puppy();Animal puppy3 = new Puppy();printAnimal(puppy1);printAnimal(puppy2);printAnimal(puppy3);인터페이스의 기본 메소드 (Default Method)Java 8 부터 도입된 기능으로 구현을 포함하는 메소드를 포함한 인터페이스를 정의할 수 있습니다.위에서 정의한 PrintableAnimal 인터페이스의 print() 메소드를 매번 구현할 필요가 없다고 느끼면 기본 메소드로 정의하여 사용할 수 있습니다.또한 상속한 인터페이스의 메소드도 기본 메소드로 정의할 수 있습니다.// 인터페이스public interface PrintableAnimal extends Animal, Comparable&amp;lt;PrintableAnimal&amp;gt; { // 자신의 메소드를 기본 메소드로 구현 default void print() { System.out.println(&quot;이름 : &quot; + getName()); System.out.println(&quot;다리개수 : &quot; + getLegs()); } // Comparable 인터페이스의 메소드를 상속하여 기본 메소드 구현 @Override default int compareTo(PrintableAnimal o) { return getLegs() - o.getLegs(); }}// 구현체public class Snake implements PrintableAnimal { @Override public String getName() { return &quot;뱀&quot;; } @Override public int getLegs() { return 0; }}// 사용하기Snake snake = new Snake();snake.print(); // PrintableAnimal의 기본 메소드 사용 default 키워드를 사용하여 기본 메소드를 구현할 수 있고 기본 메소드는 구현체에서 필수로 구현할 필요가 없습니다.하위 호환성기본 메소드는 구현체에서 필수적으로 해당 메소드를 구현할 필요가 없기 때문에 하위 호환이 가능합니다.만약 PrintableAnimal 인터페이스에 새로운 기능의 추가가 필요하다면 기존에는 메소드 정의 후 각 구현체에서 구현이 필요했거나 인터페이스를 래핑하는 기본 클래스가 필요했지만 기본 메소드로 구현한다면 인터페이스의 구현체인 Snake 클래스에는 영향이 없습니다.public interface PrintableAnimal extends Animal, Comparable&amp;lt;PrintableAnimal&amp;gt; { // ... // 기본 메소드 추가 default void otherDefaultMethod() { System.out.println(&quot;other default method&quot;); }}// 구현체는 변화 없음...public class Snake implements PrintableAnimal, Printer { @Override public String getName() { return &quot;뱀&quot;; } @Override public int getLegs() { return 0; }}기본 메소드 주의 사항만약 아래와 같이 Snake 클래스에서 두 인터페이스를 상속하는데 각 인터페이스에 print() 기본 메소드가 정의되어 있다면 어떻게 할까요?public interface Printer { default void print() { System.out.println(getClass().getSimpleName()); }}public class Snake implements PrintableAnimal, Printer { // 어떤 print() 메소드를 사용하게 될까...}요즘 IDE는 너무 똑똑하기 때문에 문제를 발견하는데는 어려움이 없습니다.Intellij는 똑똑합니다.Snake 클래스에서 print 메소드를 직접 구현해야하며 두 인터페이스의 메소드를 사용하는 방법도 있습니다.public class Snake implements PrintableAnimal, Printer { // ... @Override public void print() { PrintableAnimal.super.print(); // PrintableAnimal의 print() 메소드 호출 Printer.super.print(); // Printer의 print() 메소드 호출 // 혹은 직접 구현... }}인터페이스의 static 메소드Java 8에서 도입된 기능으로 인터페이스에 static 메소드 추가가 가능합니다.클래스에서와 동일하게 사용 가능하며 기본적으로 public으로 간주합니다.static 메소드 이므로 상속이 불가능 합니다.public interface PrintableAnimal extends Animal, Comparable&amp;lt;PrintableAnimal&amp;gt; { static String getDescription() { return &quot;출력기능이 있는 동물 인터페이스&quot;; }}System.out.println(PrintableAnimal.getDescription()); // 출력기능이 있는 동물 인터페이스v인터페이스의 private 메소드Java 9에서 도입된 기능으로 이미 Java 8에서 기본 메소드 사용이 가능해졌기 때문에 로직을 분리하기 위해 사용할 수 있습니다. private 메소드 이기 때문에 인터페이스에서 구현이 되어 있어야하고 추상(abstract) 메소드일 수 없습니다. 구현체에서 구현할 수 없고 자식 인터페이스에서도 상속이 불가능 합니다. static 메소드도 private이 가능합니다.public interface PrintableAnimal extends Animal, Comparable&amp;lt;PrintableAnimal&amp;gt; { static String getDescription() { return &quot;출력기능이 있는 동물 인터페이스&quot;; } // 자신의 메소드를 기본 메소드로 구현 // private 메소드 사용 default void print() { printName(); printLegs(); } // private 메소드로 기본 메소드에서 사용할 로직 분리 1 private void printName() { System.out.println(&quot;이름 : &quot; + getName()); } // private 메소드로 기본 메소드에서 사용할 로직 분리 2 private void printLegs() { System.out.println(&quot;다리개수 : &quot; + getLegs()); } // Comparable 인터페이스의 메소드를 상속하여 기본 메소드 구현 @Override default int compareTo(PrintableAnimal o) { return getLegs() - o.getLegs(); } default void otherDefaultMethod() { System.out.println(&quot;other default method&quot;); }} 이번 포스팅의 모든 예제를 종합한 완전체 느낌…" }, { "title": "[Live Study] 7주차 과제: 패키지", "url": "/posts/java-livestudy-7week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, package", "date": "2020-12-28 21:10:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 패키지에 대해 학습하세요.package 키워드패키지란? 패키지란 여러분이 만든 클래스나 인터페이스 등을 모은 단위 입니다. 관련 클래스를 그룹화하고 포함된 클래스의 네임스페이스를 정의하는 역할 입니다. 모든 클래스에는 정의된 클래스 이름과 패키지 이름이 있습니다. 이 둘을 합쳐야 완전하게 한 클래스를 표현한다고 할 수 있으며 FQCN(Fully Qualified Class Name) 이라고 합니다. 파일 시스템의 디렉토리와 비슷한 역할을 하기 때문에 패키지명과 동일한 디렉토리 구조를 따라야 합니다.예를 들어 String 클래스의 패키지는 java.lang이며 FQCN은 java.lang.String이 됩니다.String a = &quot;Class Name&quot;;java.lang.String b = &quot;Full Package Class Name&quot;;package 키워드 사용법package 키워드는 클래스가 포함될 패키지를 지정할 때 사용 됩니다.예들 들어 여러분이 만든 클래스에 패키지명을 주기 위해 클래스 파일 상단에 아래와 같이 작성할 수 있습니다.package dev.baesangwoo.livestudy.week7;class SampleClass { // code...}위와 같은 클래스가 있다면 FQCN은 dev.baesangwoo.livestudy.week7.SampleClass가 됩니다.만약 동일 패키지에 있는 클래스를 사용한다면 패키지명은 명시하지 않아도 됩니다.// Sample Classpackage dev.baesangwoo.livestudy.week7;class SampleClass { // code...}// Example Classpackage dev.baesangwoo.livestudy.week7; // 동일 패키지class ExampleClass { SampleClass sample = new SampleClass();}import 키워드import 키워드는 다른 패키지에 있는 클래스나 인터페이스 등을 참조할 때 사용합니다.동일 패키지의 클래스나 java.lang 패키지의 클래스는 import 구문 없이 참조 가능합니다.이때 규칙은 FQCN을 입력해야 합니다.package dev.baesangwoo.livestudy.week7.model; // 클래스의 패키지import dev.baesangwoo.livestudy.week7.ExampleClass; // 타 패키지 클래스 임포트import dev.baesangwoo.livestudy.week7.SampleClass; // 타 패키지 클래스 임포트public class Week7Model { SampleClass sample = new SampleClass(); ExampleClass example = new ExampleClass();}만약 한 패키지의 여러 클래스를 임포트 한다면 *를 사용하여 임포트 할 수 있습니다. (다만 추천하진 않습니다.)package dev.baesangwoo.livestudy.week7.model;import dev.baesangwoo.livestudy.week7.*; // week7 패키지 모든 클래스 참조 가능public class Week7Model { SampleClass sample = new SampleClass(); ExampleClass example = new ExampleClass();}또한 정적(static) 멤버도 임포트도 가능합니다.package dev.baesangwoo.livestudy.week7.model;import static java.lang.System.out; // static 임포트public class Week7Model { public void print() { out.println(&quot;println&quot;); out.print(&quot;print&quot;); }}클래스패스(Classpath)클래스패스는 JVM 혹은 Java 컴파일러가 사용하는 파라미터인데 클래스나 패키지를 찾을 때 기준이 되는 경로를 말합니다.즉, java 명령을 통해 클래스 파일을 실행할 때 클래스 파일을 찾는 기준이 되는 경로를 클래스패스라고 하며 기본적으로는 java 명령을 실행하는 위치를 의미 합니다.java HelloWorld 명령이 실행 되는 현재 경로가 기본 클래스패스 입니다.CLASSPATH 환경변수위에서 설명한 클래스패스를 환경 변수를 통해 설정할 수 있습니다.위 예제와 같은 경로에서 동일한 명령인 java HelloWorld를 실행했지만 클래스를 찾을 수 없습니다.상단에서 CLASSPATH 환경 변수를 설정 했기 때문에 환경 변수에 설정된 클래스패스에서 HelloWorld.class 파일을 찾기 때문에 클래스를 찾을 수 없는 것 입니다.-classpath 옵션java 명령 실행 시 옵션으로 클래스패스를 지정할 수 있습니다.또한 CLASSPATH 환경 변수 설정 후 실행 하였는데 -classpath 옵션이 우선 순위가 높은 것을 볼 수 있습니다.또한 단축 옵션인 -cp 옵션도 동일한 기능을 합니다.접근지시자 (Access Modifiers)접근 지시자는 멤버 변수나 메소드들의 접근 범위를 정의하기 위해 사용 합니다. public : 접근을 제한하지 않아 어디서든 접근이 가능합니다. private : 클래스 내부에서만 접근을 허용 합니다. protected : 클래스 내부, 동일 패키지, 상속받은 클래스에서만 접근을 허용 합니다. default(명시하지 않음) : 클래스 내부와 동일 패키지에서만 접근이 가능합니다. 지시자 클래스 내부 동일 패키지 상속받은 클래스 이외 private O X X X default O O X X protected O O O X public O O O O " }, { "title": "[Live Study] 6주차 과제: 상속", "url": "/posts/java-livestudy-6week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, inheritance", "date": "2020-12-26 10:22:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 상속에 대해 학습하세요.자바 상속의 특징 자식 클래스는 부모 클래스의 내용을 상속할 수 있습니다. 서브 클래스에서 별도의 내용을 가질 수 있습니다. 자식 클래스는 부모 클래스를 알 수 있지만 부모 클래스는 자식 클래스를 알 수 없습니다. 자바의 상속은 다중 상속을 지원하지 않습니다. 자바의 모든 클래스는 기본적으로 java.lang.Object 클래스를 상속합니다.자바의 상속 사용법작성하는 클래스에서 다른 클래스를 상속하기 위해서는 extends 키워드를 사용할 수 있습니다./** * 부모 클래스 */public class Person { // code..}/** * 자식 클래스 (Person 클래스 상속) */public class Sangwoo extends Person { // code..}/** * 자식 클래스 (Person 클래스 상속) */public class Alan extends Person { // code..}자식 클래스로 객체를 생성할 때 부모 클래스 타입으로 할당할 수 있습니다.Sangwoo sangwoo = new Sangwoo();Person person = new Sangwoo(); // 자식 클래스 객체를 부모 클래스 타입으로 할당super 키워드먼저 자식 키워드에서 부모 클래스의 필드나 메소드를 참조하는 방법을 알아보겠습니다./** * 부모 클래스 */public class Person { public String name = &quot;person&quot;; public String getKorean() { return &quot;사람&quot;; }}/** * 자식 클래스 (Person 클래스 상속) */public class Sangwoo extends Person { public void print() { System.out.println(name); // 자식 클래스에서 부모 클래스의 필드 참조 System.out.println(getKorean()); // 자식 클래스에서 부모 클래스의 메소드 참조 }}위 예제 처럼 자식 클래스에서 부모 클래스에 선언되어 있는 필드나 메소드에 접근할 수 있습니다.그런데 만약 부모 클래스에 선언되어 있는 필드나 메소드가 자식 클래스에 동일하게 있다면 어떻게 해야할까요?/** * 자식 클래스 (Person 클래스 상속) */public class Alan extends Person { public String name = &quot;alan&quot;; public String getKorean() { return &quot;앨런&quot;; } public void print() { System.out.println(name); System.out.println(getKorean()); System.out.println(super.name); // 부모 클래스의 name 필드 접근 System.out.println(super.getKorean()); // 부모 클래스의 getKorean() 메소드 접근 }}위 예제 처럼 Alan 클래스에 선언된 필드나 메소드가 부모 클래스의 것과 이름이 동일하다면super 키워드를 사용하여 부모 클래스의 필드나 메소드로 호출이 가능합니다./** * 부모 클래스 */public class Person { public String name; public int age; public Person() { this.name = &quot;person&quot;; this.age = 10; } public Person(String name) { this.name = name; this.age = 10; } public Person(String name, int age) { this.name = name; this.age = age; }}또한 위와 같은 Person 클래스를 상속한다면 자식 클래스에서 Person 클래스의 생성자를 호출할 수 있습니다./** * 자식 클래스 (Person 클래스 상속) */public class Sangwoo extends Person { public Sangwoo(String name, int age) { super(name, age); // super(), super(name) 도 가능.. 필요에 따라 잘 사용하기.. } public void printName() { System.out.println(&quot;name : &quot; + name); }}메소드 오버라이딩 (Method Overriding)자식 클래스가 부모 클래스의 메소드와 동일한 이름, 파라미터, 리턴 타입을 사용하여 메소드를 재정의할 수 있습니다.super 예제에서 Alan 클래스에 작성된 getKorean()가 Person 클래스의 메소드를 오버라이딩한 것 입니다.public class A { public int m1(int x, int y) { return x + y; } public int m2(int x, int y) { return x * y; }}public class B extends A { // A 클래스의 a 메소드를 오버라이딩(재정의) @Override public int m1(int x, int y) { return x - y; }}A 클래스에 덧셈 로직으로 작성된 m1 메소드를 B 클래스에서 빼기 로직으로 오버라이딩 했습니다.A 클래스와 B 클래스 각각 객체를 생성하고 m1, m2 메소드를 실행 시킨다면 아래와 같습니다.A a = new A();B b = new B();a.m1(10, 2); // 12b.m1(10, 2); // 8a.m2(3, 2); // 6b.m2(3, 2); // 6m1 메소드는 B 클래스에서 오버라이딩 되었기 때문에 결과가 다르고m2 메소드는 B 클래스에서 오버라이딩 되지 않았기 때문에 b 객체에서도 A 클래스의 메소드를 호출합니다.메소드 디스패치 (Method Dispatch)메소드 디스패치란 어떤 메소드를 호출할지 결정하여 실제로 호출 시키는 과정을 말합니다.메소드 디스패치의 종류는 아래와 같습니다. 스태틱 메소드 디스패치 다이나믹 메소드 디스패치 더블 디스패치이 포스팅에서는 스태틱 메소드 디스패치와 다이나믹 메소드 디스패치만 알아보겠습니다.사용할 예시 클래스는 아래와 같습니다.public class Parent { public void print() { System.out.println(&quot;This is parent.&quot;); }}public class Child extends Parent { @Override public void print() { System.out.println(&quot;This is child.&quot;); }}스태틱 메소드 디스패치 (Static Method Dispatch)스태틱이라는 말 답게 컴파일 시점에 어떤 메소드가 호출될지 명확하게 알고 있는 경우를 말합니다.컴파일 시점에 알 수 있기 때문에 바이트 코드에도 정보가 남겨집니다.Parent p = new Parent();Child c = new Child();p.print(); // This is parent.c.print(); // This is child.다이나믹 메소드 디스패치 (Dynamic Method Dispatch)다이나믹 메소드 디스패치는 런타임 시점에 메소드 호출을 결정하는 경우를 말합니다.자바가 런타임 다형성을 구현하는 방법이며 재정의된 메소드가 호출된다면 참조하는 객체 타입에 따라 실제 호출될 메소드를 결정 합니다.다른 말로는 런타임 다형성(Runtime Polymorphism)이라고도 합니다.자식 클래스를 부모 클래스로 업캐스팅(upcasting) 발생합니다.Parent p1 = new Child(); // 업캐스팅p1.print();결과는 당연히 This is child. 겠지만 이 경우에 p1이 어떤 객체인지 컴파일 시점에 알기 어렵습니다.왜? 라고 생각하시나요? 조금 다른 예제를 보겠습니다.public void printParent(Parent p) { p.print();}Parent p1 = new Child();Parent p2 = new Parent();printParant(p1); // This is child.printParent(p2); // This is parent.위 결과도 당연히 이해는 되실거라고 생각합니다. 그런데 왜 런타임 시점에 호출될 메소드가 결정된다고 할까요?printParent 메소드 입장에서 보면 편합니다.printParent 메소드 입장에서 파라미터로 받는 p가 어떤 객체인지 컴파일 시점에 알 수 없기 때문입니다.추상 클래스추상 클래스는 메소드 정의만 있고 구현이 되어 있지 않은 메소드가 한 개 이상 존재하는 클래스를 추상 클래스라고 합니다.즉 구체적이지 않고 추상적인 클래스를 의미 하며 추상 클래스 안에 구현되어 있지 않은 메소드를 추상 클래스라고 합니다.클래스 앞에 abstract 키워드를 붙임으로써 추상 클래스를 생성할 수 있습니다.추상 메소드도 앞에 abstract 키워드를 붙여서 정의할 수 있습니다.abstract class AbstractService { abstract String getName(); // 물론 이런 일반적인 메소드도 넣을 수 있습니다. public int plus(int x, int y) { return x + y; }}추상 클래스는 다음과 같은 특징을 가지고 있습니다. 추상 메소드를 가지고 있는 클래스는 자동으로 자체적으로 추상화되며 그렇게 선언되어야 합니다. 그렇지 않으면 컴파일 에러가 납니다. (추상 메소드를 가진다면 추상 클래스이어야 한다!)class AbstractService { public int plus(int x, int y) { return x + y; } abstract String getName(); // 추상 메소드를 가지고 있으나 추상 클래스가 아니라 컴파일 에러 발생!!!} 추상 클래스는 인스턴스화 할 수 없습니다. (객체 생성 불가)// 컴파일 에러AbstractService service = new AbstractService(); 추상 클래스를 상속한 클래스는 모든 추상 메소드를 재정의(오버라이딩) 해야 합니다. 이러한 클래스들을 구체적인 하위 클래스(concrete subclass)라고도 합니다. 만약 추상 메소드를 재정의하지 않고 추상 클래스를 상속한다면 그 자체도 추상 클래스가 되어야 합니다. static, private, final 메소드는 하위 클래스에 의해 오버라이딩 될 수 없기 때문에 추상 메소드가 될 수 없습니다. 추상 메소드가 없더라도 추상 클래스를 정의할 수 있습니다. final 키워드final 키워드는 클래스, 변수, 메소드에서 사용할 수 있는 키워드로 더 이상 변할 수 없는 최종 상태 입니다.final 클래스final 클래스는 상속할 수 없습니다.final class FinalClass {}class SubClass extends FinalClass {} // 컴파일 에러final 변수final 변수의 값을 재할당할 수 없습니다.final String field = &quot;final field&quot;;field = &quot;reassign data&quot;; // 컴파일 에러final 메소드final 메소드는 오버라이딩할 수 없습니다.더불어 private 키워드와 중첩해서 사용하는건 권장하지 않습니다. private 어차피 메소드도 오버라이딩이 불가능 하기 때문입니다.class FinalSample { final String method() { return &quot;final method&quot;; }}public class FinalSampleImpl extends FinalSample { String method() { // 컴파일 에러 return &quot;overriding method&quot;; }}Object 클래스출처 : https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.htmljava.lang.Object 클래스이며 모든 클래스의 부모 클래스 입니다.별도의 필드는 정의되어 있지 않고 객체에서 기본적으로 사용되는 메소드들로 구성되어 있습니다.상황에 따라 equals, hashCode, toString 메소드 들을 주로 재정의 하여 사용합니다.이 외에 공식 문서를 살펴보면 많은 메소드들을 볼 수 있습니다." }, { "title": "[Live Study] 5주차 과제: 클래스", "url": "/posts/java-livestudy-5week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, class", "date": "2020-12-19 17:22:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 class에 대해 학습하세요.클래스 정의하는 방법클래스란 객체를 만들어서 사용할 수 있는 설계도나 틀로 이해할 수 있습니다.클래스는 데이터와 기능으로 구성되어 있으며 데이터는 필드로 정의하고 기능은 메소드로 구현합니다. class 키워드와 중괄호({, })를 사용하여 클래스 정의 class 키워드 앞에 제어자(modifier)가 필수로 들어가야함 public, protected, private : 접근 제어자 abstract : 추상 클래스 정의 final : 확장 불가능한 클래스 정의 strictfp : 엄격한 부동소수점 클래스 정의 (플랫폼 간 부동소수점 정밀도 보장) 어노테이션(annotation) 추가 가능 (ex: @Controller) 다른 클래스를 확장(상속)하는 경우 extends 를 사용 하나 이상의 인터페이스를 구현할 수 있으며 implements 키워드와 쉼표(,)를 사용// 클래스 정의public class User { // 데이터를 정의한 필드들 private static final String DESCRIPTION = &quot;유저 클래스&quot;; private String name = &quot;sangwoo&quot;; private int age = 20; // 기능을 정의한 메소드들 public static String getDescription() { return DESCRIPTION; } public String getName() { return name; } public int getAge() { return age; }}객체 만드는 방법 (new 키워드 이해하기)객체(instance)란 클래스를 통해 만들어 사용할 수 있는 실체를 말합니다.흔히 붕어빵에 비교를 많이 하는데 붕어빵 틀을 클래스, 붕어빵을 객체로 비교하고는 합니다.객체를 생성할 때 가장 일반적인 방법으로는 new 키워드를 사용할 수 있습니다.User sangwoo = new User();위 예제로 보면 User은 클래스(붕어빵 틀)이며 sangwoo는 객체(붕어빵)이 됩니다.메소드 정의하는 방법메소드란 클래스에서 기능을 담당하며 특정 작업을 수행하고 결과를 호출자에게 반환하는 역할을 합니다.결과를 반환하지 않고 내부적인 작업만 수행할 수도 있으며 반복적인 작업을 재사용하는 메소드도 작성할 수 있습니다.메소드는 클래스 메소드(Class Method)와 객체 메소드(Instance Method)로 구분할 수 있습니다. 클래스 메소드 : 정적 메소드라고도 하며 객체를 생성하지 않고 클래스 자체와 관련이 있는 메소드 객체 메소드 : 클래스를 통해 생성된 객체에서 사용할 수 있는 메소드메소드 작성 방법 (출처 : https://www.geeksforgeeks.org/methods-in-java/)위 예제 User 클래스에서 메소드는 아래와 같습니다.public class User { ... // 클래스 메소드 public static String getDescription() { return DESCRIPTION; } // 객체 메소드 public String getName() { return name; } public int getAge() { return age; }}static 키워드가 붙은 메소드가 클래스 메소드(정적 메소드)이며 아래와 같이 사용할 수 있습니다.객체를 생성하지 않고 클래스를 통해 직접 사용할 수 있습니다.User.getDescription(); // 유저 클래스객체 메소드는 객체를 생성하여 사용할 수 있습니다.// 객체 생성User sangwoo = new User();//메소드 사용sangwoo.getName(); // sangwoosangwoo.getAge(); // 20생성자 정의하는 방법생성자(constructor)는 객체를 생성하는 방법을 말합니다.위 User 클래스에는 아직 생성자가 없기 때문에 객체를 생성할 때 필드에 원하는 값을 넣어줄 수 없습니다.생성자를 사용하여 원하는 이름을 주입할 수 있습니다.생성자의 규칙은 아래와 같습니다.&amp;lt;public | private | protected&amp;gt; 클래스명 (&amp;lt;파라미터1&amp;gt;, &amp;lt;파라미터...&amp;gt;) { // 생성자 로직...}User 클래스에 생성자를 적용하여 객체를 생성하려면 아래와 같이 할 수 있습니다.public class User { ... private String name; private int age; // 생성자 : 이름을 입력 받는다. public User(String name) { this.name = name; this.age = 20; } ...}// 생성자를 사용하여 객체 생성User sangwoo = new User(&quot;baesangwoo&quot;);sangwoo.getName(); // baesangwoo다만 이제는 파라미터 없는 기본 생성자는 사용할 수 없으며 필요하다면 여러개의 생성자를 정의할 수 있습니다.public class User { ... private String name; private int age; public User(String name) { this.name = name; this.age = 20; } public User(String name, int age) { this.name = name; this.age = age; } ...}// 여러 생성자를 사용하여 객체 생성User user1 = new User(&quot;sangwoo&quot;);User user2 = new User(&quot;alan&quot;, &quot;30&quot;);this 키워드 이해하기this는 현재 객체를 나타내며 일반적으로는 필요하지 않기 때문에 메소드 등에서 사용되지 않습니다.어떠한 메소드에서 객체의 필드나 메소드에 접근한다면 암시적으로 this에 접근하는 것입니다.만약 메소드에서 받은 파라미터가 객체의 필드와 이름이 동일하다면 명시적으로 this로 구분해야 합니다.생성자 예제를 다시 보면…public class User { ... private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } ...}위 예제에서 this.name과 this.age는 객체의 필드를 의미하며 name과 age는 파라미터를 의미합니다.또한 메소드가 해당 객체의 필드나 메소드를 사용하고 있다는 것을 분명히 할 때 this를 사용할 수 있습니다." }, { "title": "[Live Study] 4주차 과제: 제어문", "url": "/posts/java-livestudy-4week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, operator", "date": "2020-12-07 22:57:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바가 제공하는 제어문을 학습하세요.선택문if / else if / elseifif 문은 자바가 결정을 내릴 수 있도록 하는 근본적인 제어문 중 하나 입니다.조건부로 문장(statement)을 실행하기 위해 사용 되므로 조건문이라고 합니다.public String getName(String name) { if (name == null) { // name이 null이라면... name = &quot;alan&quot;; } return name;}System.out.println(getName(&quot;sangwoo&quot;)); // sangwooSystem.out.println(getName(null)); // alanif / else필요에 따라 else 문을 추가하여 조건에 해당하지 않을 때 처리를 할 수 있습니다.public String getName(String name) { if (name == null) { name = &quot;alan bae&quot;; } else { // if 문이 true가 아니라면... name = name + &quot; bae&quot;; } return name;}System.out.println(getName(&quot;sangwoo&quot;)); // sangwoo baeSystem.out.println(getName(null)); // alan baeif / else if / else위와 같이 if/else문으로 두 가지 조건(if문의 true 혹은 false)을 처리할 수 있지만더 많은 조건을 평가하고 싶다면 else if를 if와 else의 사이에 추가하여 처리할 수 있습니다.public String intToString(int n) { if (n == 0) { return &quot;zero&quot;; } else if (n == 1) { return &quot;one&quot;; } else if (n == 2) { return &quot;two&quot;; } else { // n이 0도 1도 2도 아니라면... return &quot;other&quot;; }}System.out.println(intToString(0)); // zeroSystem.out.println(intToString(1)); // oneSystem.out.println(intToString(2)); // twoSystem.out.println(intToString(3)); // otherSystem.out.println(intToString(10)); // other더불어 if/else if/else문 블록 안에서 바로 반환(return)이 가능한 것을 볼 수 있습니다.if 중첩if문 안에 추가적인 if문을 추가할 수 있습니다. 당연히 else if문이나 else문 에도 가능합니다.다만 중첩하는 것은 코드를 읽기 어렵게 만들기 때문에 불가피한 경우가 아니라면 지양하는 것이 좋다고 생각 합니다.public String intToString(int n) { if (n == 0) { return &quot;zero&quot;; } else if (n == 1) { return &quot;one&quot;; } else if (n == 2) { return &quot;two&quot;; } else { if (n &amp;lt; 10) { // n이 0,1,2가 아니면서 10 이하라면... return &quot;less then ten&quot;; } return &quot;other&quot;; }}System.out.println(intToString(0)); // zeroSystem.out.println(intToString(1)); // oneSystem.out.println(intToString(8)); // less then tenswitchswitch문을 사용한다면 어떤 한 조건에 대해서 결과를 다양하게 분기할 수 있습니다.동일한 조건으로 if / else if / else문으로도 표현이 가능하지만 가독성이 더 떨어질 수 있기 때문에switch를 사용하는 것을 고려해볼 수 있습니다.조건으로 사용할 수 있는 타입은 int, short, char, byte, String, enum이 가능하며해당하는 primitive type의 wrapper type도 사용 가능합니다.public String intToString2(int n) { String result = &quot;&quot;; switch (n) { case 0: // n이 0일때 result = &quot;zero&quot;; break; case 1: // n이 1일때 result = &quot;one&quot;; break; case 2: // n이 2일때 result = &quot;two&quot;; break; default: // 기본값 result = &quot;other&quot;; break; } return result;}System.out.println(intToString2(0)); // zeroSystem.out.println(intToString2(1)); // oneSystem.out.println(intToString2(8)); // other위와 같이 사용할 수 있으며 case 구문 마다 break를 걸어주지 않으면 다음 case 식을 실행합니다.default 키워드는 모든 case에 해당하지 않는 기본 값을 의미하며 if문의 else와 유사합니다.또한 case문에서 바로 반환이 가능 합니다.public String intToString3(int n) { String result = &quot;&quot;; switch (n) { case 0: result = &quot;zero&quot;; // break가 없어 통과 case 1: // 결국 0 or 1과 동일함 result = &quot;one&quot;; break; case 2: return &quot;two&quot;; // two 리턴 case 3: case 4: result = &quot;three or four&quot;; break; default: result = &quot;other&quot;; break; } return result;}System.out.println(intToString3(0)); // oneSystem.out.println(intToString3(1)); // oneSystem.out.println(intToString3(3)); // three or four반복문whilewhile문은 자바에서 반복적인 액션을 수해할 수 있게 해주는 기본적인 문장(statement) 이며자바의 다양한 루프(loop) 구조 중 하나 입니다.조건이 거짓일 경우 while문을 건너 뛰며 참일 경우 블록 안의 내용이 실행 되며 거짓이 될때까지 반복합니다.그러한 특징을 살려서 무한 루프를 만들기가 용이 합니다.int count = 0;while (count &amp;lt; 10) { // count가 10보다 작으면 실행 System.out.println(count); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 count++;}while (true) { // 무조건 true 이므로 무한 루프 System.out.println(&quot;this is infinity loop&quot;); // 계속 출력...}do / whiledo/while문은 위의 while문과 유사하지만 문장과 조건식이 반대 입니다.while은 조건 판단 후 문장을 실행하지만 do/while은 무조건 한번 문장을 실행 후 조건을 판단하여 반복 합니다.int count = 0;do { // 무조건 한 번 실행 System.out.println(count); // 0 count++;} while (count &amp;lt; 1); // count가 1이 되어 반복문 종료forfor 문은 일반적인 루프(loop) 패턴이며 while문 이나 do문에 비해 사용하기 편리합니다.그래서 자바에서는 반복적인 작업을 할때는 주로 for문을 사용하게 될 것 입니다.for (&amp;lt;초기값&amp;gt;; &amp;lt;조건&amp;gt;; &amp;lt;증감&amp;gt;) { &amp;lt;문장&amp;gt;}문법은 위와 같으며 간단한 예제로는 아래와 같습니다.for (int i = 0; i &amp;lt; 5; i++) { System.out.println(i); // 0, 1, 2, 3, 4} 초기값 : i는 0 (int i = 0) 조건 : i가 5미만일때 (i &amp;lt; 5) 증감 : i를 1씩 증가 (i++)위 예제에서는 조건으로 사용되는 변수를 i 하나만 사용했지만 2개 이상도 사용 가능합니다.for (int i = 0, j = 5; i &amp;lt; 5; i++, j--) { System.out.println(&quot;(&quot; + i + &quot;,&quot; + j + &quot;)&quot;); // (0,5) (1,4) (2,3) (3,2) (4,1)}foreachforeach문은 우리나라 말로 향상된 for문이라고도 불립니다.for문은 원시 타입(primitive type)을 사용하여 조건을 처리하지만 (counter)foreach문은 배열이나 컬렉션을 사용하고 요소를 하나씩 반복하여 처리할 때 주로 사용 됩니다.int[] nums = new int[]{1, 2, 3, 4, 5};for (int num : nums) { // nums의 요소를 하나씩 num에 대입합니다. System.out.println(num); // 1, 2, 3, 4, 5}다만 foreach를 사용하게 되면 반복자(counter)가 없기 때문에 현재 어느 위치인지 알기가 쉽지 않습니다.foreach를 사용한다면 할 수 없는 작업들은 아래와 같습니다. 배열 또는 컬렉션의 요소를 거꾸로 반복 할 수 없습니다. 반복자를 사용할수 없기 때문에 여러 배열의 동일한 위치의 요소를 가져올 수 없습니다. 컬렉션의 요소를 get() 메소드를 사용하여 가져올 수 없습니다.break만약 while, do/while, for, switch문을 사용할 때 어느 조건에 따라 문장을 종료하고 싶다면 break 키워드를 사용할 수 있습니다.for (int i = 0; i &amp;lt; 5; i++) { if (i == 3) { break; // i가 3이면 for문을 종료 } System.out.println(i); // 0, 1, 2}continuewhile, do/while, for 반목문을 사용할 때 continue를 사용한다면 해당 조건은 넘어가고 다음 조건을 실행 시킬 수 있습니다.for (int i = 0; i &amp;lt; 5; i++) { if (i == 3) { continue; // i가 3이면 다음 조건으로 넘어가기 } System.out.println(i); // 0, 1, 2, 4}" }, { "title": "[Live Study] 3주차 과제: 연산자", "url": "/posts/java-livestudy-3week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, operator", "date": "2020-11-23 19:57:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바가 제공하는 다양한 연산자를 학습하세요.산술 연산자산술 연산자(Arithmetic Operators)는 정수, 부동소수점, 문자열 등 boolean 타입을 제외한모든 Primitive Type에서 사용이 가능합니다.피연산자들 중 부동소수점이 있다면 부동소수점 산술이 되고 그렇지 않다면 정수 산술이 됩니다.정수 산술과 부동소수점 산술이 나누기를 수행하는 방식과언더플로우(underflow)와 오버플로우(overflow)가 처리되는 방식이 다르기 때문에 중요합니다.더하기 (Addition : +)+는 기본적으로 두 수를 더하는 연산이지만 문자열을 연결시키는데도 사용할 수 있습니다.만약 +의 피연산자 중 문자열이 있다면 다른 피연산자도 문자열로 변환됩니다.int num1 = 10;int num2 = 20;int sum = num1 + num2;System.out.println(sum); // 30String str1 = &quot;Hello&quot;;int num3 = 123;String s = str1 + num3;System.out.println(s); // Hello123빼기 (Subtraction : -)-연산자는 첫번째 피연산자에서 두번째 피연산자를 빼는 연산자입니다. (binary operator)하나의 피연산자로만 사용된다면 1차 연산 (unary negation) 으로 사용될 수 있습니다.다만 더하기 연산 처럼 문자열 연산은 불가합니다.int num1 = 10;int num2 = 2;int num3 = num1 - num2;System.out.println(num3); // 8String str1 = &quot;Hello&quot;;int num4 = 10;str1 - num4; // 컴파일 에러곱하기 (Multiplication : *)* 연산자는 두 피연산자를 곱합니다.빼기 연산과 마찬가지로 문자열 연산은 불가합니다.int num1 = 10;int num2 = 2;int num3 = num1 * num2;System.out.println(num3); // 20String str1 = &quot;Hello&quot;;int num4 = 10;str1 * num4; // 컴파일 에러나누기 (Division : /)/ 연산자는 첫번째 피연산자를 두번째 피연산자로 나눕니다.두 피연산자가 모두 정수라면 결과도 정수이며 나머지는 내림으로 없어지고 피연산자 중 부동소수점이 있다면 결과도 부동소수점 입니다.System.out.println(7 / 3); // 2System.out.println(7 / 3.0); // 2.3333333333333335정수를 0으로 나누면 ArithmeticException이 발생 합니다.System.out.println(7 / 0);부동소수점을 0으로 나눈다면 Infinity 혹은 NaN이 결과로 나옵니다.System.out.println(&quot;7 / 0.0 : &quot; + 7 / 0.0);System.out.println(&quot;0 / 0.0 : &quot; + 0 / 0.0);나머지 연산자 (Modulo : %)% 연산자는 첫번째 피연산자를 두번째 피연산자로 나누고 남은 나머지를 정수로 리턴 합니다.리턴된 결과는 첫번째 피연산자의 부호와 동일합니다.일반적으로는 정수 피연산자와 사용되지만 부동소수점에도 사용이 가능하고 결과도 부동소수점으로 리턴 합니다.System.out.println(10 % 4); // 2System.out.println(-10 % 4); // -2 (첫번째 피연산자의 부호와 결과의 부호가 동일)System.out.println(10 % -4); // 2System.out.println(); // 2.1000000000000014정수로 연산할 때 0으로 연산하면 나누기와 마찬가지로 ArithmeticException이 발생 합니다.부동소수점을 연산할 때 0으로 연산한다면 NaN 평가가 됩니다.System.out.println(10 % 0.0); // NaNSystem.out.println(10.0 % 0); // NaNSystem.out.println(10.0 % 0.0); // NaN단항 마이너스 연산 (Unary minus : -)- 연산자를 단항 연산자로 사용하면 값의 부정이 수행 됩니다.int a1 = 1;System.out.println(-a1); // -1int a2 = -1;System.out.println(-a2); // 1비트 연산자비트 연산자(Bitwise Operators) 및 시프트 연산자(Shift Operators)는 개별 비트를 조작하는 저수준(low-level) 연산자 입니다.비트 연산을 이해하기 위해서는 이진수와 음의 정수를 나타내는 데 사용되는 2의 보수를 이해해야 합니다.부동소수점, 부울(bool), 배열, 객체 등을 피연산자로 사용할 수 없습니다.비트 연산자를 공부할 때는 디버거를 활용하여 바이너리(binary) 값을 보면 이해가 빨라집니다.인텔리제이 기준으로는 아래 스크린샷을 참고해주시면 됩니다.Binary를 클릭하세요!비트 보수 (Bitwise complement : ~)~ 연산자는 비트 반전 또는 비트 NOT 연산자라고 합니다.각 비트를 반전시켜 1을 0으로, 0을 1로 변환합니다.int i = ~1;byte b = ~1;위 예제에서 i와 b의 값은 무엇이 들어가 있을까요? 출력을 해보면 둘다 -2가 나옵니다.다만 디버거를 사용하여 바이너리 값으로 보면 아래와 같이 조금 다르게 나오는 것을 볼 수 있습니다.이유는 int는 32bit이고 byte는 8bit이기 때문입니다.AND (&amp;amp;)&amp;amp; 연산자는 두 정수 피연산자를 AND 연산 합니다. (비트곱)int num1 = 10;int num2 = 20;int result1 = num1 &amp;amp; num2; // 0int num3 = 11;int num4 = 15;int result2 = num3 &amp;amp; num4; // 11result1과 result2의 결과가 왜 0과 11일까요?비트곱은 두 피연산자의 해당 비트가 모두 1일때만 1, 아니면 0을 리턴하기 때문입니다.OR (|)| 연산자는 두 정수 피연산자를 OR 연산 합니다. (비트합)int num1 = 10;int num2 = 20;int result1 = num1 | num2; // 30 (0b00011110)int num3 = 11;int num4 = 15;int result2 = num3 | num4; // 15 (0b00001111)AND 연산 예제와 다르게 비트를 합한 결과가 나오게 됩니다.XOR (^)^ 연산자는 두 정수 피연산자를 XOR (exclusive OR) 연산을 합니다.두 피연산자의 해당 비트가 같으면 0, 다르면 1을 리턴합니다.int num1 = 10;int num2 = 20;int result1 = num1 ^ num2; // 30 (0b00011110)int num3 = 11;int num4 = 15;int result2 = num3 ^ num4; // 4 (0b00000100)왼쪽 시프트 연산 (&amp;lt;&amp;lt;)&amp;lt;&amp;lt; 연산자는 비트를 왼쪽으로 두번째 피연산자로 제시된 비트 수 만큼 이동 시킵니다.시프트 될 때 기존의 가장 왼쪽 비트는 삭제되고 가장 오른쪽 비트는 0으로 채워 집니다.int num = 10; // 0b00001010int result = num &amp;lt;&amp;lt; 1; // 0b00010100 (20)int result2 = num &amp;lt;&amp;lt; 2; // 0b00101000 (40)추가적으로 2의 비트 수의 제곱 만큼 곱하는 값이 왼쪽 시프트 연산의 결과가 됩니다.result는 10 * 2 * 1 의 결과와 같고 result2는 10 * 2 * 2의 결과와 같습니다.int z = x &amp;lt;&amp;lt; y; // z = x * (2 * y);오른쪽 시프트 연산 (&amp;gt;&amp;gt;)&amp;gt;&amp;gt; 연산자는 왼쪽 시프트 연산과 반대로 우측으로 두번째 피연산자로 제시된 비트 수 만큼 이동 시킵니다.가장 오른쪽 비트는 삭제되고 기존의 값이 양수인 경우 가장 왼쪽 비트는 0으로 채워지고 음수인 경우는 1이 채워 집니다.int num = 10; // 0b00001010int result = num &amp;gt;&amp;gt; 1; // 0b00000101 (5)int result2 = num &amp;gt;&amp;gt; 2; // 0b00000010 (2)int num2 = -10; // 0b11110110int result3 = num2 &amp;gt;&amp;gt; 1; // 0b11111011 (-5)int result4 = num2 &amp;gt;&amp;gt; 2; // 0b11111101 (-2)왼쪽 시프트는 곱셈이었지만 오른쪽 시프트는 나눗셈이 됩니다.int z = x &amp;gt;&amp;gt; y; // z = x / (2 * y);부호없는(unsigned) 오른쪽 시프트 연산 (&amp;gt;&amp;gt;&amp;gt;)기본적으로는 오른쪽 시프트 연산과 동일하지만 부호에 관계없이 왼쪽 비트는 무조건 0으로만 채워집니다.그렇기 때문에 음수에 &amp;gt;&amp;gt;&amp;gt; 연산을 한다면 결과는 양수가 됩니다.int num = 10;int result = num &amp;gt;&amp;gt;&amp;gt; 1; // 5int result2 = num &amp;gt;&amp;gt;&amp;gt; 2; // 2int num2 = -10; // 0b11111111_11111111_11111111_11110110int result3 = num2 &amp;gt;&amp;gt;&amp;gt; 1; // 0b01111111_11111111_11111111_11111011int result4 = num2 &amp;gt;&amp;gt;&amp;gt; 2; // 0b00111111_11111111_11111111_11111101int는 4 byte 이기 때문에 총 32비트가 채워져 있어 음수를 &amp;gt;&amp;gt;&amp;gt; 연산 했을 경우 꽤 큰 값이 나오게 됩니다.관계 연산자 같거나 같지 않음을 평가하는 비교 연산자(Comparison Operators) 크고 작은 관계를 평가하는 관계 연산자(Relational Operators) boolean 결과를 도출 하므로 조건문(if) 이나 반복문 (for, while) 등에서 결정을 위해 사용Equals (==)== 연산자는 Primitive Type를 비교할 때 두 피연산자의 값이 같다면 true를 그렇지 않다면 false를 리턴 합니다.그러나 String 이나 참조 타입의 피연산자를 비교하면 동일한 객체 인지 여부를 체크합니다.int num1 = 10;int num2 = 10;num1 == num2 // trueint num3 = 12;int num4 = 13;num3 == num4 // false두 피연산자의 타입이 다를 때는 크기가 작은 피연산자 타입이 큰 피연산자의 타입으로 변환되어 비교 됩니다.int i = 10;float f = 10.0f;i == f // true위 예제에서 i는 float 타입으로 변환된 후 비교 됩니다.부동소수점의 NaN의 경우엔 모든 숫자와 같지 않으며NaN 여부를 체크하려면 Float.isNan()이나 Double.isNan()을 사용해야합니다.Not Equals (!=)!= 연산자는 == 연산자와 정반대로 두 피연산자의 값이 다른지 여부를 체크하여 true/false를 리턴 합니다.String 이나 참조 타입일 경우엔 동일한 객체 인지 여부를 체크합니다.int num1 = 10;int num2 = 10;num1 != num2 // falseint num3 = 12;int num4 = 13;num3 != num4 // true작음 (&amp;lt;), 작거나 같음 (&amp;lt;=)첫번째 피연산자가 두번째 피연산자보다 작은지 여부를 평가(Evaluate)하려면 &amp;lt; 연산자를 사용하고같은지 여부까지 평가하려면 &amp;lt;= 연산자를 사용합니다.int num1 = 10;int num2 = 10;num1 &amp;lt;= num2 // trueint num3 = 12;int num4 = 13;num3 &amp;lt; num4 // true큼 (&amp;gt;), 크거나 같음 (&amp;gt;=)위 연산자와 정반대로 첫번째 피연산자가 두번째 피연산자보다 큰지 여부를 평가하기 위해 &amp;gt; 연산자를 사용하고같음 여부도 평가하려면 &amp;gt;= 연산자를 사용합니다.int num1 = 10;int num2 = 10;num1 &amp;gt;= num2 // trueint num3 = 12;int num4 = 13;num3 &amp;gt; num4 // false논리 연산자Boolean Operators 라고도 하며 관계 연산자와 동일하게 true/false 결과를 리턴 합니다.여러 비교 연산을 사용하여 복잡도를 높인 조건식을 만들 때 주로 사용 됩니다.조건부 AND (&amp;amp;&amp;amp;)두 피연산자가 모두 true인지 여부를 평가하며 두 피연산자 중 하나라도 false라면 false를 리턴 합니다.int num1 = 10;int num2 = 10;boolean c1 = num1 &amp;gt;= num2; // trueint num3 = 12;int num4 = 13;boolean c2 = num3 &amp;gt; num4; // falseSystem.out.println(c1 &amp;amp;&amp;amp; c2); // false조건부 OR (||)두 피연산자 중 하나라도 true 라면 true를 리턴 합니다.int num1 = 10;int num2 = 10;boolean c1 = num1 &amp;gt;= num2; // trueint num3 = 12;int num4 = 13;boolean c2 = num3 &amp;gt; num4; // falseSystem.out.println(c1 || c2); // true단락 회로 평가 (Short Circuit Evaluation)&amp;amp;&amp;amp;와 || 연산을 사용할 때 첫 번째 피연산자의 결과에 따라 결과 값이 정해졌을 때 두 번째 피연산자의 평가를 하지 않는 것을 말합니다. &amp;amp;&amp;amp; : 첫 번째 피연산자의 결과가 false 라면 두 번째 피연산자를 평가하지 않고 false 리턴 || : 첫 번째 피연산자의 결과가 true 라면 두 번째 피연산자를 평가하지 않고 true 리턴public boolean isTrue() { System.out.println(&quot;isTrue&quot;); return 10 &amp;gt;= 10;}public boolean isFalse() { System.out.println(&quot;isFalse&quot;); return 12 &amp;gt; 13;}위와 같은 메소드가 있고 &amp;amp;&amp;amp;, || 를 사용하여 비교한다면 피연산자 순서에 따라 출력이 다릅니다.출력 결과는 아래와 같습니다.isTrue() &amp;amp;&amp;amp; isFalse(); // isTrue, isFalseisFalse() &amp;amp;&amp;amp; isTrue(); // isFalseisTrue() || isFalse(); // isTrueisFalse() || isTrue(); // isFalse, isTrue부정 연산자 (!)단항 연산자로써 해당 값의 결과의 반대로 평가 합니다.위 isTrue와 isFalse 메소드를 대상으로 사용해보면 아래와 같습니다.!isTrue() // false!isFalse() // trueAND (&amp;amp;), OR (|), XOR (^)비트 연산에서 사용되었던 연산자들과 동일하지만 boolean 연산을 사용할 때도 이 연산자들을 사용할 수 있습니다.&amp;amp;와 |의 경우 &amp;amp;&amp;amp;와 ||의 결과와 동일하지만 단락 회로 평가가 되지 않습니다.isTrue() &amp;amp; isFalse(); // isTrue, isFalseisFalse() &amp;amp; isTrue(); // isFalse, isTrueisTrue() | isFalse(); // isTrue, isFalseisFalse() | isTrue(); // isFalse, isTrue^ 연산자는 두 피연산자 중 하나만 true라면 true를 리턴 합니다. 이 연산자도 위 두 연산자와 동일하게 단락 회로 평가가 되지 않습니다.isTrue() ^ isFalse(); // trueisFalse() ^ isTrue(); // trueisTrue() ^ isTrue(); // falseisFalse() ^ isFalse(); // falseinstanceof객체(Object) 또는 배열(Array) 값을 어떠한 참조 유형에 맞는 값인지를 평가하는 연산자 입니다.만약 null을 평가한다면 항상 false가 리턴 됩니다.만약 평가 결과가 true라면 비교된 참조 유형으로 안전하게 캐스팅하고 할당할 수 있다는 것을 의미합니다.&quot;sangwoo&quot; instanceof String // truenull instanceof String // falseObject o = new int[]{1, 2, 3};o instanceof int[] // true// safety castingif (obj instanceof MyClass) { MyClass c = (MyClass) obj;}i instanceof int // compile error : Primitive Type은 사용할 수 없습니다. 일반적으로 Java 프로그래머 사이에서 instanceof를 사용하지 않는 것이 좋습니다.종종 의심스러운 설계의 신호일 수 있습니다.정상적인 상황이라면 instanceof의 사용을 피할 수 있지만 필요한 경우도 있긴 합니다.대입 연산자 (Assignment Operator)어떠한 변수에 값을 할당할 때 이 연산자를 사용할 수 있으며 메모리에 값을 저장하거나 할당한다는 의미 입니다.int i = 10;String s = &quot;hello&quot;;위와 같이 i 변수에 10, s 변수에 hello를 할당할 수 있습니다.이 외에 5개의 산술 연산자와 6개의 비트 연산자 및 시프트 연산자와 할당을 결합하는 다른 연산자도 정의 되어 있습니다.int num = 10;// 산술 연산자 결합num += 2; // num = num + 2num -= 3; // num = num - 3num *= 2; // num = num * 2num /= 2; // num = num / 2num %= 3; // num = num % 3// 비트 연산자 결합num &amp;amp;= 2; // num = num &amp;amp; 2num |= 3; // num = num | 3num ^= 4; // num = num ^ 4// 시프트 연산자 결합num &amp;lt;&amp;lt;= 3; // num = num &amp;lt;&amp;lt; 3num &amp;gt;&amp;gt;= 4; // num = num &amp;gt;&amp;gt; 4num &amp;gt;&amp;gt;&amp;gt;= 2; // num = num &amp;gt;&amp;gt;&amp;gt; 2화살표 연산자 (Lamda Expression : -&amp;gt;)Java 8 부터 도입된 연산자로 람다 표현식(Lamda Expression) 이라고 하며 메소드 본문에 해당 실행 가능한 자바 코드의 익명 컬렉션입니다.함수형 프로그래밍 언어에서 주로 사용되던 문법이며 유연성이 좋아 모던 프로그래밍 언어에서도 많이 사용합니다.메소드 파라미터 목록, 연산자, 코드 블럭 순으로 구성 됩니다.코드 블럭이 한 문장으로 끝난다면 중괄호({, })를 생략할 수 있습니다.Runnable r = () -&amp;gt; { System.out.println(&quot;1&quot;); System.out.println(&quot;2&quot;);}// 코드가 한 문장이면 중괄호 생략 가능Runnable r = () -&amp;gt; System.out.println(&quot;1&quot;);3항 연산자 (Conditional Operator : ? :)3항 연산자는 C언어로 부터 차용한 연산자 입니다.if ~ else 문장을 연산자로 표현할 수 있고 조건에 따라 결과를 반환할 수 있습니다.조건 ? true일때 결과 : false 일때 결과public int max(int x, int y) { return x &amp;gt; y ? x : y;}max(3, 2) // 3max(4, 5) // 5public String getDefaultName(String name) { return name != null ? name : &quot;unknown&quot;;}getDefaultName(&quot;sangwoo&quot;) // sangwoogetDefaultName(null) // unknown이미 위 예제의 max 메소드와 비슷한 역할을 하는 기능이 Math 클래스에 정의 되어 있습니다.연산자 우선 순위 우선순위 연산자 연산 방향 동작 1 . -&amp;gt; 객체 멤버 접근   [, ] -&amp;gt; 배열 요소 접근   (args) -&amp;gt; 메소드 호출   data++, data-- -&amp;gt; 후위 증감 2 ++data, --data &amp;lt;- 전위 증감   +, - &amp;lt;- 단항 증감   ~, ! &amp;lt;- 비트 보수, 부정 연산 3 new &amp;lt;- 객체 생성   (type) &amp;lt;- 캐스팅 4 *, /, % -&amp;gt; 곱하기, 나누기, 나머지 5 +, - -&amp;gt; 더하기, 빼기   + -&amp;gt; 문자열 결합 6 &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;gt;&amp;gt;&amp;gt; -&amp;gt; 왼쪽 시프트, 오른쪽 시프트, 부호없는 오른쪽 시프트 7 &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;= -&amp;gt; 작음, 작거나 같음, 큼, 크거나 같음   instanceof -&amp;gt; 타입 비교 8 ==, != -&amp;gt; 같음, 같지 않음 9 &amp;amp; -&amp;gt; AND 10 ^ -&amp;gt; XOR 11 | -&amp;gt; OR 12 &amp;amp;&amp;amp; -&amp;gt; AND 13 || -&amp;gt; OR 14 ? : &amp;lt;- 3항 연산자 15 =, *=, /=, %=, +=, -=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;gt;&amp;gt;&amp;gt;=, &amp;amp;=, ^=, |= &amp;lt;- 대입 연산자 16 -&amp;gt; -&amp;gt; 람다 표현식 Java 13. switch 연산자 yield 키워드를 사용하여 switch표현식을 리턴할 수 있습니다. -&amp;gt;를 사용하여 case 구문 처리가 가능합니다. (label rules)int result;switch (mode) { case &quot;a&quot;: result = 1; break; case &quot;b&quot;: result = 2; break; case &quot;c&quot;, &quot;d&quot;, &quot;e&quot;: result = 3; case &quot;f&quot;, &quot;g&quot;: System.out.println(&quot;this is f or g&quot;); result = 4; break; default: result = -1;}위와 같은 switch 문을 yield를 사용한다면 아래와 같습니다.int result = switch (mode) { case &quot;a&quot;: yield 1; case &quot;b&quot;: yield 2; case &quot;c&quot;, &quot;d&quot;, &quot;e&quot;: yield 3; case &quot;f&quot;, &quot;g&quot;: System.out.println(&quot;this is f or g&quot;); yield 4; default: yield -1;};문법이 간결해지고 result 변수의 변화가 없기 때문에 안전하게 코딩할 수 있습니다.-&amp;gt;를 사용한다면 조금 더 간단하게 변경할 수 있습니다.int result = switch (mode) { case &quot;a&quot; -&amp;gt; 1; case &quot;b&quot; -&amp;gt; 2; case &quot;c&quot;, &quot;d&quot;, &quot;e&quot; -&amp;gt; 3; case &quot;f&quot;, &quot;g&quot; -&amp;gt; { System.out.println(&quot;this is f or g&quot;); yield 4; } default -&amp;gt; -1;};case문 별로 한 문장으로 리턴이 가능하다면 yield까지 생략할 수 있습니다.두 문장 이상이 된다면 중괄호로 처리하고 yield문을 사용해야 합니다." }, { "title": "[Live Study] 2주차 과제: 자바 데이터 타입, 변수 그리고 배열", "url": "/posts/java-livestudy-2week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, type, variable, array", "date": "2020-11-21 22:04:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.프리미티브 타입 종류와 값의 범위 그리고 기본 값 타입 설명 기본값 크기 범위 boolean true 또는 false false 1 bit - char 유니코드 문자 \\u0000 2 byte \\u0000 ~ \\uFFFF byte 부호가 있는 정수 (Signed Integer) 0 1 byte -128 ~ 127 short 부호가 있는 정수 (Signed Integer) 0 2 byte -32768 ~ 32767 int 부호가 있는 정수 (Signed Integer) 0 4 byte –2147483648 ~ 2147483647(-2e31 ~ 2e31-1) long 부호가 있는 정수 (Signed Integer) 0 8 byte –9223372036854775808 ~ 9223372036854775807(-2e63 ~ 2e63-1) float IEEE 754 부동소수점 0.0 4 byte 1.4E–45 ~ 3.4028235E+38 double IEEE 754 부동소수점 0.0 8 byte 4.9E–324 ~ 1.7976931348623157E+308 프리미티브 타입과 레퍼런스 타입프리미티브 타입 (Primitive Type) 기본형 타입이라고 말하며 미리 정의되어 제공됩니다. 기본값이 존재합니다. (null 불가) 스택(Stack) 에 값이 저장됩니다.레퍼런스 타입 (Reference Type) 프리미티브 타입을 제외하면 모두 레퍼런스 타입 입니다. null이 존재합니다. 힙 (Heap) 에 값이 저장됩니다.리터럴어떠한 변수를 선언할 때 변수에 넣는 값을 리터럴(Literal) 이라고 합니다.int a = 1; int는 자료형 a는 변수명 1은 리터럴이 됩니다.정수 리터럴// 10진수 리터럴 : 일반적인 정수 입력을 합니다.int decimal = 101;// 8진수 리터럴 : 앞에 0을 붙이고 한자리 수에 0~7까지의 정수를 허용합니다.int octal = 025;// 16진수 리터럴 : 0x로 시작하며 0~9와 a~f를 허용합니다.int hex = 0x34f;// 바이너리 리터럴 : 0b로 시작하고 0, 1을 허용합니다.int binary = 0b111;부동 소수점 리터럴// double 리터럴double d1 = 123.456;double d2 = 123.456d;double d3 = 0123.456;// float 리터럴float f1 = 123.456f;float f2 = 0123.1222f;문자 리터럴// 문자 1개를 리터럴할 수 있습니다.char ch1 = &#39;a&#39;;// 0 ~ 65535 까지 char형 리터럴이 될 수 있습니다.char ch2 = 62;// 유니코드 리터럴이 가능합니다.char ch3 = &#39;\\u0012&#39;;// 이스케이프 문자도 char형 리터럴이 가능합니다.char ch4 = &#39;\\n&#39;;문자열 리터럴// 쌍따옴표를 사용하여 기본적인 문자열 리터럴이 가능합니다.String s = &quot;Hello Java&quot;;// + 연사자로 문자열을 결합하는 리터럴도 사용할 수 있습니다.String text = &quot;Hello Java\\n&quot; + &quot;Hello String literal&quot; + &quot;Hello Java Study&quot;;불리언(boolean) 리터럴// 참 리터럴boolean b1 = true;// 거짓 리터럴boolean b2 = false;변수 선언 및 초기화 하는 방법// 변수 선언 후 별도로 초기화String a;a = &quot;Hello&quot;;// 변수 선언하면서 초기화String b = &quot;Hello&quot;;// 변수 여러개 선언String c, d;// 변수 여러개 선언 및 초기화String e = &quot;eee&quot;, f = &quot;fff&quot;;변수의 스코프와 라이프타임 설명 스코프 라이프타임   클래스 변수(Class Variable) 클래스 내부나 외부의 모든 블럭에서 정의 되면서 static으로 선언된 변수 클래스 전체 프로그램 종료시 까지 인스턴스 변수(Instance Variable) 클래스 내부에 선언되고 메소드나 블럭에서 선언되지 않는 변수 static 메소드를 제외한 클래스 전체 클래스의 객체가 메모리에 올라가 있는 동안 로컬 변수(Local Variable) 클래스 변수, 인스턴스 변수가 아닌 모든 변수 선언된 블럭 내 변수가 선언된 블럭의 종료시 까지 public class ScopeAndLifetime { static String a; // 클래스 변수 String b; // 인스턴스 변수 void f() { String c; // 로컬 변수 }}타입 변환, 캐스팅 그리고 타입 프로모션타입 캐스팅변수의 타입을 명시적으로 변환하는 방법이고 크기가 더 큰 자료형을 더 작은 자료형으로 대입할 때자료형을 명시하여 강제로 변환하는 방법이기도 합니다.float a = 1f;int b = a; // 컴파일 에러 발생int c = (int) a; // 명시적으로 int로 형변환타입 프로모션변수의 타입을 자동으로 변환하는 방법이고 크기가 더 작은 자료형을 더 큰 자료형으로 대입할 때 발생합니다.int a = 1;float b = a; // 자동 형변환 (타입 프로모션)1차 및 2차 배열 선언하기배열(Array) 이란 동일한 자료형의 데이터를 연속된 공간에 저장하기 위한 선형 자료구조를 말합니다.1차원 배열 선언하기int[] arr1;int arr2[];int[] arr3 = new int[2];int[] arr4 = new int[]{1, 3, 3};int[] arr5 = {1, 2, 3, 4};2차원 배열 선언하기int[][] arr1;int arr2[][];int[][] arr3 = new int[2][3];int[][] arr4 = new int[][]{ {1, 2}, {3, 4} };int[][] arr5 = { {5, 6}, {7, 8}, {9, 10} };타입 추론, var타입 추론(Type Inference) 이란 타입이 정해지지 않은 변수의 타입을 컴파일러가 유추하는 기능을 말합니다.이미 스칼라나 코틀린 등 다른 언어에서는 적극적으로 사용되고 있습니다.자바는 자바10 부터 지원하며 var 키워드를 사용하여 타입 추론이 가능합니다.var a = &quot;String&quot;; // Stringvar b = 11; // intvar c = &#39;a&#39;; // charvar d = 12.34; // doublevar e = 12.34f; // float" }, { "title": "[Live Study] 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가.", "url": "/posts/java-livestudy-1week/", "categories": "Java, Live Study", "tags": "java, livestudy, whiteship, jvm", "date": "2020-11-17 21:18:00 +0900", "snippet": "이 스터디는 백기선님께서 Github와 유튜브로 진행하시는 스터디 입니다.참여하시고 싶으신 분은 아래 링크를 참고해 주세요 :)대부분의 내용은 [O’REILLY] Java in a Nutshell, 7th Edition 에서 참고 하였습니다.(최대한 직접 해석하면서 읽고 있으며 모르는 단어는 번역기로 찾았습니다.)학습 목표자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기JVM이란 무엇인가 JVM은 Java Virtual Machine의 약자로 자바 바이트코드를 실행하기 위한 환경을 제공하는 프로그램입니다. 한 번에 하나의 바이트코드 명령을 실행하는 인터프리터를 실행합니다. 자바 소스코드를 바로 실행할 수는 없으며 바이트코드로 컴파일하여 실행할 수 있습니다. 다양한 플랫폼의 실행 환경을 제공하기 때문에 한 번 작성된 자바 어플리케이션은 JVM이 설치되어 있는 환경이라면 코드의 변경 없이 실행이 가능합니다. Garbage Collector(GC)를 통해 메모리 관리를 해주기 때문에 개발자의 부담을 덜어줍니다. (다만, 튜닝이 필요할 수는 있습니다.)컴파일 하는 방법컴파일을 하기 위해서는 자바 컴파일러가 필요한데 이 컴파일러는 JDK(Java Development Kit)이 필요합니다.JDK가 설치되어 있고 만약 HelloWorld.java 라는 자바 소스 파일이 있다면 아래와 같이 컴파일이 가능합니다.$ javac HelloWorld.java위 명령으로 컴파일을 하면 바이트코드인 HelloWorld.class 이 생성됩니다.실제 바이트코드의 내용을 보려면 아래의 명령어를 입력하면 됩니다.$ javap -c HelloWorld실행하는 방법위 예제로 컴파일하여 생성한 바이트코드를 실행하려면 아래와 같이 입력해주세요.$ java HelloWorld바이트코드란 무엇인가바이트코드는 하드웨어 프로세서에서 실행되는 기계어와 유사하지는 않으며컴퓨터의 CPU에서 동작하는 코드라고 생각할 수 있지만 그렇지 않습니다.자바 프로그램은 JVM에서 실행되기 때문입니다.바이트코드란 JVM 인터프린터가 이해하고 실행할수 있는 형태를 말합니다.JIT 컴파일러란 무엇이며 어떻게 동작하는지JIT(Just-In-Time) 컴파일러는 자바 바이트코드를 프로세서가 이해할 수 있는 기계어로 컴파일하여자바 어플리케이션의 성능을 향상시킬 수 있는 런타임 환경의 구성요소 입니다.플랫폼 초기에는 자바 컴파일러(javac)로 컴파일 할 때 최적화된 바이트코드를 많이 만들어냈지만JIT 컴파일러가 나오면서 중요한 메소드들은 이에 의해 매우 빠른 기계어로 컴파일됩니다.JIT 컴파일러의 작업을 쉽게 하는 것이 바이트코드를 최적화하는 것 보다 더 큰 이득이 있습니다.기본적으로 JVM은 한번의 하나의 바이트코드 명령만을 인터프리터로 실행하기 때문에JIT 컴파일러를 사용하여 미리 플랫폼이 이해할 수 있는 기계어로 컴파일 해놓고 캐싱이 되어마치 처음부터 그 플랫폼에서 컴파일 된 것처럼 보이기 때문에 성능이 향상 될 수 있습니다.출처 : https://www.javatpoint.com/jit-in-javaJVM 구성요소출처 : https://www.alieranotes.com/post/jvm-architecture클래스 로더 (Class Loader)클래스 로더는 클래스 파일을 읽고 메소드 영역(Method Area)에 바이트 코드를 저장합니다.메소드 영역 (Method Area)메소드 영역에는 .class 파일의 클래스 레벨 정보가 있습니다.JVM은 모든 클래스들 중에서 공유되는 하나의 메소드 영역만 제공 합니다.힙 (Heap)힙은 객체가 할당되는 JVM의 메모리 영역입니다. JVM은 각 클래스 파일에 대한 객체를 생성합니다.스택 (Stack)스택은 JVM의 메모리 영역이지만 힙과는 다르게 메소드 파라미터와 같은 임시 변수를 저장하는데 사용합니다.PC (Program Counter) RegisterPC Register는 어떤 명령이 실행되고 어떤 명령이 실행될 것인지 추적을 유지하기 위해 사용 됩니다.명령은 스레드(Thread)에 의해 실행되기 때문에 각 스레드는 별도의 PC Register를 가지고 있습니다.JIT Compiler위의 설명을 읽어주세요~!GC (Garbage Collection)GC는 JVM의 메모리 관리를 위해서 사용 됩니다.새로운 객체들에게 더 많은 메모리를 할당하기 위해 힙에서 참조되지 않는 객체를 파괴 합니다.네이티브 메소드 스택 (Native Method Stack)네이티브 메소드 스택은 JVM의 런타임 데이터 영역에 엑세스하는데 사용이 됩니다.네이티브 메소드 인터페이스 (Native Method Interface)C, C++로 작성된 네이티브 프로그램 코드를 호출하는데 사용 됩니다.네이티브 프로그램은 시스템의 하드웨어나 OS에 고유한 Low-level 언어로 개발된 프로그램 입니다.JDK와 JRE의 차이출처 : https://www.worldofitech.com/java-programming-jvm-jre-jdk/JRE (Java Runtime Environment)JRE는 자바로 개발된 어플리케이션을 실행하기 위한 환경 입니다.JVM과 자바 클래스 라이브러리를 포함하고 있으며 그 외 자바 어플리케이션을 실행하기 위한 세그먼트를 제공합니다.JDK (Java Development Kit)JDK는 자바 어플리케이션을 개발하기 위한 도구를 제공 합니다.JRE를 포함하고 있으며 개발을 위한 컴파일러, 디버거, JavaDoc 등이 포함 됩니다." }, { "title": "[Leaning Scala] Chapter9. 트레이트", "url": "/posts/scala-learning-scala-chapter9-2/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-10-17 10:36:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677트레이트 (trait)트레이트는 다중 상속을 가능하게 하는 스칼라의 유형 중 하나 입니다.다른 클래스 유형과 마찬가지로 트레이트는 하나 이상의 클래스를 확장할 수는 없지만 동시에 여러 트레이트를 확장할 수는 있습니다.트레이트는 직접 인스턴스화가 될 수 없고 클래스 매개변수를 가질 수는 없지만 타입 매개변수를 사용할 수 있어 재사용성이 뛰어납니다.// 트레이트 정의trait Article { def publish()}// 트레이트 구현class MyArticle(title: String, content: String) extends Article { override def publish(): Unit = { println(s&quot;title : $title, content : $content&quot;) }}val article = new MyArticle(&quot;제목&quot;, &quot;내용&quot;)article.publish() // title : 제목, content : 내용위의 예제로 트레이트를 클래스로 확장하는 것을 볼 수 있습니다.하나 이상의 트레이트를 확장할 때엔 with 키워드를 사용할 수 있습니다.// 트레이트 정의trait Article { def publish()}// 두번째 트레이트 정의trait Logger { def log(): Unit = { println(&quot;Log&quot;) }}// 여러 트레이트 확장class MyArticle(title: String, content: String) extends Article with Logger { override def publish(): Unit = { println(s&quot;title : $title, content : $content&quot;) }}val article = new MyArticle(&quot;제목&quot;, &quot;내용&quot;)article.publish() // title : 제목, content : 내용article.log() // Log위의 예제를 보면 스칼라에서 트레이트를 통해서 다중 상속을 지원하는 것 처럼 보입니다.본래 JVM은 하나의 부모 클래스만 확장 할 수 있는데 어떻게 가능한걸까요?실제로는 컴파일러에서 선형화(linearization) 라는 상속된 클래스와 트레이트의 수평적인 리스트를 받아서한 클래스가 다른 클래스를 확장하는 수직적 체인으로 재구성하는 절차로 이를 가능하게 합니다.이는 단일 상속만 지원하는 실행 환경에서 다중 상속을 지원하는 일종의 대처 방안이며JVM이 단일 상속만 지원한다는 사실이 모든 클래스 계층구조가 비결정적이며경쟁 관계의 구성원을 가진 두 트레이트로 혼란을 일으킬 가능성을 배제한다는 점을 보장합니다.선형화를 통해 클래스와 트레이트를 재배치할 때는 가장 낮은 서브클래스부터 가장 높은 클래스까지 오른쪽 부터 왼쪽 순으로 배치합니다.// 코드 작성class D extends A with B with C// 컴파일 후class D extends C extends B extends A아래 예제를 실행시켜 보면 이해하실 수 있습니다.trait A { override def toString: String = &quot;A&quot;}trait B { override def toString: String = s&quot;B-&amp;gt;${super.toString}&quot;}trait C { override def toString: String = s&quot;C-&amp;gt;${super.toString}&quot;}class D extends A with B with C { override def toString: String = s&quot;D-&amp;gt;${super.toString}&quot;}val d = new Dprintln(d.toString) // D-&amp;gt;C-&amp;gt;B-&amp;gt;A선형화의 이점으로 부모 클래스의 행위를 재정의 하고 베이스 클래스에 서브 클래스가 결합될 때부가적인 기능을 추가하는 트레이트를 만들 수 있습니다.// 부모 클래스class A(val data: String) { def print(): Unit = { println(s&quot;A data : $data&quot;) }}// 부모 클래스를 확장한 서브 클래스 1trait B extends A { override def print(): Unit = { println(s&quot;B data : $data&quot;) }}// 부모 클래스를 확장한 서브 클래스 2trait C extends A { override def print(): Unit = { println(s&quot;C data : $data&quot;) }}// 부모 클래스와 서브 클래스 1 확장class D(data: String) extends A(data) with B// 부모 클래스와 서브 클래스 2 확장class E(data: String) extends A(data) with Cnew D(&quot;alan&quot;).print() // B data : alannew E(&quot;alan&quot;).print() // C data : alan위 예제를 통해 부모 클래스에 부가적인 기능을 추가하기 위해 트레이트를 사용하는 것을 볼 수 있고더불어 추상클래스나 자바의 인터페이스와 유사해 보이지만 전혀 다른 것을 알 수 있습니다. 트레이트는 어떻게 선형화가 트레이트들을 확장하는 클래스의 계층구조를 형성하는지를 이해하는 것이 중요합니다.셀프 타입셀프 타입 (self type)을 사용하여 트레이트를 확장할 때 특정 타입이 함께 사용되어야 함을 명시할 수 있습니다.해당 트레이트에 지정된 셀프 타입에서만 함께 사용할 것을 요구하는 제약사항이라고 볼 수 있습니다.// 기본 클래스class BaseProfile(val name: String)// 기본 클래스를 셀프 타입으로 가지는 트레이트trait Printer { // 셀프 타입 지정 self: BaseProfile =&amp;gt; // 셀프 타입인 기본 클래스의 필드를 메소드에서 사용함 def print(): Unit = { println(s&quot;name : ${self.name}&quot;) }}위 예제는 Printer 트레이트가 셀프 타입으로 BaseProfile 클래스를 가지는 것을 볼 수 있으며트레이트에서 셀프 타입의 필드를 사용할 수 있습니다.이 때 특정 클래스에서 Printer 트레이트를 확장할 때 제약이 생겨 BaseProfle을 확장하지 않으면 Printer 트레이트를 확장할 수 없습니다.셀프 타입을 가지는 트레이트를 단독으로 확장했을 때 위와 같은 에러를 발생시킵니다.정상적으로 Printer 트레이트를 확장하기 위해서는 아래 예제와 같이Printer 트레이트의 셀프 타입인 BaseProfile을 확장하여야 합니다.class Profile(name: String) extends BaseProfile(name) with Printerval profile = new Profile(&quot;alan&quot;)profile.print() // name : alan 셀프타입은 트레이트의 제약사항이나 요구사항을 추가할 때 특정 맥락에서만 사용되는 것을 보장하는 안전한 방식입니다.트레이트를 통한 인스턴스화지금까지 트레이트를 확장하는 방식으로 extends 또는 with 키워드를 사용하였습니다.또 다른 방식으로는 어떠한 클래스를 인스턴스화 할 때 트레이트를 추가할 수도 있습니다.class Atrait Bval a = new A with B간단하게 보면 위 예제와 같이 A 클래스를 인스턴스화 할 때 with 키워드를 사용하여 B 트레이트를 추가할 수 있습니다.이 때 주의해야 할 개념은 트레이트의 선형화를 통해 B 트레이트가 A 클래스를 확장했다는 점을 기억해야 합니다.그렇기 때문에 확장의 개념인 extends 가 아니라 사용하는 클래스를 트레이트에 의해 확장된다는 개념으로 with를 사용한다고 이해하면 좋습니다.아래와 같이 트레이트를 사용하여 인스턴스화 한다면 기존 클래스에 새로운 기능을 무한대로 추가할 수 있습니다.class User(name: String) { def prefix = &quot;&quot; override def toString: String = s&quot;$prefix $name&quot;}trait Alan { self: User =&amp;gt; override def prefix: String = &quot;Alan&quot;}trait Sangwoo { self: User =&amp;gt; override def prefix: String = &quot;Sangwoo&quot;}// 트레이트를 이용한 인스턴스화val alan = new User(&quot;Bae&quot;) with Alanval sangwoo = new User(&quot;Bae&quot;) with Sangwooprintln(alan) // Alan Baeprintln(sangwoo) // Sangwoo Bae 서적에서는 이 트레이트의 기능을 의존성 주입 (dependency injection) 의 역할로 사용된다고 서술되어 있지만 기존에 스프링 프레임워크에서 공부했던 의존성 주입과 사용 방법이 머릿 속에 박혀 있어 이 부분을 완벽히 이해하지 못하였습니다. 대략 느낌적으로는 클래스 정의 시점에 존재하지 않던 기능을 인스턴스화 시점에 트레이트를 추가함으로써 해당 트레이트의 기능이 클래스에 주입된다는 것일까 하는 느낌으로 어렴풋이 이해했습니다.이렇게 트레이트에 대해 공부해 봤는데 처음 트레이트를 접할 때는 자바의 추상클래스나 인터페이스와 비교해 생각하려 했으나이 생각이 적절치 않다고 개인적으로 결론을 지었습니다.트레이트는 다른 객체 지향 언어에서 볼 수 없는 (아직 보지 못한?) 특수한 기능 이라고 생각합니다." }, { "title": "[Leaning Scala] Chapter9. Object, 케이스 클래스", "url": "/posts/scala-learning-scala-chapter9-1/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-10-11 16:17:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677Object서적에는 객체로 설명되어 있으나 클래스를 통햇 생성되는 객체(instance)와 혼동될 여지가 있어 영어인 Object로 명시 하겠습니다.Object는 하나 이상의 인스턴스를 가질 수 없는 형태의 클래스이며 객체지향적으로 싱글턴(singleton)이라고 합니다.자바 등 다른 객체지향 언어에서는 정적(static)이거나 전역(global)로 선언할 수 있으며 코틀린의 object와는 비슷합니다.Object는 따로 인스턴스화를 하지 않더라도 필드나 메소드에 접근이 가능한 구조입니다.정확하게는 최초로 접근할 때 자동으로 인스턴스화 합니다.object Hello { println(&quot;Hello Object&quot;) def hi() = &quot;Hi Object&quot;}println(Hello.hi())// Hello Object// Hi Objectprintln(Hello.hi())// Hi Object위와 같이 object 키워드를 사용하여 정의하고 별도로 인스턴스를 생성하지 않고 바로 메소드를 사용할 수 있습니다.더불어 최초 사용 시 자동으로 전역 인스턴스화가 되기 대문에 두번째 hi() 메소드 실행 시에는이미 생성된 전역 인스턴스를 사용함으로써 Hello Object가 출력되지 않는 것을 볼 수 있습니다.Object는 순수 함수에 가장 잘 어울리며 저자가 좋아하는 Object의 용도입니다.순수 함수는 주어진 매개 변수로만 계산하여 결과값을 반환하는 함수이며 참조에 투명한 함수 입니다.그 외의 특징은 예전 스칼라의 함수에 대해 공부할 때 작성했던 포스팅에서 확인해보실 수 있습니다.object Calculator { def plus(a: Int, b: Int): Int = { a + b } def minus(a: Int, b: Int): Int = { a - b }}println(Calculator.plus(10, 20)) // 30println(Calculator.minus(20, 10)) // 10이렇게 클래스와 상관없는 유틸리티성의 순수 함수들을 Object에 정의해놓고 사용한다면클래스의 비즈니스 로직과 분리할 수 있고 어느 곳에서도 재사용이 가능한 메소드가 됩니다.동반 객체동반 객체 (Companion Object)는 어떠한 클래스와 동일한 이름을 가진 Object를 말합니다.자바에는 존재하지 않지만 코틀린에서는 companion object 키워드를 사용하여 정의할 수 있습니다.동일한 이름을 가져 서로 동반 관계에 있는 클래스와 Object는 서로간의 private, protected 필드와 메소드에 접근할 수 있습니다.class User { def print() = s&quot;name : ${User.name}, email : ${User.email}&quot;}object User { private val name = &quot;alan&quot; private val email = &quot;alan@gmail.com&quot;}val user = new Userprintln(user.print()) // name : alan, email : alan@gmail.com객체지향 프로그래밍에서 많이 사용되는 팩토리(factory) 패턴을 구현하는데도 동반 객체를 사용할 수 있습니다.이 전에 공부했던 클래스의 apply 메소드를 기억하시나요?apply 메소드를 동반 객체에 적용함으로써 팩토리 패턴을 구현할 수 있습니다.class User(name: String, email: String) { def printUser(): Unit = { println(s&quot;name : $name, email : $email&quot;) }}object User { def apply(name: String, email: String): User = new User(name, email)}val user = User(&quot;alan&quot;, &quot;alan@gmail.com&quot;)println(user.printUser()) // name : alan, email : alan@gmail.com객체를 가지는 명령줄 어플리케이션자바 등 언어와 마찬가지로 스칼라도 명령줄 어플리케이션을 생성할 수 있습니다.자바와 다른 점은 클래스가 아니라 object에 생성하지만 같은 점은 main 메소드를 사용한다는 것입니다.사실 자바에서는 클래스에 main 메소드를 static으로 생성하기 때문에 거의 동일하다고 할 수 있습니다.object MyApp { def main(args: Array[String]): Unit = { println(&quot;MyApp Start&quot;) }}케이스 클래스 (case class)케이스 클래스는 자동으로 생성된 몇 가지 메소드를 포함한 클래스이며앞서 공부한 동반 객체도 생성되며 그 동반 객체도 자동으로 생성된 메소드가 있습니다.케이스 클래스에 정의된 필드들에 기반으로 메소드를 생성합니다.// 케이스 클래스 정의case class Article(title: String, content: String, createdAt: LocalDateTime)// 동반객체의 apply 메소드를 자동 생성 (Article.apply())val article = Article(title = &quot;제목&quot;, content = &quot;내용&quot;, createdAt = LocalDateTime.now())// 클래스의 toString 자동 생성println(article.toString) // Article(제목,내용,2020-10-16T18:05:42.191)// 사본을 반환하는 copy 메소드 자동 생성val copiedArticle = article.copy()// 모든 필드를 비교하는 equals 자동 생성println(article == copiedArticle) // true// 모든 필드들의 해시코드 반환println(article.hashCode()) // 480956799 (랜덤)val copiedArticle2 = article.copy(content = &quot;내용2&quot;)println(article == copiedArticle2) // false위 예제를 통해 케이스 클래스를 정의하면 자동으로 생성된 메소드들을 확인할 수 있습니다.코틀린의 data class와 비슷한 기능이라고 볼 수 있습니다." }, { "title": "[Learning Scala] Chapter8. 클래스", "url": "/posts/scala-learning-scala-chapter8/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-23 10:53:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677이전 포스팅까지는 스칼라의 핵심적인 기능과 사용 방법에 대해 알아봤고 이제 스칼라로 객체지향 개발을 하도록 제공되는 기능들을 알아보려고 합니다.먼저 가장 기본적인 클래스에 대해 알아보겠습니다. 다만 이번 포스팅은 기존에 자바 등 객체지향 언어에서 클래스를 사용해본 경험이 있다는 전제 하에 설명하려 합니다.서적에는 스칼라의 클래스에 대한 다양한 내용이 있지만 기본적인 사용법과 자바 클래스와의 차이점 위주로 설명드리겠습니다.스칼라의 클래스에서도 다른 객체지향 언어의 클래스에서 제공되는 상속(inheritance), 다형성(polymorphism),캡슐화(encapsulation)을 지원합니다.기본 사용법아래 예제는 간단하므로 쉽게 이해하실거라고 생각합니다.// 클래스 정의class Member { val name: String = &quot;alan&quot; def greet(): String = s&quot;Hello, $name&quot;}object Runner extends App { val member = new Member // 객체 생성 println(member.greet()) // Hello, alan println(member) // Member@77f03bb1}스칼라의 클래스는 자바와 같이 java.lang.Object를 상속하는 클래스이며 스칼라의 루트 타입인 Any와 동등합니다.그렇기 때문에 두번째 출력문인 Member@77f03bb1 이 데이터는 toString() 메소드를 사용하여 출력되었으며이를 오버라이딩(override) 할 수 있습니다.class Member { val name: String = &quot;alan&quot; def greet(): String = s&quot;Hello, $name&quot; override def toString = s&quot;Member($name)&quot;}object Runner extends App { val member = new Member println(member.greet()) // Hello, alan println(member) // Member(alan)}생성자생성자는 자바보다는 조금 간단하며 코틀린과 비슷합니다.클래스에 매개변수로 기본 생성자를 지정할 수 있고 추가적인 생성자를 만드는 방법도 존재합니다.그리고 메소드 매개변수와 마찬가지로 기본값을 정의할 수 있습니다.class Member(val firstName: String, val lastName: String, val gender: String = &quot;M&quot;) { // 기본 생성자 // 추가 생성자 def this(firstName: String, lastName: String) = { this(firstName, lastName, &quot;M&quot;) } override def toString = s&quot;Member($firstName, $lastName, $gender)&quot;}val m1 = new Member(&quot;alan&quot;, &quot;bae&quot;) // 기본생성자 사용val m2 = new Member(&quot;sangwoo&quot;, &quot;bae&quot;) // 추가 생성자 사용println(m1) // Member(alan, bae, M)println(m2) // Member(sangwoo, bae, M)상속상속도 자바와 동일한 문법으로 가능하고 당연히 자식 크래스의 객체에서 부모 클래스의 메소드 호출이 가능합니다.또한 isInstanceOf 메소드를 사용하여 객체의 타입을 체크할 수 있습니다.class Member(val memberType: String, val firstName: String, val lastName: String) { def print(): Unit = { println(this) } override def toString = s&quot;Member($memberType, $firstName, $lastName)&quot;}class OldMember(firstName: String, lastName: String) extends Member(&quot;OLD&quot;, firstName, lastName)val oldMember = new OldMember(&quot;alan&quot;, &quot;bae&quot;)// 부모 클래스의 메소드 실행oldMember.print() // Member(OLD, alan, bae)println(oldMember.isInstanceOf[Member]) // trueprintln(oldMember.isInstanceOf[OldMember]) // true제네릭제네릭한 타입을 매개변수도 정의할 수 있습니다.class MyData[T](element: T) { def printType(): Unit = { println(element.getClass.getTypeName) }}val myData1 = new MyData[String](&quot;String&quot;)myData1.printType() // java.lang.String// 타입 매개변수 생략 가능val myData2 = new MyData(1)myData2.printType() // java.lang.Integer제네릭 타입의 경계 (bounds)를 지정할 수도 있습니다.저 복잡하게 사용할 수도 있지만 간단하게는 아래 예제로 구분할 수 있습니다.class Aclass B extends A// &amp;lt;: 와 &amp;gt;: 사용의 차이를 아래 인스턴스 새성 구문에서 확인해보세요!class C[T &amp;lt;: A]class D[T &amp;gt;: A]class E[T &amp;lt;: B]class F[T &amp;gt;: B]// 주석은 컴파일 결과 입니다.new C[A] // oknew C[B] // oknew D[A] // oknew D[B] // type arguments [Runner.B] do not conform to class D&#39;s type parameter bounds [T &amp;gt;: Runner.A]new E[A] // type arguments [Runner.A] do not conform to class E&#39;s type parameter bounds [T &amp;lt;: Runner.B]new E[B] // oknew F[A] // oknew F[B] // ok추상 클래스스스로는 인스턴스화를 할 수 없지만 다른 클래스에 의해 확장하여 사용할 수 있는 추상클래스도 정의할 수 있습니다.필드와 메소드 모두 구현되지 않은 상태로 정의할 수 있습니다.abstract class Profile { var name: String var email: String def makePrintData(): String def print(): Unit = { println(makePrintData()) }}class MyProfile extends Profile { override var name: String = &quot;alan&quot; override var email: String = &quot;alan@gmail.com&quot; override def makePrintData(): String = { s&quot;$name : $email&quot; }}val myProfile = new MyProfilemyProfile.print() // alan : alan@gmail.com익명 클래스앞서 추상 클래스를 재사용이 가능하도록 상속한 자식 클래스를 정의하는 방법을 알아봤습니다.이번엔 일회성이며 이름이 없는 익명 클래스를 알아보겠습니다.부모 클래스를 확장하는 객체를 가지지만 일회성으로 값이나 변수에 할당할 수 있습니다.혹은 해당 추상 클래스의 구현해야할 메소드가 한개이며 해당 타입을 파라미터로 받는 메소드가 있다면 람다식으로도 정의할 수 있습니다.// 추상클래스abstract class TalkListener { def receive(): Unit}class Talk { private val listeners = collection.mutable.Buffer.empty[TalkListener] // 추상클래스를 받는 메소드 def addListener(listener: TalkListener): Unit = { listeners += listener } def listen(): Unit = { listeners.foreach(_.receive()) }}val talk = new Talk// 익명 클래스를 값에 할당val listener = new TalkListener { override def receive(): Unit = { println(&quot;first listener&quot;) }}talk.addListener(listener)// 구현해야할 메소드가 한개라면 람다식으로 정의할 수 있습니다.talk.addListener(() =&amp;gt; { println(&quot;second listener&quot;)})talk.listen()// 출력:// first listener// second listener메소드 오버로딩자바와 마찬가지로 메소드 오버로딩(overload) 이 가능합니다.class A { def print(s: String): Unit = println(s&quot;This is String : $s&quot;) def print(i: Int): Unit = println(s&quot;This is Integer : $i&quot;)}val a = new Aa.print(&quot;alan&quot;) // This is String : alana.print(100) // This is Integer : 100Apply 메소드스칼라 클래스의 특징인 apply 메소드는 메소드 이름 없이 호출 될 수 있는 메소드 입니다.이미 사용해보았는데 List를 선언할 때 apply 메소드가 사용됩니다.// 이 두가지는 동일합니다.val list = List(1, 2, 3)val list2 = List.apply(1, 2, 3)간단하게 아래처럼 구현해볼 수 있습니다.class Multiplier(num: Int) { def apply(num2: Int): Int = num * num2}val number = new Multiplier(2)number(10) // 20, 내부적으로 apply 메소드 호출지연값 (Lazy Value)lazy val 키워드를 사용하여 지연된 값을 사용할 수 있습니다.값을 정의할 때 블록으로 표현식(expression) 을 사용할 수 있고 이는 해당 값이 최초 호출 될 때 한 번 실행되어결과를 값에 할당하고 이후에 값을 호출하더라도 이미 계산된 값을 반환합니다.class MyData { val firstNum = 10 val secondNum = 2 // 지연값 정의 lazy val resultNum: Int = { val result = firstNum * secondNum println(s&quot;resultNum : $result&quot;) result }}// 객체 생성val myData = new MyDataprintln(myData.resultNum)// resultNum : 20// 20println(myData.resultNum)// 20프라이버시 접근 변경자스칼라에도 자바와 같은 언어와 같이 값, 변수, 메소드 등의 프라이버시 제어를 할 수 있습니다. public : 붙이지 않았을 때 와 동일. 공개되어 있어 어디서든 사용 가능하며 오버라이딩 가능. protected : 동일 클래스나 서브 클래스에서 사용 가능하며 오버라이딩 불가. private : 동일 클래스에서만 사용 가능.추가적으로 프라이버시 접근 변경자(access modifier) 라는 것을 사용하여 제어의 수준을 추가할 수 있습니다.예를 들어 어떤 키워드(값, 변수, 메소드, 클래스 등) 에 private을 지정할 때 패키지명을 추가하여해당 키워드의 접근 가능한 패키지 레벨을 지정할 수 있습니다.package dev.blog // 패키지 지정class Blog { private val title = &quot;blog title&quot; // Blog 클래스에서만 접근 가능 private[dev] val author = &quot;blog author&quot; // dev 패키지에서도 접근 가능 // Blog 클래스에서만 접근 가능 private def getTitle(): String = { title } // dev 패키지에서도 접근 가능 private[dev] def getAuthor(): String = { author }} title, getTitle()은 private 이기 때문에 다른 클래스에서 사용할 수 없습니다.author, getAuthor()는 dev 패키지 까지 사용 가능 합니다.위 Blog 클래스를 아래와 같이 사용할 수 있습니다.package devimport dev.blog.Blogobject DevApp extends App { val blog = new Blog blog.title // value title in class Blog cannot be accessed as a member of dev.blog.Blog from object DevApp in package dev blog.author // 사용 가능 blog.getTitle() // method getTitle in class Blog cannot be accessed as a member of dev.blog.Blog from object DevApp in package dev blog.getAuthor() // 사용 가능}이상으로 스칼라의 클래스에 대해 공부 하였습니다.책에는 더 많은 내용이 있지만 개인적으로 자바를 경험해봤기 때문에 자바와의 차이점 위주로 작성하였습니다.다음 포스팅에서는 클래스를 통해 생성하는 객체와 스칼라만의 구성 요소인 케이스 클래스, 트레이트에 대해 알아보겠습니다." }, { "title": "[Learning Scala] Chapter7. 그 외의 컬렉션 (모나딕 컬렉션)", "url": "/posts/scala-learning-scala-chapter7-2/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-16 10:16:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677모나딕 컬렉션(monadic collection) 이란 Iterable 연산과 비슷한 변형 연산은 지원하지만하나 이상의 요소를 포함할 수 없는 컬렉션을 말합니다.Option 컬렉션크기가 1인 컬렉션이며 값의 존재 여부를 나타내며 null의 안전한 처리를 하는데 사용되는 경우가 많습니다.또한 자바의 Optional과 비슷하다고 볼 수 있습니다.하나의 값에 대한 여러 연산 체인이 있을 때 이 연산들을 안전하게 처리하는데 좋은 방법이 될 수 있습니다.val name = Option(&quot;alan&quot;)name match { case Some(n) =&amp;gt; println(s&quot;name : $n&quot;) // name : alan case None =&amp;gt; println(&quot;name is null&quot;)}위 예제와 같이 Some과 None 타입으로 값의 존재를 구분할 수 있습니다.혹은 아래와 같이 isDefined, isEmpty를 사용하여 판단할 수도 있습니다.val name = Option(&quot;alan&quot;)if (name.isDefined) { println(s&quot;name is defined : $name&quot;) // name is defined : Some(alan)} else { println(&quot;name is empty&quot;)}일반적인 컬렉션에서도 요소를 추출할 때 안정성을 위해 Option을 리턴하는 메소드들이 있습니다.val words = List(&quot;alan&quot;, &quot;bae&quot;, &quot;sangwoo&quot;)println(words.headOption) // Some(alan)println(words.find(_.endsWith(&quot;song&quot;))) // NoneOption에서 값을 꺼낼 때 다양한 방법이 있지만 get() 메소드를 사용하는 것은 좋지 않습니다.만약 해당 옵션이 None인스턴스였을때 아래와 같은 런타임 익셉션이 발생하므로 안전하지 않습니다.Option의 get() 메소드는 안전하지 않습니다!안전하게 Option의 값을 꺼내는 방법은 아래 예제와 같이 몇가지가 있습니다.val mySome = Option(&quot;alan&quot;)val myNone = Option(null)// None일 경우 기본값 sangwoo 리턴mySome.getOrElse(&quot;sangwoo&quot;) // alanmyNone.getOrElse(&quot;sangwoo&quot;) // sangwoo// None일 경우 sangwoo 리턴, Some일 경우 고차함수 실행// foldRight, foldLeft, recudeXXX 등도 사용할 수 있습니다.mySome.fold(&quot;sangwoo&quot;)(x =&amp;gt; s&quot;$x.bae&quot;) // alan.baemyNone.fold(&quot;sangwoo&quot;)(x =&amp;gt; s&quot;$x.bae&quot;) // sangwoo// None일 경우 주어진 파라미터의 Option을 리턴mySome orElse Option(&quot;sangwoo&quot;) // Some(alan)myNone orElse Option(&quot;sangwoo&quot;) // Some(sangwoo)// 매치표현식으로도 표현할 수 있습니다.mySome match { case Some(m) =&amp;gt; println(s&quot;This is Some $m&quot;) // This is Some alan case None =&amp;gt; println(&quot;This is None&quot;)}Try 컬렉션기존의 자바 등에서 에러 처리를 위해 try... catch... 블록을 주로 사용하지만util.Try 컬렉션을 사용하면 스칼라만의 방식으로 에러를 처리할 수 있습니다.저자의 간단한 설명을 그대로 적자면 아래와 같습니다. 스칼라는 try.. catch... 블록을 지원하며, 이 경우 catch 블록에는 발생한 에러를 매칭하기 위한 일련의 case문을 포함하고 있다.하지만 나는 util.Try만 사용할 것을 추천하는데, 이는 에러를 처리하기에 더 안전하고, 더 표현력 있으며, 완전한 모나딕 접근법을 제공하기 때문이다.Try를 구현한 두 개의 서브 타입이 있으며 표현식의 반환 값을 포함한 Success와 발생한 익셉션을 포함한 Failure가 있습니다.아래 예제를 보시면 이해가 되실 것 같아요!val emptyList = List()val list = List(&quot;alan&quot;)Try { emptyList.head } // Failure(java.util.NoSuchElementException: head of empty list)Try { list.head } // Success(alan)위 예제에서 나온 리턴 값을 가지고 에러를 처리하는 여러가지 방법을 알아보겠습니다.def divide(a: Int, b: Int) = a / b// 매치표현식을 사용할 수 있습니다.Try { divide(10, 0) } match { case Success(value) =&amp;gt; println(s&quot;success : $value&quot;) case Failure(exception) =&amp;gt; println(s&quot;exception : ${exception.getMessage}&quot;) // exception : / by zero}// map : Success인 경우 새로운 값에 내장된 값을 매핑하는 함수를 호출함Try { divide(10, 2) }.map { divide(_, 2) } // Success(2)// flatMap : Success인 경우 Try를 반환하는 함수를 호출함 (위 map과 아래 결과물은 동일합니다. 문법적인 차이점을 찾아보세요!)Try { divide(10, 2) }.flatMap { result =&amp;gt; Try { divide(result, 2) } } // Success(2)// toOption : Option으로 전환하고 Success일 경우 결과를 Some에 넣어서 반환// Success -&amp;gt; SomeTry { divide(10, 2) }.toOption // Some(5)// Failure -&amp;gt; NoneTry { divide(10, 0) }.toOption // None// Success에 내장된 값을 가져오거나 Falure일 경우 ERROR를 리턴Try { divide(10, 2) }.getOrElse(&quot;ERROR&quot;) // 5Try { divide(10, 0) }.getOrElse(&quot;ERROR&quot;) // ERRORFuture 컬렉션Future 컬렉션은 이름에서 유추할 수 있듯 백그라운드 작업을 개시하는 컬렉션 입니다.기본적으로 스칼라 코드는 JVM의 메인 스레드에서 동작하지만 Future를 함수로 호출하면별도의 스레드에서 함수를 실행하여 백그라운드 작업이 가능하게 합니다.주의해야할 점은 백그라운드 작업이 진행 중일 수 있기 때문에 Future의 값을 즉시 사용하지 못할 수 있다는 것과함수를 동시에 실행하기 위한 context를 지정해야한다는 점 입니다.기본 사용법import scala.concurrent.ExecutionContext.global // 컨텍스트 importimport scala.concurrent.Futureobject ScalaFuture extends App { println(&quot;1&quot;) Future { println(&quot;2&quot;) }(global) // 컨텍스트 지정 println(&quot;3&quot;)}위 예제를 실행하면 실행 순서가 어떻게 될까요?퓨처는 백그라운드에서 실행되기 때문에 1 -&amp;gt; 3 -&amp;gt; 2 순으로 출력되는 것을 보실 수 있습니다.또한 위 예제처럼 명시적으로 context 를 지정할 수도 있지만 묵시적 으로도 지정이 가능합니다.import scala.concurrent.ExecutionContext.Implicits.global // 묵시적 context 지정 (Implicit)import scala.concurrent.Futureobject ScalaFuture extends App { println(&quot;1&quot;) Future { println(&quot;2&quot;) } // 묵시적으로 context가 지정되어 파라미터가 생략됨 println(&quot;3&quot;)} 서적 기준으로 묵시적 이라고 표현했지만 암묵적, 암시적 등으로도 표현됩니다.비동기식으로 퓨처 처리하기위 예제들이 기본적으로 비동기적으로 퓨처를 실행하는 방법입니다.추가적으로 퓨처의 반환값이나 예외를 포함한 Try 객체를 받아서 처리를 하거나 콜백 함수를 실행하여 처리할 수도 있습니다.아래 표는 비동기식 퓨처를 처리하기 위한 연산입니다. 이름 예제 설명 fallbackTo nextFtr(1) fallbackTo nextFtr(2) 두번째 퓨처를 첫번째에 연결하고 새로운 종합적인 퓨처를 반환함.첫번째 퓨처가 성공적이지 않다면 두번째 퓨처가 호출됨. flatMap nextFtr(1).flatMap(int =&amp;gt; nextFtr()) 두번째 퓨처를 첫번째 퓨처에 연결하고 새로운 종합적인 퓨처를 반환함.첫번째가 성공적이라면 그 반환값이 두번째를 호출하는데 사용됨. map nextFtr(1) map (_ * 2) 주어진 함수를 퓨처에 연결하고 새로운 종합저긴 퓨처를 반환함.퓨처가 성공적이라면 그 반환값이 해당 함수를 호출할 때 사용됨. onComplete nextFtr() onComplete { _ getOrElse 0 } 퓨처의 작업이 완료된 후 주어진 함수가 값 또는 예외를 포함한util.Try를 이용하여 호출함 onFailure nextFtr() onFailure { case _ =&amp;gt; &quot;error!&quot; } 퓨처의 작업이 예외를 발생시키면 주어진 함수는 그 예외를 가지고 호출됨 Future.sequence Future sequence List(nextFtr(1), nextFtr(5)) 주어진 시퀀스에서 퓨처를 병행으로 실행하여 새로운 퓨처를 반환함.시퀀스 내의 모든 퓨처가 성공하면 이들의 리스트가 반환됨. 그렇지 않으면 그 시퀀스 내에서 처음으로 발생한 예외가 반환됨. 다양한 연산이 존재하지만 간단히 flatMap과 map의 차이를 알아보겠습니다.이 둘은 퓨처가 중첩으로 있을때 차이가 있습니다.flatMap은 이름 처럼 평평하게 map을 한다고 생각하면 됩니다.이론적으로보단 직접 코드를 작성해보시면 실제로 실행되는 프로세스는 동일하지만 결과값이 다른 것을 알 수 있습니다.// future 안에 future가 있기 때문에 결과 값은 Future[Future(..)]val f3: Future[Future[Unit]] = f1().map(_ =&amp;gt; f2())// future 안에 future가 있지만 하나의 종합적인 future로 반환됨 val f4: Future[Unit] = f1().flatMap(_ =&amp;gt; f2())위 표에 작성되어 있지는 않지만 개인적으로 유용해보이는 연산인 isCompleted를 소개해드립니다.val f = Future { println(&quot;f&quot;)}while (!f.isCompleted) { println(&quot;wait......&quot;)}위 프로그램을 실행시키면 Future가 완료될 때 까지 wait...... 가 여러번 출력되는 것을 알 수 있습니다.이 외 표에 작성되어 있는 연산들을 직접 작성하고 확인해보시면 좋습니다. :)동기식으로 퓨처 처리하기동기식으로 퓨처를 처리하게 되면 백그라운드 스레드가 완료될 때 까지 스레드를 차단하기 때문에자원 소모가 더 클 수 있기 때문에 트래픽이 많다면 비동기적으로 처리하는 것이 좋습니다.단, 스레드를 차단하고 백그라운 작업이 성공적이든 아니든 완료되길 기다려야할 때 사용할 수 있습니다.추가적으로 동기적으로 퓨처를 처리하기 위해서는 Duration을 지정해야하고그 기간 내에 완료되지 않았을 때 java.util.concurrent.TimeoutException이 발생한다는 점을 숙지해야합니다.import scala.concurrent.ExecutionContext.Implicits.globalimport scala.concurrent.duration.{Duration, SECONDS}import scala.concurrent.{Await, Future}object ScalaFuture extends App { def f() = Future { println(&quot;1&quot;) } val duration = Duration(10, SECONDS) Await.result(f(), duration) println(&quot;2&quot;)}위 예제는 이전 비동식 예제와 다르게 1 -&amp;gt; 2 순서대로 정확하게 동작하는 것을 볼 수 있습니다.단 duration 값으로 지정된 기간 안에 퓨처가 완료되지 않는다면 예외를 발생시킵니다.이상으로 다양한 컬렉션에 대해 알아봤습니다.스칼라에서 모나딕 컬렉션은 함수형 프로그래밍을 하는데 핵심적인 역할을 한다고 생각하기 때문에 잘 학습해야할 것 같습니다.더불어 컬렉션 타입 별 동일한 네이밍의 연산들이 존재하는데 (map, flatMap 등) 처리되는 방식은컬렉션에 따라 조금씩 다르기 때문에 헷갈리지 말아야할 것 같습니다.다음 포스팅부터는 객체지향 스칼라에 대해 공부해 보겠습니다.감사합니다." }, { "title": "[Learning Scala] Chapter7. 그 외의 컬렉션 (가변, 배열, 시퀀스)", "url": "/posts/scala-learning-scala-chapter7-1/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-15 21:05:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677이전 포스팅에서 보편적인 컬렉션인 List, Set, Map에 대해 알아봤습니다.이 세 컬렉션은 모두 불변의 타입이며 List는 순서가 있는 컬렉션이고 Set과 Map은 순서가 없는 컬렉션 입니다.위 세 컬렉션을 제외한 다른 컬렉션에 대해 알아보겠습니다.가변적인 컬렉션불변의 타입을 가진 컬렉션은 요소를 추가, 변경, 삭제가 불가능하지만 가변적인 컬렉션을 사용하여 처리할 수 있습니다.불변 타입의 컬렉션과 대응되는 가변 컬렉션은 아래와 같습니다. 불변의 타입 가변적인 대응 타입 collection.immutable.List collection.mutable.Buffer collection.immutable.Set collection.mutable.Set collection.immutable.Map collection.mutable.Map 새로운 가변 컬렉션 생성하기가변 컬렉션을 생성할때는 풀패키지명을 포함해서 생성해야하며 필요시에 다시 불변의 리스트로 전환할 수 있습니다.val mutableList = collection.mutable.Buffer(&quot;a&quot;)mutableList.addOne(&quot;b&quot;)mutableList.append(&quot;c&quot;) // 내부적으로는 addOne 호출mutableList += &quot;d&quot; // 내부적으로는 addOne 호출println(mutableList) // ArrayBuffer(a, b, c, d)val immutableList = mutableList.toList // 불변의 List로 변환println(immutableList) // remove불변의 컬렉션으로부터 가변적인 컬렉션 만들기위 예제에서 본 가변 컬렉션 -&amp;gt; 불변 컬렉션 이 아니라 불변 컬렉션 -&amp;gt; 가변 컬렉션 으로 변환도 가능합니다.val map = Map(&quot;alan&quot; -&amp;gt; 1130, &quot;song&quot; -&amp;gt; 1021) // Map 선언val mutableList = map.toBuffer // Map -&amp;gt; Bufferprintln(mutableList) // ArrayBuffer((alan,1130), (song,1021))mutableList trimStart 1 // 가변의 컬렉션이므로 수정 가능println(mutableList) // ArrayBuffer((song,1021))mutableList += (&quot;bae&quot; -&amp;gt; 1) // 가변의 컬렉션이므로 수정 가능println(mutableList) // ArrayBuffer((song,1021), (bae,1))val map2 = mutableList.toMap // Buffer -&amp;gt; Mapprintln(map) // Map(alan -&amp;gt; 1130, song -&amp;gt; 1021)List와 Set은 비슷하지만 Set은 모든 요소가 유일하므로 중복되는 요소는 삭제됩니다.val list = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)val buffer = list.toBuffer // List -&amp;gt; Bufferbuffer += &quot;a&quot; // 요소 추가println(buffer) // ArrayBuffer(a, b, c, a)val set = buffer.toSet // buffer -&amp;gt; Set (중복요소 삭제됨)println(set) // Set(a, b, c)컬렉션 빌더 사용하기Builder를 사용하면 추가(append) 연산만 가능하게 됩니다. 필요한 요소를 추가한 후result() 메소드를 호출하면 이를 최종 컬렉션 타입으로 반환해 줍니다.val setBuilder = collection.mutable.Set.newBuilder[String]setBuilder.addOne(&quot;a&quot;)setBuilder += &quot;b&quot;setBuilder ++= List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) // List 추가. 내부적으로 addAll 호출 println(setBuilder) // scala.collection.mutable.HashSet$$anon$4@2aaf7cc2val mutableSet = setBuilder.result()println(mutableSet) // HashSet(a, b, c, d, e)배열Array는 고정된 크기를 가지며, 내용 변경이 가능하고, 인덱스를 가지고 있는 타입이고 자바의 배열을 감싼 래퍼 타입 입니다.공식적으로는 컬렉션이 아니지만 Iterable 연산을 지원합니다.val arr = Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)arr(0) = &quot;d&quot; // 0번째 인덱스 값 변경println(arr) // [Ljava.lang.String;@77f03bb1println(arr.mkString(&quot;Array(&quot;, &quot;, &quot;, &quot;)&quot;)) // Array(d, b, c)val mappedArr = arr.map(_.concat(&quot;z&quot;)) // Iterable 연산 지원println(mappedArr.mkString(&quot;Array(&quot;, &quot;, &quot;, &quot;)&quot;)) // Array(dz, bz, cz)val filteredArr = arr.filter(item =&amp;gt; item == &quot;b&quot;) // Iterable 연산 지원println(filteredArr.mkString(&quot;Array(&quot;, &quot;, &quot;, &quot;)&quot;))Seq와 시퀀스Seq는 모든 시퀀스의 루트 타입이며 List같은 연결리스트와 Vector 같은 색인리스트를 포함합니다.List를 생성하는 다른 방법으로 Seq를 호출할 수 있습니다.val seq = Seq(&#39;C&#39;, &#39;M&#39;, &#39;Y&#39;, &#39;K&#39;)println(seq) // List(C, M, Y, K)val list = List(&#39;C&#39;, &#39;M&#39;, &#39;Y&#39;, &#39;K&#39;)println(list) // List(C, M, Y, K)println(seq == list) // true시퀀스 컬렉션의 계층구조 (출처 : https://www.oreilly.com/library/view/learning-scala/9781449368814/ch07.html)시퀀스 타입 이름 설명 Seq 모든 시퀀스의 루트, List()의 간단한 방법 IndexedSeq 색인 시퀀스의 루트, Vector의 손쉬운 방법 Vector 색인된 접근을 위해 Array 인스턴스에 의해 지원받는 리스트 Range 정수의 범위, 데이터를 즉시 생성함 LinearSeq 선형(연결 리스트) 시퀀스의 루트 List 구성요소들의 단방향 연결 리스트 Queue 선입선출 리스트 Stack 후입선출 리스트 Stream 지연 리스트, 항목들은 그 항목에 접근할 때 추가됨 String 문자(Character)의 컬렉션 " }, { "title": "[Learning Scala] Chapter6. 보편적인 컬렉션 (2)", "url": "/posts/scala-learning-scala-chapter6-2/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-08 09:58:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677이전 포스팅에서 기본적인 컬렉션에 대해 알아보았습니다.이번 포스팅에서는 앞서 공부한 컬렉션들에 대해 조금 더 디테일한 기능에 대해 알아보겠습니다.(List 컬렉션을 중점으로 두고 작성하겠습니다.)List에는 무엇이 있는가?List 정의하기리스트를 정의하는 법은 다양하게 있지만 간단하게 몇가지를 알아보겠습니다.// 빈 리스트 선언 (리스트 타입을 지정해줘야합니다.)val list = List[String]() // String List 정의 (값의 타입을 추론합니다.)val colors = List(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)// List 안에 List 선언val listInList = List(List(1, 3, 5), List(2, 4, 6))// List 인에 Tuple 선언 (Map과 유사해보이지만 Map 만의 api를 제공하진 않습니다.)val tuples = List((&#39;A&#39;, 1), &#39;B&#39; -&amp;gt; 2, &#39;C&#39; -&amp;gt; 3)요소 참조하기List의 요소를 참조할 때는 가장 기본적으로 인덱스 번호로 참조할 수 있고첫번째, 마지막 요소를 참조하는 메소드도 따로 존재하고 스칼라만의 특이한 tail 메소드가 있습니다.val colors = List(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)colors(1) // 인덱스 번호로 요소를 호출하기.colors.head // 리스트의 첫번째 요소 가져오기.colors.last // 리스트의 마지막 요소 가져오기.colors.tail // head 요소를 제외한 나머지 요소들 가져오기.List 확인하기List에 요소가 존재하는지, 비어있는지 등을 확인하는 메소드도 당연히 있습니다.다만 단순히 List의 요소 존재여부만 판단할 때 size 메소드 보다는 isEmpty를 사용하는 것이 조금 더 효율적입니다.val colors = List(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)// 아래 두 메소드는 결과는 동일하지만 size 메소드는 매번 리스트를 모두 순회하므로 이 경우에는 isEmpty가 더 효율적입니다.colors.size &amp;lt; 1 // falsecolors.isEmpty // false// isEmpty 를 반대로 구현한 메소드 입니다. !isEmptyprintln(colors.nonEmpty) // true생성 연산자스칼라에는 Nil 이라는 타입이 있습니다. 아무 것도 없는 리스트를 표현하는 타입이며 모든 리스트의 종점엔 Nil 인스턴스가 있습니다.또한 지금까지 공부한 대부분의 연산자들은 왼쪽 결합형 (left-associative)이었으나 지금 공부할 리스트 생성 연산자 (::)는 오른쪽 결합형(right-associative) 입니다.Nil과 생성 연산자(::)를 사용하여 리스트를 생성할 수 있습니다.val list = 1 :: 2 :: 3 :: Nilprintln(list) // List(1, 2, 3) ::는 단순히 List에서 제공하는 메소드이며 1, 2, 3을 Nil 앞에 요소로 추가한다고 볼 수 있습니다.List의 산술 연산Int나 String 타입의 값이나 변수에 사용되는 산술 연산이 있듯 List에서도 사용할 수 있는 산술 연산이 다양하게 존재합니다.바로 위에서 공부했던 생성 연산자 ::도 마찬가지 입니다. 이름 예제 설명 :: 1 :: 2 :: Nil 리스트에 개발 요소를 덧붙임, 오른쪽-결합형 연산자 ::: List(1, 2) ::: List(2, 3) 이 리스트 앞에 다른 리스트를 추가함, 오른쪽-결합형 연산자 ++ List(1, 2) ++ Set(3, 4, 3) 이 리스트에 다른 컬렉션을 덧붙임 == List(1, 2) == List(1, 2) 두 컬렉션의 타입과 내용이 동일하다면 참을 반환 distinct List(3, 5, 4, 3, 4).distinct 중복 요소가 없는 리스트를 반환 drop List(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) drop 2 리스트의 첫 번째 n개의 요소를 제거 filter List(23, 8, 14, 21) filter (_ &amp;gt; 18) Boolean 함수를 통과한 요소들을 반환 flatten List(List(1, 2), List(3, 4)).flatten 다중 리스트를 단일 리스트로 변환 partition List(1, 2, 3, 4, 5) partition (_ &amp;lt; 3) 리스트의 요소들을 참/거짓 함수 결과에 따라 분류하여 두 개의 리스트를 포함하는 튜플로 생성 reverse List(1, 2, 3).reverse 리스트 요소들의 순서를 거꾸로 함 slice List(&quot;apple&quot;, &quot;to) slice (1, 3) 리스트 중 첫 번째 인덱스부터 두 번째 인덱스 - 1까지에 해당하는 부분을 반환 sortBy List(&quot;apple&quot;, &quot;to&quot;) sortBy (_.length) 주어진 함수로부터 반환된 값으로 리스트 순서를 정렬 sorted List(&quot;apple&quot;, &quot;to&quot;).sorted 핵심 스칼라 타입의 리스트를 자연값 기준으로 정렬함 splitAt List(2, 3, 5, 7) splitAt 2 List 요소들을 주어진 인덱스의 앞에 위치하는지 뒤에 위치하는지에 따라 두 리스트의 튜플로 분류함 take List(2, 3, 5, 7, 11, 13) take 3 리스트에서 첫 번째 n개의 요소들을 추출 zip List(1 , 2) zip List(&quot;a&quot;, &quot;b&quot;) 두 리스트를 각 인덱스에 해당하는 요소들끼리 구성된 튜플의 리스트로 결합 List에는 이렇게 다양한 산술 연산이 존재합니다.더불어 List는 연결 리스트이기 때문에 리스트를 순회하는 연산을 할 때는 주의해야 합니다. 일반적으로는 앞에서 연산하는 것이 가장 좋습니다.고차함수 사용해보기위 표에서 고차함수는 filter, partition, sortBy 가 있는데 가볍게 살펴보겠습니다.// 20보다 큰 요소만 추출List(23, 8, 14, 21).filter(_ &amp;gt; 20) // List(23, 21)// 3보다 작은 것과 그렇지 않은 것들로 나눠서 튜플로 반환List(1, 2, 3, 4, 5).partition(_ &amp;lt; 3) // (List(1, 2),List(3, 4, 5))// 문자열의 길이가 짧은 것부터 정렬List(&quot;apple&quot;, &quot;to&quot;).sortBy(_.length) // List(to, apple)List 매핑map 메소드를 사용하여 어떠한 함수를 List의 모든 요소에 적용하고 새로운 리스트로 결과를 반환할 수 있습니다.책에서 엄선한 map 관련 메소드를 살펴보겠습니다.// 주어진 함수를 이용하여 각 요소를 반환List(&quot;alan&quot;, &quot;sangwoo&quot;).map(s =&amp;gt; s&quot;$s bae&quot;) // List(alan bae, sangwoo bae)// 주어진 함수를 이용하여 각 요소를 변환하고 그 결과 리스트를 이 리스트에 평면화(flatten) 함List(&quot;milk,tee&quot;).flatMap(_.split(&quot;,&quot;)) // List(milk, tee)// 각 요소를 부분 함수를 사용하여 변환하고, 해당 함수를 적용할 수 있는 요소를 유지함.List(0, 1, 2) collect { case 1 =&amp;gt; &quot;ok&quot; } // List(ok)List(0, 1, 2) collect { case 1 =&amp;gt; &quot;ok&quot; case 2 =&amp;gt; &quot;fail&quot;} // List(ok, fail)List 축소하기지금까지 List의 사이즈와 구조를 변경하거나 완전히 다른 값과 타입으로 전환하는 방법을 알아보았습니다.이번에는 리스트를 단일 값으로 축소하는 방법을 알아보겠습니다.수학적인 축소 연산 이름 예제 설명 max List(41, 59, 26).max 리스트의 최대값 구하기 min List(10.9, 32.5, 4.23, 5.67).min 리스트의 최소값 구하기 product List(5, 6, 7).product 리스트의 숫자들을 곱하기 sum List(11.3, 23.5, 7.2).sum 리스트의 숫자들을 합하기 부울(bool) 축소 연산 이름 예제 설명 contains List(34, 29, 18) contains 29 리스트에 이 요소를 포함하고 있는지름 검사함 endsWith List(0, 4, 3) endsWith List(4, 3) 리스트가 주어진 리스트로 끝나는지를 검사함 exists List(24, 17, 32) exists (_ &amp;lt; 18) 리스트에서 최소 하나의 요소에 대해 조건자가 성립하지는지를 검사함 forall List(24, 17, 32) forall (_ &amp;lt; 18) 리스트의 모든 요소에 대해 조건자가 성립하는지를 검사함 startsWith List(0, 4, 3) startsWith List(0) 리스트가 주어진 리스트로 시작하는지를 테스트함 일반적인 리스트 축소 연산 이름 예제 설명 fold List(4, 5, 6).fold(0)(_ + _) 주어진 시작값과 축소 함수로 리스트를 축소 reduce List(4, 5, 6).reduce(_ + _) 리스트의 첫번째 요소를 시작으로 주어진 축소 함수로 리스트를 축소 scan List(4, 5, 6).scan(0)(_ + _) 시작값과 축소 함수를 취하여 각각의 누곗값의 리스트를 반환함 위 세 가지 연산은 Left, Right 연산도 함께 제공 됩니다. (ex: foldLeft, foldRight)컬렉션 전환하기List를 기준으로 이번 포스팅을 진행하지만 필요에 따라Map이나 Set 등 다른 컬렉션 타입으로 변환이 필요할 수 있을때 사용하는 연산이 있습니다.컬렉션 전환 연산 이름 예제 설명 mkString List(24, 99, 104).mkString(&quot;, &quot;) 주어진 구분자를 사용하여 컬렉션을 String으로 변환 toBuffer List(&#39;f&#39;, &#39;t&#39;).toBuffer 불변의 컬렉션을 가변적인 컬렉션으로 전환 toList Map(&quot;a&quot; -&amp;gt; 1, &quot;b&quot; -&amp;gt; 2).toList 컬렉션을 List로 전환 toMap Set(1 -&amp;gt; true, 3 -&amp;gt; true).toSet 두 요소(길이)로 구성된 튜플의 컬렉션을 Map으로 전환 toSet List(2, 5, 5, 3, 2).toSet 컬렉션을 Set으로 전환 toString List(2, 5, 5, 3, 2).toString 컬렉션을 String으로 컬렉션의 타입을 포함하여 만듦 자바와 스칼라 컬렉션 호환성스칼라는 JVM 으로 컴파일하고 그 위에서 동작하기 때문에 JDK와 상호작용하고 어떤 자바 라이브러리도 추가할 수 있어야 합니다.기본적으로 자바 컬렉션과 스칼라 컬렉션은 호환되지는 않지만 아래의 import 구문을 추가하면 서로 변환이 가능한 연산이 추가 됩니다.import scala.jdk.CollectionConverters._object ScalaToJava extends App { val scalaList = List(12, 29) val list = scalaList.asJava // java.util.List val javaList = new java.util.ArrayList[String](5) val d = javaList.asScala // mutable.Buffer } 서적에는 collecton.JavaConverters._를 import 하라고 기술되어 있지만 deprecated 되었고2.13.0버전 부터는 scala.jdk.CollectionConverters._를 사용하도록 되어 있습니다.컬렉션으로 패턴 매칭하기컬렉션을 이용하여 매치 표현식을 사용할 수 있습니다.패턴 매칭은 스칼라의 평범한 연산일 뿐 아니라 스칼라의 핵심 특징이며 스칼라 데이터 구조에 광범위하게 적용됩니다.잘 사용한다면 다른 언어에서 비슷한 작업을 할 때보다 로직을 간결하게 작성할 수 있습니다.val statuses = List(500, 404)// 리스트의 head 값을 기준으로 500 미만 여부 체크하여 분기val msg1 = statuses.head match { case x if x &amp;lt; 500 =&amp;gt; &quot;okay&quot; case _ =&amp;gt; &quot;error&quot;}println(msg1) // error// 리스트에 500 포함 여부 체크하여 분기val msg2 = statuses match { case x if x contains 500 =&amp;gt; &quot;has error&quot; case _ =&amp;gt; &quot;okay&quot;}println(msg2) // has error// 패턴 가드를 사용하여 분기val msg3 = statuses match { case List(500, x) =&amp;gt; s&quot;error by $x&quot; case List(e, x) =&amp;gt; s&quot;$e by $x&quot;}println(msg3) // error by 403// 리스트의 head와 tail을 분해val result = List(&#39;r&#39;, &#39;g&#39;, &#39;b&#39;) match { case head :: tail =&amp;gt; s&quot;$head :: $tail&quot; case Nil =&amp;gt; &#39; &#39;}println(result) // r :: List(g, b)// 튜플도 패턴 매칭을 사용할 수 있음val result2 = (&#39;h&#39;, 204, true) match {case (_, _, false) =&amp;gt; 501case (&#39;c&#39;, _, true) =&amp;gt; 302case (&#39;h&#39;, x, true) =&amp;gt; x // 여길 통과합니다.case (c, x, true) =&amp;gt; println(s&quot;did not expect code $c&quot;) x}println(result2) // 204이상으로 기본적인 컬렉션인 List에 대해 알아보고 Map과 Set에 대해서도 가볍게 알아봤습니다.이번 포스팅으로 알게된 List, Map, Set 뿐만 아니라 다른 컬렉션들이 많이 존재하니각 컬렉션들의 용도를 잘 구분하여 사용할 수 있어야할 것 같습니다." }, { "title": "[Learning Scala] Chapter6. 보편적인 컬렉션 (1)", "url": "/posts/scala-learning-scala-chapter6-1/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-07 17:00:00 +0900", "snippet": "이 글은 러닝 스칼라를 기반으로 작성 되었습니다.출처 : https://jpub.tistory.com/677스칼라는 JVM 기반 언어이므로 기본적으로 자바 컬렉션이 사용이 가능합니다.하지만 추가적으로 스칼라만의 다양한 고차 연산도 있있습니다.대부분 Iterable의 서브타입이고 컬렉션 데이터를 처리하는 메소드들을 제공합니다.ListList는 불변의 단방향 연결 리스트입니다.List를 가볍게 아래와 같이 사용해 볼 수 입습니다.val list: List[Int] = List(11, 30, 10, 21) // List.apply(11, 30, 10, 21)println(s&quot;list size : ${list.size}, list : $list&quot;) // list size : 4, list : List(11, 30, 10, 21)println(list(1)) // 30println(list.head) // 11println(list.last) // 21println(list.tail) // List(30, 10, 21)List를 루프(loop)로 사용하기앞에서 공부한 for 문을 사용하여 List를 루핑할 수 있습니다.val list: List[Int] = List(11, 30, 10, 21) // List.apply(11, 30, 10, 21)var total = 0for (i &amp;lt;- list) { total += i}println(total) // 72고차함수 사용하기List 외에 다른 컬렉션에서도 사용 가능한 고차 함수를 아래 예제처럼 적용할 수 있습니다.val list = List(&quot;hello&quot;, &quot;world&quot;, &quot;scala&quot;)// foreach: 프로시저를 받아서 리스트의 모든 요소에서 호출 시킨다.list.foreach((s: String) =&amp;gt; print(s&quot;$s,&quot;)) // hello,world,scala,list.foreach { s =&amp;gt; print(s&quot;$s,&quot;) } // hello,world,scala,// map: 리스트의 모든 요소을 다른 값이나 타입으로 전환하는 함수를 받는다.list.map((s: String) =&amp;gt; s.length) // List(5, 5, 5)list.map { s =&amp;gt; s.length } // List(5, 5, 5)// reduce: 리스트 요소들를 단일 항목으로 결합한다.val data = list.reduce((s1: String, s2: String) =&amp;gt; { println(s&quot;($s1, $s2)&quot;) s1 + s2})println(data) // helloworldscala// 위 reduce 동작 순서// (hello, world)// (helloworld, scala)SetSet은 각 요소들이 유일하고 순서가 없는 컬렉션이며 동작은 List와 유사합니다.val data = Set(10, 20, 30, 20, 10)println(data) // Set(10, 20, 30)=println(data.reduce((a: Int, b: Int) =&amp;gt; a + b)) // 60 (sum과 동일하게 동작)MapMap은 불변의 키-값 저장소이며 키-값 쌍을 Tuple로 기술하면 되며 관계 연산자(-&amp;gt;)를 사용할 수 있습니다.Map 또한 Iterable의 서브 타입 이므로 List와 동일한 연산을 지원합니다.val rgbMap = Map( &quot;red&quot; -&amp;gt; 0xff0000, &quot;green&quot; -&amp;gt; 0xff00, &quot;blue&quot; -&amp;gt; 0xff)rgbMap(&quot;red&quot;) // 16711680rgbMap(&quot;green&quot;) | rgbMap(&quot;blue&quot;) // 65535rgbMap.contains(&quot;black&quot;) // falsergbMap.foreach(pair =&amp;gt; println(pair))// (red,16711680)// (green,65280)// (blue,255)지금까지 이렇게 기본적인 컬렉션인 List, Set, Map에 대해 간단히 알아보았습니다.이런 컬렉션들로 어떤 작업을 할 수 있는지는 다음 포스팅에서 알아보겠습니다." }, { "title": "[Learning Scala] Chapter5. 일급 함수", "url": "/posts/scala-learning-scala-chapter5/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-07 10:20:00 +0900", "snippet": "출처 : https://jpub.tistory.com/677이 글은 러닝 스칼라를 기반으로 작성 되었습니다.일급 함수란? 함수가 선언되고 호출되는 것 외에 다른 데이터 타입처럼 사용될 수 있는 것. 식별자에 할당되지 않고도 리터럴 형태로 생성될 수 있음. 값, 변수 데이터 구조처럼 컨테이너에 저장될 수 있음. 다른 함수의 매개변수로 사용되거나 다른 함수의 반환값으로 사용될 수 있음. (고차 함수: higher-order function)함수 타입과 값함수의 타입은 입력 타입과 반환 값 타입의 단순한 그룹입니다.일반적인 함수 정의 시 String, Int, Unit 등의 타입을 반환하지만 함수 자체를 반환할 수 있으며이 때 반환 타입을 정의할 때 아래와 같이 작성할 수 있습니다.([&amp;lt;입력 타입&amp;gt;, ....]) =&amp;gt; &amp;lt;반환 타입&amp;gt;def double(x: Int): Int = { x * 2}double(10) // 일반 함수 호출val myDouble: Int =&amp;gt; Int = double // myDouble은 double 함수 자체를 값으로 받아 타입은 Int =&amp;gt; Int (Int를 입력받아 Int를 반환하는 타입)myDouble(10) // double 함수 호출과 결과가 동일val myDoubleCopy = myDouble // 새로운 값에 할당하는 것도 일반 값과 동일하게 가능myDoubleCopy(5) // double, myDouble과 결과 동일def max(x: Int, y: Int): Int = { if (x &amp;gt; y) x else y}val maximum: (Int, Int) =&amp;gt; Int = max // max 함수의 매개변수가 여러개일때.maximum(10, 20)고차 함수 (higher-order function)입력 매개변수나 반환 값을 함수 타입의 값을 가지는 함수를 고차 함수 라고 합니다.// 두번째 매개변수로 함수 타입을 받는다.def myString(str: String, fun: String =&amp;gt; String): String = { if (str == null) { return null } fun(str) // 함수타입으로 받은 매개변수를 실행시킨다.}def reverser(s: String) = s.reversemyString(&quot;hello&quot;, reverser) // olleh (두번째 매개변수로 함수를 넘긴다.)함수 리터럴 (function literal)함수 리터럴은 이름없는 함수로 함숫값과 변수에 저장되거나 고차 함수 매개변수로 정의할 수 있습니다.함수 리터럴의 다른 명칭 익명 함수 (Anonymous function) 람다 표현식, 람다 (Lambda expression)([&amp;lt;식별자&amp;gt;: &amp;lt;타입&amp;gt;, ... ]) =&amp;gt; &amp;lt;표현식&amp;gt;/** * doDouble 이라는 이름이 있는 함수 정의 * @param x 입력값 * @return 결과값 */def doDouble(x: Int): Int = x * 2/** * 이름없는 함수를 doubler 라는 함숫값으로 정의 * 이 값의 타입은 Int =&amp;gt; Int 이다. */val doubler = (x: Int) =&amp;gt; x * 2 위 예제의 차이가 느껴지시나요?위에서 고차 함수의 예제로 사용했던 함수를 사용하여 함수 리터럴을 표현할 수 있습니다.// 두번째 매개변수로 함수 타입을 받는다.def myString(str: String, fun: String =&amp;gt; String): String = { if (str == null) { return null } fun(str) // 함수타입으로 받은 매개변수를 실행시킨다.}myString(&quot;hello&quot;, (s: String) =&amp;gt; s.replace(&quot;l&quot;, &quot;i&quot;)) // 두번째 파라미터로 함수 리터럴을 넘김.자리표시자 구문 (placeholder syntax)함수 리터럴의 축약형으로 지정된 매개변수를 와일드카드 연산자(_)로 대체한 형태입니다.입력 매개변수가 한 번만 사용되고 리터럴의 타입이 명시적으로 정의되어 있다면 사용할 수 있습니다.// 리터럴의 타입이 Int =&amp;gt; Int로 명시되어 있어 와일드카드(_)를 사용할 수 있음.val doubler: Int =&amp;gt; Int = _ * 2// 두번째 매개변수로 함수 타입을 받는다.def myString(str: String, fun: String =&amp;gt; String): String = { if (str == null) { return null } fun(str) // 함수타입으로 받은 매개변수를 실행시킨다.}// 명시적으로 두번째 파라미터가 String =&amp;gt; String 타입의 함수값을 받도록 정의되어 있으므로 와일드카드(_)를 사용할 수 있음.myString(&quot;hello&quot;, _.reverse) // olleh부분 적용 함수와 커링지금까지 공부한 함수는 기본 매개변수가 있지 않다면 함수의 모든 매개변수를 지정하여야 합니다.만약 일부 매개변수를 고정하고 싶다면 와일드카드(_)를 명시적인 타입과 함께 사용하여부분적으로 함수를 적용할 수 있고 이 기법을 커링(currying)이라고 합니다.def factorOf(x: Int, y: Int) = y % x == 0val multipleOf3 = factorOf(3, _: Int) // factorOf 함수의 첫번째 파라미터를 3으로 고정한 함수값val isEven = factorOf(2, _: Int) // factorOf 함수의 첫번째 파라미터를 2로 고정한 함수값multipleOf3(30) // trueisEven(111) // false이름에 의한 호출 매개변수함수의 매개변수를 값, 함수 중 아무거나 호출할 수 있도록 지원하는 이름에 의한(by-name) 호출 매개변수 입니다.값으로 매개변수를 넘긴다면 일반적인 함수와 동일하게 파라미터에 접근할 수 있습니다. (by-value parameter)만약 함수를 매개변수를 넘긴다면 호출한 함수 내에서 매개변수가 사용할때마다 매개변수로 넘긴 함수가 실행됩니다.이름에 의한 호출 매개변수 지정하기&amp;lt;식별자&amp;gt;: =&amp;gt; &amp;lt;타입&amp;gt;// 일반적인 함수def myPrinter1(data: Int): Unit = { for (i &amp;lt;- Range(0, 2)) { println(s&quot;myPrinter1 call data($i) : $data&quot;) }}// 이름에 의한 호출 매개변수를 가진 함수def myPrinter2(data: =&amp;gt; Int): Unit = { for (i &amp;lt;- Range(0, 2)) { println(s&quot;myPrinter2 call data($i) : $data&quot;) }}// 예시 함수def f(num: Int) = { println(s&quot;f($num)&quot;) num}// 1. 값을 매개변수를 넘겼을 때 차이myPrinter1(1)//myPrinter1 call data(0) : 1//myPrinter1 call data(1) : 1myPrinter2(1) // myPrinter1(1)과 동작 동일//myPrinter2 call data(0) : 1//myPrinter2 call data(1) : 1// 함수를 매개변수로 넘겼을 때 차이myPrinter1(f(1))//f(1)//myPrinter1 call data(0) : 1//myPrinter1 call data(1) : 1myPrinter2(f(1)) // myPrinter1(f(1))과 동작이 다름. 매개변수를 참조할 때 마다 f(1) 함수 실행//f(1)//myPrinter2 call data(0) : 1//f(1)//myPrinter2 call data(1) : 1//f(1) myPrinter1 과 myPrinter2 함수의 파라미터를 비교해보면 차이점을 알 수 있습니다.부분 함수부분 함수(partial function)는 앞에서 공부한 부분 적용 함수와는 다릅니다.부분 함수는 일반적인 함수인 완전 함수와 반대되는 개념으로 가능한 입력값 중 일부만 받을 수 있는 함수입니다.부분 적용 함수는 부분적으로 호출되는 일반 함수입니다.부분 함수는 매치 표현식과 비슷하게 사용할 수 있습니다.def call: Int =&amp;gt; String = { case 1 =&amp;gt; &quot;ONE&quot; case 2 =&amp;gt; &quot;TWO&quot;}println(call(1)) // ONEprintln(call(2)) // TWOprintln(call(3)) // 에러 발생 scala.MatchError함수 리터럴 블록으로 고차 함수 호출하기위에서 고차 함수를 공부할 때는 표현식 블록을 직접 정의하여 사용할 함수에서 매개변수로 호출 하였습니다.만약 표현식 블록을 재사용할 가능성이 크다면 그렇게 사용하는 것도 좋지만만약 한 번 사용되고 말 표현식이라면 함수 리터럴 블록으로 매개변수를 넘길 수 있습니다.// 두번째 매개변수로 함수 타입을 받는다.def myString(str: String, fun: String =&amp;gt; String): String = { if (str == null) { return null } fun(str) // 함수타입으로 받은 매개변수를 실행시킨다.}// 위에서 공부한 고차 함수 호출 법def myConcat(s: String): String = { val str = s.concat(&quot;,scala&quot;) str.replace(&quot;,&quot;, &quot; &quot;)}myString(&quot;hello&quot;, myConcat)// 함수 리터럴로 고차 함수 호출하기myString(&quot;hello&quot;, { s =&amp;gt; val str = s.concat(&quot;,scala&quot;) str.replace(&quot;,&quot;, &quot; &quot;)})위와 같이 함수 리터럴로 고차 함수를 호출 할 수 있습니다.다만 한 괄호 안에 포함 시키는 것이 다루기 불편할 수 있기 때문에매개변수 그룹을 분리하여 함수 리터럴 블록을 사용할 수 있습니다.// 매개변수 그룹을 분리def myString2(str: String)(fun: String =&amp;gt; String): String = { if (str == null) { return null } fun(str) // 함수타입으로 받은 매개변수를 실행시킨다.}myString2(&quot;hello&quot;) { s =&amp;gt; val str = s.concat(&quot;,scala&quot;) str.replace(&quot;,&quot;, &quot; &quot;)}" }, { "title": "[Learning Scala] Chapter4. 함수", "url": "/posts/scala-learning-scala-chapter4/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-06 09:38:00 +0900", "snippet": "출처 : https://jpub.tistory.com/677이 글은 러닝 스칼라를 기반으로 작성 되었습니다.스칼라의 함수 (function)스칼라에서 함수는 이름을 가진, 재활용 가능한 표현식입니다.함수는 매개변수화할 수도 있고 값을 반환할 수도 있지만 이 어느 것도 필수는 아니지만 이 특징들은 재사용과 구성력을 최대화 합니다.더 짧고, 더 가독성이 높고, 더 안정적인 어플리케이션을 작성할 수 있도록 해주며 매개변수화 된 함수를 사용하여 정규화된다면 테스트하기도 쉬워집니다.함수형 프로그래밍 언어스칼라는 함수형 프로그래밍 언어 이며 함수형 프로그래밍 언어는 재사용성이 높고구성력이 좋은 함수를 지원하여 함수를 구조화할 수 있도록 돕는데 맞춰져 있습니다.특히 순수 함수를 구성하면 더 훌륭한 이점을 얻을 수 있습니다.순수 함수의 특징 하나 또는 그 이상의 입력 매개변수를 가진다. 입력 매개변수만을 가지고 계산을 수행한다. 값을 반환한다. 동일 입력에 대해 하상 같은 값을 반환한다. 함수 외부의 어떤 데이터도 사용하거나 영향을 주지 않는다. 함수 외부 데이터에 영향받지 않는다.다양한 함수의 사용법// 입력값이 없는 함수def hi = &quot;hi&quot;// 반환 타입을 지정하여 함수 정의def hello: String = &quot;hello&quot;// 함수 정의def greet(name: String): String = s&quot;Hello, $name&quot;println(greet(&quot;alan&quot;))// 함수 조기종료def safeTrim(data: String): String = { if (data == null) { return null // 특정 조건에 따라 조기종료를 해야한다면 return 사용 } data.trim // return 사용하지 않고 반환}val trimResult = safeTrim(&quot; This is trim... &quot;)println(trimResult) // This is trim...val trimNullResult = safeTrim(null)println(trimNullResult) // null프로시저 (procedure)프로시저는 반환값을 가지지 않는 함수입니다.작성한 함수에 반환값이 없다면 Unit 타입으로 추론이 됩니다.// 묵시적 반환def logger(str: String) = println(s&quot;log : $str&quot;)// 명시적 반환def logger2(str: String): Unit = println(s&quot;log : $str&quot;)// deprecated : 등호 없이 정의def logger3(str: String) { println(s&quot;log : $str&quot;)}빈 괄호 함수함수에 매개변수가 없다면 빈 괄호를 사용하여 함수와 값을 명확하게 구분하는 것이 좋습니다.// 빈 괄호를 사용하여 함수 정의def hi() = &quot;hi&quot;hi() // okhi // ok// 괄호 없이 함수 정의def hello = &quot;hello&quot;hello // okhello() // error 발생표현식 블록을 이용하여 함수 호출함수에 표현식 블록을 사용하여 블록의 반환값을 함수의 인수로 사용할 수 있습니다.def won(amount: Int) = s&quot;${amount}원&quot;val myWon = won { val money = 1000 + 2000 money * 2 // 6000. won 함수의 인수로 사용됨}println(myWon) // 6000원중첩 함수스칼라에서 표현식 블록이 중첩이 되듯 함수도 중첩이 가능합니다.def max(a: Int, b: Int, c: Int) = { def max(x: Int, y: Int) = if (x &amp;gt; y) x else y max(a, max(b, c))}val maxNum = max(100, 200, 300)println(maxNum) // 300매개변수 이름을 지정하여 함수 호출함수를 호출 할 때 매개변수 이름을 지정하여 함수를 호출하면 명시적이며실제 함수 정의 시의 매개변수 순서와 다르게 순서를 지정하여도 호출이 가능합니다.def printProfile(name: String, age: Int, email: String): Unit = { println(s&quot;name: $name&quot;) println(s&quot;age: $age&quot;) println(s&quot;email: $email&quot;)}printProfile( name = &quot;alan&quot;, email = &quot;alan@gmail.com&quot;, // 실제 함수에 선언된 매개변수 순서와 호출 순서가 다르더라도 가능 age = 10)// 출력:// name: alan// age: 10// email: alan@gmail.com기본값을 갖는 매개변수함수의 매개변수의 기본값을 지정할 수 있으며 기본값을 지정한 매개변수를매개변수 순서를 뒤로 가도록 하면 구조화에 더 좋습니다.def greet(name: String, prefix: String = &quot;Hello&quot;) = { println(s&quot;$prefix, $name&quot;)}greet(name = &quot;alan&quot;) // Hello, alangreet(prefix = &quot;hi&quot;, name = &quot;alan&quot;) // hi, alangreet(&quot;alan&quot;, &quot;bye&quot;) // bye, alan가변 매개변수스칼라는 코틀린 처럼 가변 매개변수 (vararg)를 받을 수 있습니다.*(asterisk, 별표) 를 사용하여 가변 매개변수를 정의할 수 있고 해당 매개변수는 컬렉션 타입입니다.def sum(nums: Int*): Int = { var total = 0 for (num &amp;lt;- nums) total += num total}println(sum(1, 2, 3, 4)) // 10매개변수 그룹스카라는 매개변수를 그룹으로 분리를 할 수 있다. 괄호 ((, ))를 기준으로 그룹을 묶을 수 있습니다.def min(x: Int)(y: Int): Int = { if (x &amp;lt; y) x else y}println(min(1)(5)) // 1 위 예제처럼 간단한 코드에서는 특별하게 사용해야할 이유가 없을 수도 있지만 추후에 고차 함수를 사용하게 되어 함수 리터럴과 함게 사용할 때 이점이 있을 수 있습니다.타입 매개변수자바 등에서 부르는 generic 과 비슷한 기능입니다.대괄호([,])를 사용하여 타입을 지정할 수 있으며 지정한 타입으로 해당 함수 호출 범위에서 사용할 수 있습니다.더불어 타입 추론을 함께 사용하면 더 간결한 코드를 작성할 수 있습니다.// 결과값의 타입을 지정해서 받을 수 없다. 무조건 Any로 리턴def identity(a: Any): Any = aval s1: String = identity(&quot;string&quot;) // error: type missmatchval i1: Int = identity(1) // error: type missmatch// 아래부터 타입 매개변수 사용// 리턴 타입을 지정해서 받을 수 있음.def identity2[A](a: A): A = a// 함수에 대괄호로 타입 지정val s2: String = identity2[String](&quot;string&quot;)val i2: Int = identity2[Int](1)// 매개변수 자체로 리턴타입 추론 가능.val s3 = identity2(&quot;string&quot;)val i3 = identity2(2)메소드스칼라에서 객체의 메소드를 호출하는 방식은 기존의 자바와 동일합니다.단지 스칼라의 특성에 따라 빈 괄호를 생략하거나 띄어 쓰기로 매개변수를 입력할 수 있습니다.val image = &quot;image.jpg&quot;image.endsWith(&quot;.jpg&quot;) // true (기본적인 방식)image endsWith &quot;.jpg&quot; // true (위와 동일. 코틀린의 infix function 처럼... 스칼라에서는 연산자 표기법이라고 함.)image.last // g (매개변수가 없는 함수)연산자 표기법 (operator notation)위 예제에서 보여진 것처럼 함수의 매개변수가 한 개 일때 점과 괄호를 제거하고 함수를 호출하는 방식을 연산자 표기법이라고 합니다.실제로 스칼라에서는 덧셈 (+) 등 어떤 산술 연산자도 없고 모두 객체의 메소드로써 호출을 합니다.val num = 1 + 2 // 그동안 산술연산자 처럼 사용하였다.val num2 = 1.+(2) // 실제로는 이렇게 메소드 호출로 동작한다.num compare 4 // -1 (num보다 작으면 1, 같으면 0, 크면 -1)val str = &quot;mystr&quot;str substring (2, 4) // st (매개변수가 두개 이상일때는 비효율적일수도...)이와 같이 연산자는 모두 객체의 메소드 이다." }, { "title": "[Learning Scala] Chapter3. 표현식과 조건문", "url": "/posts/scala-learning-scala-chapter3/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-04 17:02:00 +0900", "snippet": "출처 : https://jpub.tistory.com/677이 글은 러닝 스칼라를 기반으로 작성 되었습니다.표현식 (Expression) 표현식은 실행 후 값을 반환하는 코드 단위를 말함. 기존 데이터를 변경하는 대신 값을 반환할 수 있기 때문에 함수형 프로그래밍의 기반이 됨.// 누구나 할 수 있지만 이 자체가 표현식이라는 개념을 설명하기 위해...&quot;hello&quot; // hello&quot;he&quot; + &quot;ll&quot; + &quot;o&quot; // hello표현식 블록 (Expression Block) 중괄호({, })를 사용하여 여러 표현식을 표현식 블록으로 만들 수 있음. 표현식 블록 안의 마지막 표현식이 전체 블록의 반환값이 됨.// 1. 일반 표현식val a = 5val a2 = a + 10println(a2) // 15// 2. 표현식 블록val b = { val x = 5 x + 10}println(b) // 15 위 두 예제는 동일한 결과가 출력되지만 표현식 블록을 사용한 예제는 어떠한 값을 정의 하기 위한 것임을 분명히 할 수 있습니다.val amount = { val a = 1000; { val b = a * 2; { val c = b - 2 c } }}println(amount) 위와 같이 표현식 블록은 중첩이 가능합니다. 굳이 이런 방식을 사용할 필요는 없지만 이 구문과 구성의 본질을 이해하는 것이 필요합니다.if 표현식자바 등 타 언어에서는 if... else if... else 블록형태를 취하지만스칼라는 공식적으로 if와 선택적인 else 블록만을 지원합니다.실전에서는 if... else if... else블록을 작성할 수 있지만이는 스칼라에서는 if... else { if... else...} 표현식과 동일하며 논리적으로는 일치합니다.val amount = 10 if (amount &amp;gt; 0) { println(true) // true 출력} else { println(false)}// 아래 두 표현식은 동일하며 논리적으로도 일치함.if (a &amp;gt; 0) { println(&quot;양수&quot;)} else if (a &amp;lt; 0) { println(&quot;음수&quot;)} else { println(&quot;0&quot;)}if (a &amp;gt; 0) { println(&quot;양수&quot;)} else { if (a &amp;lt; 0) { println(&quot;음수&quot;) } else { println(&quot;0&quot;) }}매치 표현식 (Match) 자바의 switch 문과 유사하며 모두 잡아 내는 catch-all 패턴을 지원합니다. 매치 표현식은 0개 또는 단 하나의 패턴만 매칭할 수 있으므로 여러 개의 패턴을 한 번에 순서대로 매칭하는 형태의 제어 이동(fall-through)이 없습니다. break를 지원하지 않습니다.기본 사용법val x = 10val y = 20val maxVal = x &amp;gt; y match { case true =&amp;gt; x case false =&amp;gt; y}println(maxVal) // 10// 표현식의 입력값에 따라 값을 변환하는 것 외에 추가적인 동작을 할 수 있다.val status = 500val message = status match { case 200 =&amp;gt; &quot;ok&quot; case 400 =&amp;gt; { println(&quot;Bad Request&quot;) &quot;error&quot; } case 500 =&amp;gt; { println(&quot;Internal Server Error&quot;) &quot;error&quot; }}println(message)패턴 대안 (Pattern Alternative)하나의 case 블록에 파이프 기호(|)를 사용하여 패턴 중 하나라도 일치하면 해당 case 블록을 리턴할 수 있습니다.val day = &quot;MON&quot;val kind = day match { case &quot;MON&quot; | &quot;TUE&quot; | &quot;WED&quot; | &quot;THU&quot; | &quot;FRI&quot; =&amp;gt; &quot;weekday&quot; case &quot;SAT&quot; | &quot;SUN&quot; =&amp;gt; &quot;weekend&quot;}println(kind) // weekday값 바인딩 패턴특정 리터럴을 매칭 하고 그 외의 경우에는 값 바인딩을 이용하여 가능한 모든 값이 매칭 되도록 할 수 있습니다.val message = &quot;ERROR&quot;val status = message match { case &quot;OK&quot; =&amp;gt; 200 case other =&amp;gt; println(other) // ERROR -1}println(status) // -1 값 other은 case 블록이 유지되는 동안 정의 되며 매치 표현식의 입력값인 message 값이 할당됩니다.와일드카드 연산자 패턴와일드카드 연산자로는 언더바(_) 기호가 사용됩니다.val message = &quot;ERROR&quot;val status = message match { case &quot;OK&quot; =&amp;gt; 200 case _ =&amp;gt; -1}println(status) // -1패턴 가드 (Pattern guard)case 블록에서 if 표현식을 추가하여 match 표현식에 조건부 로직을 섞어 쓸 수 있습니다.val data = &quot;hello&quot;data match { case str if data == &quot;hi&quot; =&amp;gt; println(str) case str =&amp;gt; println(s&quot;this is not hi! : $str&quot;) // this is not hi! : hello}타입 매칭매치 표현식으로 각 case 블록에서 타입을 매칭하여 처리를 분리할 수 있습니다.val x: Int = 1123val y: Any = x // 최상위 타입인 Any에 x값을 할당y match { case x: String =&amp;gt; println(s&quot;String : $x&quot;) case x: Int =&amp;gt; println(s&quot;Int : $x&quot;) // Int : 1123 case x: Long =&amp;gt; println(s&quot;Long : $x&quot;) case x: Double =&amp;gt; println(f&quot;Double : $x%.2f&quot;) case x: Float =&amp;gt; println(f&quot;Float : $x%.2f&quot;)}루프 (Loop)기본 for 루프 반복for (&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복자&amp;gt;) [yield] [&amp;lt;표현식&amp;gt;] yield는 호출된 모든 표현식의 반환 값을 컬렉션으로 반환합니다.아래는 가장 간단한 for 루프 예제입니다.for (x &amp;lt;- 1 to 5) { println(x)}// 출력// 1// 2// 3// 4// 5아래는 yield 키워드를 사용하여 컬렉션을 리턴하는 예제입니다.val result = for (x &amp;lt;- 1 to 5) yield { s&quot;data: $x&quot;}println(result) // Vector(data: 1, data: 2, data: 3, data: 4, data: 5) yield 키워드를 사용하여 리턴된 컬렉션은 Vector 입니다.반복자 가드매치 표현식의 패턴 가드와 마찬가지로 반복자 가드 (or 필터) 를 추가할 수 있습니다.val threes = for (i &amp;lt;- 1 to 20 if i % 3 == 0) yield iprintln(threes) // Vector(3, 6, 9, 12, 15, 18)// 라인을 구분하여 반복자와 반복자 가드를 구분할 수 있고 반복자 가드를 여러개 사용할 수 있음.val quotes = &quot;a,b,c,,d&quot;for { t &amp;lt;- quotes.split(&quot;,&quot;) if t != null if t.length &amp;gt; 0} println(t)중첩된 반복자 (Nested Iterator)반복자를 중첩하여 사용하면 전체 반복 횟수는 모든 반복자 횟수의 곱입니다.for { x &amp;lt;- 1 to 2 y &amp;lt;- 1 to 3} print(s&quot;($x, $y), &quot;) // (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), 값 바인딩for 루프 표현식 블록 내에서 사용할 임시 변수를 바인딩 할 수 있습니다.val result = for (i &amp;lt;- 1 to 5; data = s&quot;data:$i&quot;) yield data // data가 임시 변수 println(result) // Vector(data:1, data:2, data:3, data:4, data:5)while과 do... while 루프var x = 3while (x &amp;gt; 0) { print(s&quot;x:$x,&quot;) x -= 1}// 출력 : x:3,x:2,x:1,val y = 0do println(s&quot;y:$y&quot;)while (y &amp;gt; 0)// 출력 : y:0" }, { "title": "[Learning Scala] Chapter2. 데이터로 작업하기: 리터럴, 값, 변수, 타입", "url": "/posts/scala-learning-scala-chapter2/", "categories": "Scala, Learning Scala", "tags": "scala, learningscala", "date": "2020-09-04 13:38:00 +0900", "snippet": "출처 : https://jpub.tistory.com/677이 글은 러닝 스칼라를 기반으로 작성 되었습니다.스칼라 데이터의 정의 값 불변의 타입 재할당 불가 리터럴 (리터럴 데이터) 숫자, 문자, 텍스트 등 데이터 변수 가변 타입 재할당 가능 타입 데이터의 종류, 데이터의 정의 또는 분류 스칼라의 모든 데이터는 특정 타입에 대응 모든 스칼라 타입은 데이터와 그 데이터를 처리하는 메소드를 갖는 클래스로 정의 값 (Value)val 키워드를 사용하여 불변한(immutable) 값을 정의할 수 있습니다.// val &amp;lt;식별자&amp;gt;[: &amp;lt;타입&amp;gt;] = &amp;lt;데이터&amp;gt;val x: Int = 20val greeting: String = &quot;Hello, Scala!&quot;val at: Char = &#39;@&#39;x = 1000 // error: 재할당 불가변수 (Variable)var 키워드를 사용하여 변경이 가능한(mutable) 변수를 정의할 수 있습니다.// var &amp;lt;식별자&amp;gt;[: &amp;lt;타입&amp;gt;] = &amp;lt;데이터&amp;gt;var myStr: String = &quot;Hello&quot;var myInt: Int = 100myStr = &quot;Hi&quot; // 재할당 가능myInt = &quot;Scala&quot; // error : Type missmatch타입 (Type) 스칼라는 숫자 타입(Int, Double 등) 과 숫자가 아닌 타입 (String 등)이 있음. 스칼라는 원시 데이터 타입 (primitive type)이 없음.타입 추론값이나 변수를 선언 시 타입을 명시하지 않고 할당된 데이터를 기반으로 타입을 추론할 수 있습니다.val myVal = 10 // Int 값으로 추론됨var myVar = &quot;Hello&quot; // String 변수로 추론됨숫자형 데이터 타입 (Number Data Type) 순위 이름 설명 크기 (Byte) 최소 최대 1 Byte 부호 있는 정수 1 -128 127 2 Short 부호 있는 정수 2 -32768 32767 3 Int 부호 있는 정수 4 -2^31 2^31 - 1 4 Long 부호 있는 정수 8 -2^63 2^63 - 1 5 Float 부호 있는 부동 소수점 4 n/a n/a 6 Double 부호 있는 부동 소수점 8 n/a n/a 숫자 타입 간 자동 변환// 위의 표에서 낮은 순위에 있는 타입은 자신보다 높은 타입으로 자동 변환이 가능하다. val b: Byte = 10val s: Short = b val d: Double = s val i: Int = d // Double은 Int보다 높은 순위의 타입으로 변환 불가메소드를 사용한 숫자 타입 간 변환val l: Long = 10val i: Int = l.toInt // Int 타입으로 변환숫자 리터럴(Literal) 표현val myInt = 10 // Intval myHex = 0xffff00 // 접두사 0x : 16진수val myLong = 200L // 접미사 L(l) : Longval myDouble = 2.0 // Doubleval myFloat = 10f // 접미사 f : Floatval myDouble2 = 2d // 접미사 d : Double문자열 (String)스칼라의 String 은 자바의 String 을 기반으로 했습니다. 침고!기본 사용법# REPLscala&amp;gt; val hello = &quot;hello&quot;val hello: String = helloscala&amp;gt; val helloScala = &quot;hello \\nscala&quot;val helloScala: String =helloscala여러줄 리터럴 큰 따옴표 세 개를 사용하여 여러줄 리터럴리 가능함. 특수문자의 시작인 역슬래시를 인식하지 못함.# REPLscala&amp;gt; val multipleLine = &quot;&quot;&quot;scala | java | kotlin | jvm | \\t | \\n&quot;&quot;&quot;val multipleLine: String =scalajavakotlinjvm\\t\\n문자열 보간 (String Interpolation)val alan = &quot;alan&quot;println(&quot;Hello, &quot; + alan) // Hello, alanprintln(s&quot;Hello, $alan&quot;) // Hello, alanval num = 10println(s&quot;num : $num&quot;) // num : 10println(s&quot;num * 3 : ${num * 3}&quot;) // num * 3 : 30// printfval item = &quot;apple&quot;println(f&quot;I wrote a new $item%.3s today&quot;) // I wrote a new app todayprintln(f&quot;$item count : ${355 / 113.0}%.5f&quot;) // apple count : 3.14159튜플 둘 이상의 값을 가지는 순서가 있는 컨테이너. 각각의 값은 다른 타입을 가질 수 있음. 값을 논리적으로 분류할 필요가 있으며 분류한 값들을 하나의 응집된 단위로 표현하는데 유용함. 리스트, 배열과는 다르게 요소들을 반복할 수는 없고 단지 하나 이상의 값을 담기 위한 컨테이너.val infos = (&quot;alan&quot;, &quot;bae&quot;, 8, 31)println(infos._1) // alanval red = &quot;red&quot; -&amp;gt; 0xff0000println(red) // (red,16711680)val reversedRed = red._2 -&amp;gt; red._1println(reversedRed) // (16711680,red)" }, { "title": "[JPA] Spring Data JPA와 Querydsl (feat. Spring MVC)", "url": "/posts/jpa-querydsl/", "categories": "JPA", "tags": "jpa, querydsl", "date": "2020-02-18 00:18:00 +0900", "snippet": "EntityListener@PrePersist@PostPersist@PreUpdate@PostUpdate@PreRemove@PostRemove@PostLoadAttributeConverter@Converterclass SnackNutrientConverter : AttributeConverter&amp;lt;SnackNutrient, String&amp;gt; { private val mapper = jacksonObjectMapper() override fun convertToDatabaseColumn(attribute: SnackNutrient): String { return mapper.writeValueAsString(attribute) } override fun convertToEntityAttribute(dbData: String): SnackNutrient { return mapper.readValue(dbData) }}Spring Data JPARepository 커스텀, 확장interface SnackRepositoryCustom { fun findBy(name: String): Snack?}@Repository@Transactionalclass SnackRepositoryCustomImpl(private val em: EntityManager) : SnackRepositoryCustom { override fun findBy(name: String): Snack? { return em.createQuery(&quot;SELECT s FROM Snack s WHERE s.name = :name&quot;, Snack::class.java) .setParameter(&quot;name&quot;, name) .resultList.firstOrNull() }}기본 Repository 커스텀interface MyRepo&amp;lt;T, ID&amp;gt; : JpaRepository&amp;lt;T, ID&amp;gt;class MyRepoImpl&amp;lt;T, ID&amp;gt;() : MyRepo&amp;lt;T, ID&amp;gt;, SimpleJpaRepository&amp;lt;T, ID&amp;gt;()@EnableJpaRepositories(repositoryBaseClass = MyRepoImpl::class)QuerydslQuerydsl 레퍼런스 문서의존성 및 어노테이션 프로세서 추가implementation(&quot;com.querydsl:querydsl-jpa&quot;)kapt(&quot;com.querydsl:querydsl-apt:4.2.1:jpa&quot;)QDomain 생성./gradlew kaptKotlin -i -S기본 사용법val car = QCar.carval query = JPAQuery&amp;lt;Car&amp;gt;(em)val result = query.from(car) .where(car.name.eq(&quot;asd&quot;)) .fetch()Spring Data JPA와 Querydsl 함께 사용하기@Transactionalclass SnackRepositoryCustomImpl : SnackRepositoryCustom, QuerydslRepositorySupport(Snack::class.java) { override fun findBy(name: String): Snack? { return entityManager!!.createQuery(&quot;SELECT s FROM Snack s WHERE s.name = :name&quot;, Snack::class.java) .setParameter(&quot;name&quot;, name) .resultList.firstOrNull() } override fun findAllBy(name: String): List&amp;lt;Snack&amp;gt; { val snack = QSnack.snack return from(snack) .where(snack.name.eq(name)) .fetch() }}" }, { "title": "[JPA] 엔티티 작성 시 주의 사항 (feat. 스프링 부트, 코틀린)", "url": "/posts/jpa-entity/", "categories": "JPA", "tags": "jpa, entity", "date": "2020-02-06 22:17:00 +0900", "snippet": "단일 데이터 소스를 사용하고 특별한 조건이 없으면서 스프링 부트를 사용한다면 JPA를 설정하는 것은 매우 간편합니다.그러나 기본적인 엔티티 작성 방법 외에 사용 시 주의해야 할 사항들이 있어 정리해봅니다.개인적인 관점에서 필요하다 생각하는 주의 사항이므로 잘못된 방법이라면 댓글로 지적 부탁드립니다.또는 추가적으로 주의 사항이 있다면 댓글로 정보를 주시면 감사드리겠습니다.엔티티 작성 가이드 @Entity 애노테이션을 사용해야 합니다. public 혹은 protected 접근자의 기본 생성자가 필요합니다. 탑 레벨 클래스이어야 하고 enum 이나 interface는 엔티티가 될 수 없습니다. 참고 : https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#entity-pojo엔티티 작성 시 주의 사항equals(), hashCode() 재정의엔티티는 식별자(@Id)를 가지는 객체로써 equals()와 hashCode()를 재정의해주어야 동일성과 동등성이 보장될 수 있습니다.재정의 시에 기본적으로 @Id 필드는 필수로 넣어주시면 좋습니다.@Entityclass Blog { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null var title: String? = null var content: String? = null override fun equals(other: Any?): Boolean { if (this === other) return true if (javaClass != other?.javaClass) return false other as Blog if (id != other.id) return false return true } override fun hashCode(): Int { return id?.hashCode() ?: 0 }}toString() 재정의 시 연관관계 필드 제외테스트 혹은 필요에 의해 자동으로 toString()을 재정의하는 경우 연관관계 필드들은 제외하고 정의하셔야 합니다.특히 양방향 관계라면 더욱 조심하여야 합니다.@Entityclass Parent { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null var name: String? = null @OneToMany(mappedBy = &quot;parent&quot;) val children: MutableSet = mutableSetOf() override fun toString(): String { return &quot;Parent(id=$id, name=$name, children=$children)&quot; }}@Entityclass Child { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null var name: String? = null @ManyToOne(fetch = FetchType.LAZY) var parent: Parent? = null // Convenient method fun matchParent(parent: Parent) { this.parent = parent parent.children.add(this) } override fun toString(): String { return &quot;Child(id=$id, name=$name, parent=$parent)&quot; }}위와 같은 두 엔티티가 양방향 관계를 맺고 toString()을 자동 생성하여 연관 관계 필드를 참조하고아래와 같이 루프를 돌면서 프린트를 찍으면 순환 참조가 계속 발생하여 스택 오버 플로우 익셉션이 발생하고애플리케이션이 종료되는 것을 볼 수 있습니다.@Test@DisplayName(&quot;toString() 순환 참조 테스트&quot;)fun testRecursiveError() { childRepository.findAll().forEach(::println)}엔티티에서 toString()이 잘못 사용된 예Kotlin 기준 엔티티 작성 시 주의 사항코틀린 기반 스프링을 사용하면서 JPA를 사용한다면 추가적으로 주의해야할 사항들이 있으니 꼭 체크해주세요.코틀린 all open 플러그인 잘쓰기// allopen 확장, @Component 등 특정 스프링 어노테이션에 대해 allopen 플러그인을 적용.kotlin(&quot;plugin.spring&quot;) version kotlinVersion// noarg 확장, @Entity, @Embeddable, @MappedSuperclass 어노테이션에 대해 noarg 플러그인 적용.kotlin(&quot;plugin.jpa&quot;) version kotlinVersion코틀린을 사용하여 스프링과 JPA를 개발할 때 보통 기본적으로 위와 같이 두 플러그인 설정을 하게 됩니다.주석에 달린 설명대로 간단하게 설명할 수 있으며 만약 두 플러그인에 대해 자세히 모르신다면 하며자세한 정보는 아래 두 링크를 참고해주세요. Kotlin Spring Plugin Kotlin JPA Plugin중요한 것은 코틀린으로 JPA의 지연 로딩을 제대로 사용하려면 all open 플러그인의 커스텀이 필요합니다.지연 로딩은 프록시 객체를 만들 수 있어야 하는데 그러려면 엔티티 클래스에 final 키워드가 없어야 합니다.그러나 코틀린의 class와 프로퍼티(필드)는 기본값이 final이기 때문에 open 키워드를 클래스와 필드에사용해주어야 하지만매우 불편한 일이므로 아래와 같이 설정하여 지연 로딩이 가능하게 즉, 프록시 객체 생성이 가능하게 설정할 수 있습니다.allOpen { annotation(&quot;javax.persistence.Entity&quot;) annotation(&quot;javax.persistence.MappedSuperclass&quot;) annotation(&quot;javax.persistence.Embeddable&quot;)}위와 같이 설정하여 @Entity, @MappedSuperclass, @Embeddable을 사용하는 클래스와 프로퍼티를open 시킬 수 있습니다.이렇게 JPA에서 엔티티를 사용할 때 주의해야 할 점을 간단하게 알아봤습니다.감사합니다." }, { "title": "[JPA] 영속성 컨텍스트 (Persistence Context) 특징", "url": "/posts/jpa-persistence-context/", "categories": "JPA", "tags": "jpa, persistence", "date": "2020-01-12 18:26:00 +0900", "snippet": "먼저 JPA란 Java Persistence API의 약자로 자바 ORM 기술에 대한 API 표준 명세이며 대표적인 구현체로는 Hibernate가 있습니다.JPA에서 가장 중요한 개념 중 하나인 영속성 컨텍스트(Persistence Context)의 특징에 대해 함께 알아보겠습니다.특징에는 크게 다섯 가지가 있습니다. 1차 캐시 (First Level Cache) 동일성 보장 (Identify) 쓰기 지연 (Write-behind) 변경 감지 (Dirty Checking) 지연 로딩 (Lazy Loading)본격적으로 들어가기 전에 혹시 아래와 비슷한 코드를 보시거나 작성해보신 적이 있으신가요?// 이런 코드를 보신적이 있나요? fun main(args: Array) { val emf = Persistence.createEntityManagerFactory(&quot;default&quot;) val em = emf.createEntityManager() val tx = em.transaction tx.begin() try { val member = Member().apply { name = &quot;배모군&quot; address = &quot;서울&quot; } em.persist(member) } catch (e: Exception) { e.printStackTrace() tx.rollback() } finally { em.close() } emf.close()}만약 위와 같은 코드를 처음 보신다면 JPA에 대해 더 학습이 필요할 수 있습니다.요즘은 스프링 부트와 Spring Data JPA에서 제공하는 추상화한 Repository를 사용하여 개발을 하는 경우가 많지만실제 구현체는 위와 같은 코드와 비슷하게 작성되어 있습니다.그래서 샘플 코드는 직접 EntityManager를 사용하여 작성하였습니다.프로젝트 구성말씀드린대로 EntityManager를 직접 사용하여 샘플 코드를 작성하였지만 설정의 편의를 위하여Spring Data JPA Starter를 의존성으로 넣고 스프링 부트에서 사용하는 application.yml로 설정 하였습니다.또한 자바가 아닌 코틀린으로 작성하니 참고 바랍니다.// build.gradle.ktsplugins { kotlin(&quot;jvm&quot;) version &quot;1.3.61&quot; kotlin(&quot;plugin.spring&quot;) version &quot;1.3.61&quot; kotlin(&quot;plugin.jpa&quot;) version &quot;1.3.61&quot; id(&quot;org.springframework.boot&quot;) version &quot;2.2.2.RELEASE&quot; idea}apply { plugin(&quot;io.spring.dependency-management&quot;)}allOpen { annotation(&quot;javax.persistence.Entity&quot;) annotation(&quot;javax.persistence.MappedSuperclass&quot;) annotation(&quot;javax.persistence.Embeddable&quot;)}group = &quot;dev.baesangwoo&quot;version = &quot;1.0-SNAPSHOT&quot;repositories { mavenCentral()}dependencies { implementation(kotlin(&quot;stdlib-jdk8&quot;)) implementation(kotlin(&quot;reflect&quot;)) implementation(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;) runtimeOnly(&quot;mysql:mysql-connector-java&quot;) testImplementation(&quot;org.springframework.boot:spring-boot-starter-test&quot;) { exclude(group = &quot;org.junit.vintage&quot;, module = &quot;junit-vintage-engine&quot;) }}tasks { compileKotlin { kotlinOptions { freeCompilerArgs = listOf(&quot;-Xjsr305=strict&quot;) jvmTarget = &quot;1.8&quot; } } compileTestKotlin { kotlinOptions { freeCompilerArgs = listOf(&quot;-Xjsr305=strict&quot;) jvmTarget = &quot;1.8&quot; } } test { useJUnitPlatform() }}# resources/application.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test username: root password: password jpa: properties: dialect: org.hibernate.dialect.MySQL5InnoDBDialect hibernate: format_sql: true use_sql_comments: true hibernate: ddl-auto: create show-sql: truelogging.level.org.hibernate.type.descriptor.sql.BasicBinder: traceEntity 작성1:n 구조를 갖는 Entity 두 가지를 간단히 작성하였습니다.또한 쓰기 지연의 재현을 눈으로 보기 쉽게 @Id 필드에 @GeneratedValue를 선언하지 않았습니다.@Entityclass Team( @Id var id: Long, var name: String)@Entity@Table(name = &quot;MEMBER&quot;)class Member( @Id var id: Long, @ManyToOne(fetch = FetchType.LAZY) var team: Team, var name: String, var address: String)테스트 코드 작성테스트를 위해 JUnit5를 사용하였고 JPA만 테스트하기 위해 @DataJpaTest를 사용 하였습니다.대략적인 구성은 아래와 같습니다.@ExtendWith(SpringExtension::class) // junit5@DataJpaTest@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) // 테스트 데이터베이스를 h2로 변경하지 않음@Rollback(false) // 테스트 후 롤백하지 않음@DisplayName(&quot;영속성 컨텍스트 테스트&quot;)internal class PersistenceContextTest { @PersistenceContext // 기본 엔티티매니저 private lateinit var em: EntityManager @Test @DisplayName(&quot;1차 캐시 테스트&quot;) fun testFirstLevelCache() { // code .. } @Test @DisplayName(&quot;동일성 테스트&quot;) fun testIdentity() { // code .. } @Test @DisplayName(&quot;쓰기 지연 테스트&quot;) fun testWriteBehind() { // code .. } @Test @DisplayName(&quot;변경 감지 테스트&quot;) fun testDirtyChecking() { // code .. } @Test @DisplayName(&quot;지연 로딩 테스트&quot;) fun testLazyLoading() { // code .. }}이제부터 영속성 컨텍스트의 각 특징을 재현과 함께 설명 해보겠습니다. :)1차 캐시 (First Level Cache)영속화된 엔티티를 저장하여 @id값이 같은 엔티티를 찾을 때 직접 DB에 쿼리 실행을 요청하지 않고 엔티티가 저장된 공간에서 가져오게 되는데 이 공간을 1차 캐시라 합니다.@Test@DisplayName(&quot;1차 캐시 테스트&quot;)fun testFirstLevelCache() { val randomNum = (100..200L).random() team = Team( id = randomNum, name = &quot;팀_$randomNum&quot; ) em.persist(team) // select 쿼리가 실행되지 않고 1차 캐시에서 가져옴. em.find(Team::class.java, team.id)}1차 캐시 테스트 결과위 코드를 실행하면 find 구문이 있지만 select 쿼리가 실행되지 않는 것을 확인할 수 있습니다.이미 1차 캐시에 동일한 아이디를 가지고 있는 엔티티가 존재하기때문에 데이터베이스로 쿼리를 요청하지 않고 캐시를 가져옵니다.동일성 보장 (Identity)동일한 @id값으로 검색한 엔티티는 동일성이 보장됩니다.마치 리스트에서 데이터를 가져오듯 @id값이 동일하다면 해당 엔티티의 동일성을 보장해줍니다.즉, 동일한 레퍼런스라는 뜻입니다.@Test@DisplayName(&quot;동일성 테스트&quot;)fun testIdentity() { val randomNum = (100..200L).random() val team = Team( id = randomNum, name = &quot;팀_$randomNum&quot; ) em.persist(team) // select 쿼리가 실행되지 않고 1차 캐시에서 가져옴. val findTeam = em.find(Team::class.java, team.id) // 동등성 (equality) assertEquals(findTeam, team) // 동일성 (identity) assertSame(findTeam, team)}동일성 테스트 결과영속화된 객체를 1차캐시에서 가져와 비교를하면 동등성은 물론이고 동일성까지 보장되어 테스트가 성공하는 것을 볼 수 있습니다.쓰기 지연 (Write-behind)한 트랜잭션안에서 여러번 persist 메소드를 호출하여 DB에 저장을 시도할 때 persist 함수가 호출된 시점이 아닌트렌잭션이 커밋되는 시점에 한 번에 insert 쿼리가 실행되어 네트워크 비용을 줄일 수 있고트랜잭션이 커밋되지 않거나 중간에 의도치 않은 익셉션이 발생하면 트렌잭션이 롤백이되어 DB에 데이터가 반영되지 않습니다.@Test@DisplayName(&quot;쓰기 지연 테스트&quot;)fun testWriteBehind() { println(&quot;========================&quot;) val myTeam = Team( id = 2929494L, name = &quot;쓰기지연팀&quot; ) // 쿼리가 출력문 사이에 찍히지 않고 트랜잭션이 커밋될 때 (메소드 끝) 찍힘 em.persist(myTeam) println(&quot;========================&quot;)}쓰기 지연 테스트 결과코드에서는 출력문 사이에 persist 메소드가 작성되어 있지만 실제 쿼리는 그 뒤에 찍히는 것이 보입니다.정확히는 커밋 시점에 찍히는데 이 테스트에서는 메소드 종료 시점이 커밋 시점입니다.변경 감지 (Dirty Checking)영속화된 엔티티의 값을 변경한다면 다시 persist 메소드를 호출하여 DB에 명령을 보내는 것이 아니라트렌잭션이 커밋되는 시점에 엔티티의 데이터가 변경이 되었다면 update 쿼리 실행을 요청합니다.이는 1차 캐시에 영속화 시점의 스냅샷이 존재하기 때문입니다.@Test@DisplayName(&quot;변경 감지 테스트&quot;)fun testDirtyChecking() { val randomNum = (100..200L).random() val team = Team( id = randomNum, name = &quot;팀_$randomNum&quot; ) em.persist(team) // 프로퍼티의 값을 변경만 하면 종료 전 변경된 사항을 커밋할떄 판단하여 update 쿼리 실행 team.name = &quot;TD&quot;}변경 감지 테스트 결과로그에 보이듯 값을 변경 후 다시 persist 메소드를 호출하지 않아도 업데이트 쿼리가 실행되는 것을 볼 수 있습니다. 영속성 컨텍스트에서 커밋 시점에 스냅샷과 비교하여 변경 사항이 있을 경우에만 업데이트 쿼리를 요청합니다.지연 로딩 (Lazy Loading)@ManyToOne 등 의 엔티티간 연관 관계가 맺어져 있는 엔티티를 검색할 때 연관 관계가 있는 엔티티는프록시 데이터로 채우고 실제로 사용할 때 검색하게 하는 지연 로딩이 되어 불필요한 쿼리를 실행하지 않게 도와 줍니다.필요에 따라서는 연관 관계가 있는 엔티티와 Join 하는 쿼리로 실행시킬 수도 있으나기본적으로는 지연 로딩을 사용하는게 애플리케이션 성능 향상에 도움이 됩니다.@Test@DisplayName(&quot;지연 로딩 테스트&quot;)fun testLazyLoading() { val randomNum = (100..200L).random() val team = Team( id = randomNum, name = &quot;팀_$randomNum&quot; ) val member = Member( id = randomNum, team = team, // n:1 엔티티 주입 name = &quot;배모군_$randomNum&quot;, address = &quot;서울_$randomNum&quot; ) em.persist(team) em.persist(member) // flush를 실행하면 쌓인 쿼리를 실행합니다. em.flush() // clear를 실행하면 영속성 컨텍스트가 가지고 있는 엔티티를 모두 제거합니다. (1차 캐시 정리) em.clear() val findMember = em.find(Member::class.java, member.id) println(&quot;Member에서 Team을 참조하기 전 : ${findMember.address}&quot;) // team을 참조할 때 team select 쿼리가 실행됨 println(&quot;Member에서 Team 참조 : ${findMember.team.name}&quot;)}지연 로딩 테스트 결과Member 엔티티를 조회 후 실제로 Team 엔티티의 값을 사용할 때 Team을 조회하는 쿼리가 실행되는 것을 볼 수 있습니다.단, @ManyToOne 애노테이션에 fetch 조건을 Lazy로 선언해 주셔야 가능합니다.이렇게 간단하게 영속성 컨텍스트의 다섯가지 특징을 간단히 알아봤습니다.애플리케이션의 성능 향상의 방법은 다양하게 존재하지만 JPA를 사용한다면이 다섯 가지 특징을 잘 이해하고 사용하면 좋은 알고리즘 만큼 큰 성능 향상을 느낄 수 있을 것이라고 생각합니다.더불어 JPA를 공부하고 싶은 분들께 누구나 추천하는 이 책을 추천 드리며 이만 마치겠습니다.감사합니다." }, { "title": "[Spring] 스프링 AOP 초간단 예제 (애노테이션 기반)", "url": "/posts/spring-core-bean/", "categories": "Spring, Core", "tags": "spring, aop", "date": "2020-01-04 23:33:00 +0900", "snippet": "Aspect는 어떻게 적용될까요? 출처 : https://stackoverflow.com/questions/29650355/why-in-spring-aop-the-object-are-wrapped-into-a-jdk-proxy-that-implements-interfAOP 란 Aspect Oriented Programming의 약자로 우리말로는 관점 지향 프로그래밍 이라 합니다.관점이라는 말이 어렵게 느껴진다면 관심사에 따라 기능을 분리하여 모듈화하여 개발하는 개념이라고 생각해 볼 수 있습니다.여러 메소드에 비즈니스 로직과 크게 관련이 없는 로직이 중복되어 있을때 사용할 수 있고 모듈화된 해당 기능은 재사용성도 용이해집니다.간단하게 설명했지만 위 그림처럼 복잡하고 다양한 개념과 이론이 존재하고 실무에 적용하려고 하면 꽤나 학습이 필요한 개념입니다.최대한 초보자가 AOP에 입문하는데 도움을 주기 위해 예제 코드는 단순하게 작성하였습니다. (저도 아직 초보자입니다…)함수 실행 여부의 로깅하는 기능을 AOP를 사용한 샘플입니다.예제는 Gradle, 스프링부트, 코틀린 기반으로 작성이 되어있습니다.AOP를 적용하기 위해 의존성을 추가해주어야 하고 테스트 를 위해 스프링부트 2.2에서 테스트 의존성으로 추가된 JUnit5를 사용하겠습니다.로깅이 필요한 함수에 사용할 애노테이션을 추가하고 레벨 지정을 위한 Enum 클래스도 생성하였습니다.애노테이션에 로그 레벨 지정과 로그 메시지를 전달하기 위한 변수를 추가하였고 함수를 호출할 때 마다 애노테이션을 사용해야하기 때문에 리텐션을 런타임으로 주었고함수에 사용할 애노티에션이므로 타켓을 함수로 지정하였습니다.이제 로깅하는 기능을 분리해보겠습니다.해당 기능을 담당하는 클래스를 생성하여 Bean으로 등록하고 AOP에서 관점이라는 개념으로 사용되는 @Asepct 애노테이션을 추가해줍니다.로깅하는 함수 내에 파라미터가 두개 들어가 있는데 ProceedingJoinPoint는 실제 실행될 핵심 함수를 의미하고위에서 생성한 애노테이션의 변수를 사용하여 로깅하기 위해 두번째 파라미터로 넣어줍니다.@Around는 해당 함수의 실행 조건을 지정할 수 있습니다.현재는 애노테이션 기반의 AOP를 구현 중이므로 위에서 생성한 애노테이션을 실행 조건으로 줍니다.단, 이번 예제처럼 함수에 파라미터로 애노테이션을 받았다면 해당 파라미터명으로 적어줍니다.이제 핵심 기능을 개발하고 로깅이 필요하다면 생성한 @LoggerMarker 애노테이션을 달아주고 로그 레벨과 메시지를 지정합니다.핵심 기능은 주문한 메뉴를 가져오는 메소드와 가격을 가져오는 메소드가 있습니다.이제 테스트를 작성하여 서비스 함수를 실행하여 로깅이 되는지 확인해보겠습니다.테스트 실행 결과테스트를 실행하면 위와 같이 지정한 로그 레벨과 메시지가 정상적으로 실행되는 것을 볼 수 있습니다.이렇게 Aspect의 @Around 조건으로 애노테이션을 사용한 단순한 스프링 AOP를 간단하게 구현해 보았습니다.AOP에서 사용되는 여러 용어와 다양한 구현 방식이 존재하므로 위에서 말씀드린대로 많은 학습이 필요한 개념입니다.이 단순한 예제로 AOP를 이해하는데 조금이나마 도움이 되었길 바랍니다.읽어주셔서 감사합니다 :)" }, { "title": "[Spring] 스프링프레임워크 Bean 등록과 사용의 변천사", "url": "/posts/spring-core-aop/", "categories": "Spring, Core", "tags": "spring, bean", "date": "2020-01-02 23:37:00 +0900", "snippet": "요즘엔 스프링 부트를 주로 사용하기 때문에 XML로 스프링 어플리케이션을 설정할 일이 전혀 없지만스프링을 처음으로 접하는 개발자에게 간단하게나마 설명을 하기 위해 간단히 샘플 코드를 작성해 보았습니다.샘플 코드가 코틀린 기반이라 자바 기반 코드와 조금 다른 점이 있으니 참고하시게 되면 주의해주시기 바랍니다.XML 설정으로 Bean 등록과 사용초창기 사용 방법으로 일일히 빈을 등록하는 XML 설정에 등록할 빈을 정의합니다.클래스를 생성할 때 마다 빈으로 등록하기 위한 XML 작업이 많아지는 불편함이 있고 IDE 기능이 없다면 매우 사용하기 어렵습니다.resources/application-context.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt; &amp;lt;!-- Bean 등록 (id: Bean 이름, class: Bean으로 등록할 클래스의 풀패키지 경로 --&amp;gt; &amp;lt;bean id=&quot;teamService&quot; class=&quot;com.baegoon.lunchstudy.DefaultTeamService&quot;/&amp;gt; &amp;lt;bean id=&quot;memberService&quot; class=&quot;com.baegoon.lunchstudy.DefaultMemberService&quot;&amp;gt; &amp;lt;!-- 생성자로 받는 Bean 주입 --&amp;gt; &amp;lt;constructor-arg name=&quot;teamService&quot; ref=&quot;teamService&quot;/&amp;gt; &amp;lt;/bean&amp;gt;&amp;lt;/beans&amp;gt;Application.kt/** * 메인 메소드 */fun main(args: Array&amp;lt;String&amp;gt;) { // 작성한 XML 설정을 Application Context로 사용 val context: ApplicationContext = ClassPathXmlApplicationContext(&quot;application-context.xml&quot;) // 팀 서비스 Bean 호출 val teamService = context.getBean(&quot;teamService&quot;) as TeamService println(teamService.getTeam()) // 멤버 서비스 Bean 호출 val memberService = context.getBean(&quot;memberService&quot;, MemberService::class.java) println(memberService.getMember())}/** * 팀 서비스 인터페이스 */interface TeamService { fun getTeam(): String}/** * 팀 서비스 구현체 */class DefaultTeamService : TeamService { override fun getTeam(): String { return &quot;테크컨버전스팀&quot; }}/** * 멤버 서비스 인터페이스 */interface MemberService { fun getMember(): String}/** * 멤버 서비스 구현체 * @property TeamService teamService 팀 서비스 빈 주입 */class DefaultMemberService(private val teamService: TeamService) : MemberService { override fun getMember(): String { return &quot;${teamService.getTeam()} 배상우&quot; }}XML 설정으로 패키지를 검색하여 Bean 등록과 사용스프링 2.5 부터 제공된 방식으로 XML 설정이 간단해지고 이 때부터 애노테이션 기반으로 Bean을 생성 합니다.위 방법 보단 조금 나아진 방법이지만 현재는 사용하지 않습니다.resources/application-context.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt; &amp;lt;!-- com.baegoon.lunchstudy 패키지부터 모든 빈을 스캔 --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.baegoon.lunchstudy&quot;/&amp;gt;&amp;lt;/beans&amp;gt;Application.kt/** * 메인 메소드 */fun main(args: Array&amp;lt;String&amp;gt;) { // 작성한 XML 설정을 Application Context로 사용 val context: ApplicationContext = ClassPathXmlApplicationContext(&quot;application-context.xml&quot;) // 팀 서비스 Bean 호출 val teamService = context.getBean(&quot;defaultTeamService&quot;) as TeamService println(teamService.getTeam()) // 멤버 서비스 Bean 호출 val memberService = context.getBean(&quot;defaultMemberService&quot;, MemberService::class.java) println(memberService.getMember())}/** * 팀 서비스 인터페이스 */interface TeamService { fun getTeam(): String}/** * 팀 서비스 구현체 */@Service // 애노테이션으로 Bean 명시class DefaultTeamService : TeamService { override fun getTeam(): String { return &quot;테크컨버전스팀&quot; }}/** * 멤버 서비스 인터페이스 */interface MemberService { fun getMember(): String}/** * 멤버 서비스 구현체 * @property TeamService teamService 팀 서비스 빈 주입 */@Service // 애노테이션으로 Bean 명시class DefaultMemberService(private val teamService: TeamService) : MemberService { override fun getMember(): String { return &quot;${teamService.getTeam()} 배상우&quot; }}Configuration Class로 Bean 등록과 사용 (Java Config)1번의 발전된 방법으로 XML 설정없이 클래스 파일로 설정을 만들어서 빈을 등록하고 사용할 수 있습니다.코틀린 없던 시절 Java Config 라고 많이 불렸습니다.단, 1번과 동일한 문제인 빈을 일일히 등록해줘야하는 번거로움이 존재합니다.Application.kt/** * 메인 메소드 */fun main(args: Array&amp;lt;String&amp;gt;) { // 작성한 Configuration 클래스를 Application Context로 사용 val context: ApplicationContext = AnnotationConfigApplicationContext(ApplicationConfiguration::class.java) // 팀 서비스 Bean 호출 val teamService = context.getBean(&quot;teamService&quot;) as TeamService println(teamService.getTeam()) // 멤버 서비스 Bean 호출 val memberService = context.getBean(&quot;memberService&quot;, MemberService::class.java) println(memberService.getMember())}/** * 팀 서비스 인터페이스 */interface TeamService { fun getTeam(): String}/** * 팀 서비스 구현체 */class DefaultTeamService : TeamService { override fun getTeam(): String { return &quot;테크컨버전스팀&quot; }}/** * 멤버 서비스 인터페이스 */interface MemberService { fun getMember(): String}/** * 멤버 서비스 구현체 * @property TeamService teamService 팀 서비스 빈 주입 */class DefaultMemberService(private val teamService: TeamService) : MemberService { override fun getMember(): String { return &quot;${teamService.getTeam()} 배상우&quot; }}/** * Bean 설정 클래스 */@Configuration // 설정 클래스임을 의미class ApplicationConfiguration { /** * 팀 서비스 Bean 등록 * 함수명이 Bean 이름임 */ @Bean fun teamService(): TeamService { return DefaultTeamService() } /** * 멤버 서비스 Bean 등록 * 함수명이 Bean 이름임 * @param teamService [TeamService] 팀 서비스 Bean 주입 */ @Bean fun memberService(teamService: TeamService): MemberService { return DefaultMemberService(teamService) }}Configuration Class로 패키지를 검색하여 Bean 등록과 사용설정 클래스에 @ComponentScan 이라는 애노테이션을 붙이고 basePackagesClass 옵션을 주어 Bean을 스캔하고 등록 합니다.2번의 발전된 방식으로 매우 간편해졌습다.1, 2번 처럼 XML로 작성하여 Type-safety 하지 못하거나 불편함이 없고 3번 처럼 일일히 Bean을 등록하는 코드가 들어갈 필요 없이 매우 간결합니다.스프링 부트가 나오기 직전까지 사용되던 방식입니다.Application.kt/** * 메인 메소드 */fun main(args: Array&amp;lt;String&amp;gt;) { // 작성한 Configuration 클래스를 Application Context로 사용 val context: ApplicationContext = AnnotationConfigApplicationContext(ApplicationConfiguration::class.java) // 팀 서비스 Bean 호출 val teamService = context.getBean(&quot;teamService&quot;) as TeamService println(teamService.getTeam()) // 멤버 서비스 Bean 호출 val memberService = context.getBean(&quot;memberService&quot;, MemberService::class.java) println(memberService.getMember())}/** * 팀 서비스 인터페이스 */interface TeamService { fun getTeam(): String}/** * 팀 서비스 구현체 */@Service(&quot;teamService&quot;) // teamService로 Bean 이름 지정class DefaultTeamService : TeamService { override fun getTeam(): String { return &quot;테크컨버전스팀&quot; }}/** * 멤버 서비스 인터페이스 */interface MemberService { fun getMember(): String}/** * 멤버 서비스 구현체 * @property TeamService teamService 팀 서비스 빈 주입 */@Service(&quot;memberService&quot;)class DefaultMemberService(private val teamService: TeamService) : MemberService { override fun getMember(): String { return &quot;${teamService.getTeam()} 배상우&quot; }}/** * Bean 설정 클래스 */@Configuration // 애노테이션이 붙어있으면 설정 클래스임을 의미@ComponentScan(basePackageClasses = [LunchStudyApplication::class]) // 애노테이션을 사용하여 Bean을 검색할 패키지를 지정class ApplicationConfiguration스프링 부트 등장!선 코드!Application.kt/** * 스프링 부트 어플리케이션 */@SpringBootApplicationclass LunchStudyApplication/** * 메인 메소드 */fun main(args: Array&amp;lt;String&amp;gt;) { // 스프링 부트 어플리케이션 실행 runApplication&amp;lt;LunchStudyApplication&amp;gt;(*args)}/** * 팀 서비스 인터페이스 */interface TeamService { fun getTeam(): String}/** * 팀 서비스 구현체 */@Serviceclass DefaultTeamService : TeamService { override fun getTeam(): String { return &quot;테크컨버전스팀&quot; }}/** * 멤버 서비스 인터페이스 */interface MemberService { fun getMember(): String}/** * 멤버 서비스 구현체 * @property TeamService teamService 팀 서비스 빈 주입 */@Serviceclass DefaultMemberService(private val teamService: TeamService) : MemberService { override fun getMember(): String { return &quot;${teamService.getTeam()} 배상우&quot; }}스프링 부트가 자동 설정 기능을 제공하여 Bean을 등록하고 사용하는데 획기적인 변화가 있었습니다.메인 어플리케이션 클래스에 있는 @SpringBootApplication 애노테이션이 핵심적인 역할을 하는데@SpringBootApplication 애노테이션 자체가 @Configuration과 @ComponentScan 애노테이션을 모두 포함하기 때문에 가능한 일입니다.물론 더 많은 일들을 하고 있으니 레퍼런스를 참고해보시면 좋습니다." } ]
