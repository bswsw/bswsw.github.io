---
title: 08장. 분산 시스템의 골칫거리
author: Bae Sangwoo
date: 2025-02-09 13:00:00 +0900
categories: [ Study, 데이터 중심 어플리케이션 설계 ]
tags: [ study, data, design, architecture ]
image:
  src: https://wikibook.co.kr/images/cover/l/9791158393601.jpg
---


> 어떤 것이든지 잘못될 가능성이 있다면 잘못된다.

## 0. 분산 시스템의 골칫거리

- 분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다르다.
- 엔지니어로서의 우리의 임무는 모든게 잘못되더라도 사용자가 기대하는 보장을 만족시키는 제 역할을 해내는 시스템을 구축하는 것이다.

## 1. 결함과 부분 장애

- 컴퓨터에 내부 결함이 발생하면 잘못된 결과를 반환하기보다는 완전히 동작하지 않기를 원한다.
- 단일 컴퓨터 기준
  - 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다. (결정적이다.)
  - 하드웨어 문제가 있으면 보통 시스템이 완전히 실패하는 결과를 낳는다.
- 분산 시스템 기준
  - 네트워크 문제, 부분적인 실패, 타이밍 문제 등 다양한 문제가 발생할 수 있다.
  - 부분 장애는 비결정적이다.
  - 이러한 문제들은 예측하기 어렵고, 디버깅하기도 어렵다.

### 1.1. 클라우드 컴퓨팅과 슈퍼컴퓨팅

- 슈퍼 컴퓨팅
  - 슈퍼컴퓨터에서 실행되는 작업은 보통 가끔씩 계산 상태를 지속성 있는 저장소에 체크포인트로 저장한다.
  - 노드 하나에 장애가 발생했을 때 흔한 해결책은 그냥 전체 클러스터 작업부하를 중단하는 것이다.
  - 슈퍼컴퓨터는 부분 장애를 전체 장애로 확대하는 방법으로 처리하는데 시스템의 어느 부분에 장애가 발생하면 그냥 전체가 죽게 한다.
- **분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다.**
- 올바르게 동작하던 시스템도 시간이 지나면 어떤 부분에 결함이 생길 것이고 소프트웨어는 어떤 식으로든 그 결함을 처리해야 한다.

## 2. 신뢰성 없는 네트워크

- 분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비다.
- 인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크다.
- 노드는 다른 노드로 패킷을 보낼 수 있지만 도착을 보장하지 않고 요청을 보내고 응답을 기다리는 사이에 여러 잘못이 생길 수 있다.
- 이런 문제를 다루는 가장 흔한 방법은 타임아웃이다.

### 2.1. 현실의 네트워크 결함

- 네트워크 문제는 놀랄 만큼 흔하다.
- 중간 규모의 데이터센터에서 매달 12번의 네트워크 결함이 발생함을 발견했다.
- EC2 같은 공개 클라우드 서비스는 일시적으로 네트워크 결함이 자주 발생하는 것으로 알려져 있다.
- 소프트웨어는 예측하지 못하는 상황이지만 네트워크 결함을 반드시 견뎌내도록 처리할 필요는 없다.
- 네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야 한다.
- 고의로 네트워크 문제를 유발하여 시스템의 반응을 테스트해보는 것도 좋다. (카오스 몽키)

### 2.2. 결함 감지

- 결함을 자동으로 감지할 수 있어야 한다.
- 네트워크는 불확실성이 있기 때문에 노드가 동작 중인지 아닌지 구별하기 어렵다.
- TCP가 패킷이 전달됐다는 확인 응답을 했더라도 애플리케이션이 그것을 처리하기 전에 죽을 수도 있다.
- 요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.

### 2.3. 타임아웃과 기약 없는 지연

- 타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다.
- 타임아웃이 짧으면 결함을 빨리 발견하지만 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아진다.
- 빠른 타임아웃은 다른 노드로 역할을 넘겨주게 되고 해당 요청이 중복되어 실행될 수도 있다.
- 역할이 다른 노드로 전달되어 다른 노드와 네트워크에 추가적인 부하를 준다.
- 비동기 네트워크는 기약 없는 지연(unbounded delay)이 있다.

#### 2.3.1. 네트워크 혼잡과 큐 대기

- 네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을 때까지 잠시 기다려야할 수도 있는데 이를 네트워크 혼잡(Network Congestion)이라고 부른다.
- 패킷이 목적지에 도착했을 때 모든 CPU가 바쁜 상태라면 운영체제 큐에 넣어둔다.
- TCP는 혼잡 회피, 배압이라고 하는 흐름 제어를 수행하여 데이터가 네트워크로 들어가기 전에 송신을 제어하는 부가적인 큐 대기를 할 수 있다.
- TCP는 타임아웃이 발생하면 손실로 간주하고 자동으로 재전송하는데 애플리케이션에서는 패킷의 손실과 재전송이 보이지 않지만 지연은 확인할 수 있다.
- 다양한 요인으로 네트워크 지연의 변동성에 영향을 준다.
- 이런 환경에서는 실험적으로 타임아웃을 선택하는 수 밖에 없다.
- 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 그들의 변동성을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 하는 방법이 있다.

### 2.4. 동기 네트워크 대 비동기 네트워크

- 전화 통화는 회선(circuit)을 만들어 고정되고 보장된 양의 대역폭이 할당된다. (동기식 네트워크)
- 큐 대기가 없으므로 네트어워크 종단 지연 시간의 최대치가 고정돼 있다. - 제한 있는 지연 (bounded delay)
- TCP 연결의 패킷은 가용한 네트워크 대역폭을 기회주의적으로 사용한다. (비동기식 네트워크)
- 웹 페이지 요청, 이메일/파일 전송 처럼 순간적으로 몰리는 트래픽의 경우 TCP 패킷 교환이 적절하다.
- 네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 것이라고 가정하고 타임아웃의 올바른 값은 실험을 통해 결정해야 한다.

## 3. 신뢰성 없는 시계

- 분산 시스템에서는 통신이 즉각적이지 않으므로 시간을 다루기 까다롭다.
- 메시지가 네트워크를 거쳐 전달되는 데 시간이 걸리고 네트워크의 지연 변동성 때문에 얼마나 거릴지 알 수 없다.
- 개별 장비는 수정 발진기(quartz oscillator)라는 시계를 갖고 있지만 다른 장비와 차이가 있을 수 있다.
- 네트워크 시간 프로토콜(NTP) 메커니즘으로 서버 그룹 내에 시계를 조정할 수 있게 한다.
- GPS로 더 정확한 시간을 동기화시킬 수 있다.

### 3.1. 단조 시계 대 일 기준 시계

- 일 기준 시계(Wall-Clock Time)
  - 모두가 같이 보는 벽 시계
  - created_at 기록에 적합하다.
- 단조 시계(Monotonic Clock vs)
  - 나 혼자 보는 손목 시계
  - elapsed_time 측정에 적합하다.
- [리눅스 서버 ntp 동기화 설정](https://blog.naver.com/anysecure3/222646997574){:target="_blank" rel="noopener"}

#### 3.1.1. 일 기준 시계

- 일 기준 시계는 직관적으로 시계에 기대하는 일을 한다.
- 어떤 달력에 따라 현재 날짜와 시간을 변환한다.
  - 리눅스: clock_gettime(CLOCK_REALTIME)
  - 자바: System.currentTimeMillis()
  - 에포크(epoch)부터 흐른 초(or 밀리초) 수를 반환한다. (에포크: 1970년 1월 1일 0시 0분 0초 - UTC)
- 일 기준 시계는 보통 NTP로 동기화되어 한 장비의 타임스탬프는 다른 장비의 타임스탬프와 동일한 의미를 지닌다는 뜻이다.
- 로컬 시계가 NTP 서버보다 너무 앞서면 강제 리셋되어 과거 시점으로 거구로 뛰는 것처럼 보일 수 있다.

#### 3.1.2. 단조 시계

- 단조 시계는 타임아웃이나 서비스 응답 시간 같은 지속 시간(시간 구간)을 재는 데 적합하다.
  - 리눅스: clock_gettime(CLOCK_MONOTONIC)
  - 자바: System.nanoTime()
- 두 시점의 단조 시계 값을 확인하여 두 값 사이의 차이로 시간이 얼마나 흘렀는지 알 수 있다.
- 그러나 시계의 절대적인 값은 의미가 없다.
- 컴퓨터가 시작한 이래 흐른 나노초 수일 수도 있고 비슷한 어떤 것일 수도 있다.
- 두 대의 다른 컴퓨터에서 나온 단조 시계 값은 동일한 것을 의미하지 않기 때문에 이 둘을 비교하는 것은 의미가 없다.
- 여러 개의 CPU 소켓이 있는 서버는 CPU마다 독립된 타이머가 있을 수 있다.
  - 운영체제는 차이를 보정하여 스레드가 여러 CPU에 걸쳐 스케쥴링 되더라도 시계가 단조적으로 보이게 하려고 한다.
  - 단조성 보장은 곧이 곧대로 받아들이지 않는게 현명하다.
- 단조 시계의 해상도는 좋은 편이기 때문에 마이크로초나 그 이하 단위로 측정할 수 있다.
- 분산 시스템의 경과 시간을 재는데 단조 시계를 쓰는 것은 측정이 약간 부정확해도 민감하지 않기 때문에 일반적으로 괜찮다.

### 3.2. 시계 동기화와 정확도

- 단조 시계는 동기화가 필요 없지만 일 기준 시계는 NTP 서버나 다른 외부 시간 출처에 맞춰 설정돼야 유용하다.
- 하드웨어 시계와 NTP는 생각보다 정확하지 않다.
  - 컴퓨터의 수정 시계는 장비 온도에 따라 더 빠르거나 느리게 실행되는 드리프트 현상이 생긴다.
  - 컴퓨터 시계와 NTP 서버와 차이가 심하면 동기화가 거부되거나 강제로 리셋될 수 있다.
  - 방화벽으로 NTP 서버가 차단되어 잘못된 설정이 얼마동안 알려지지 않을 수 있다.
  - NTP 동기화는 잘해야 네트워크 지연만큼만 좋을 수 있다. (최소 오차 35ms)
  - 어떤 NTP 서버들은 이상이 잇거나 설정이 잘못돼서 몇 시간 정도 차이 나는 시간을 보고하고 있다.
  - 윤초가 발생하면 1분이 길이가 59-61초가 되어 윤초를 고려하지 않고 설계된 시스템에서는 시간에 관한 가정이 엉망이 돼 버린다.
  - 가상 장비에서 하드웨어 시계는 가상화돼서 정확한 시간 엄수가 필요한 애플리케이션에게 추가적인 어려움이 생긴다.
  - 완전히 제어할 수 없는 장치에서 소프트웨어를 실행하면 아마도 그 장치의 하드웨어 시계를 전혀 믿을 수 없을 것이다.
- 유럽 금융 규제 기관 초안은 고빈도 트레이딩 펀드는 모두 그들의 시계를 UTC와 100마이크로초 이내 동기화를 요구한다.
  - GPS, 정밀 시간 프로토콜(PTP), 세심한 배포와 모니터링
  - 상당한 노력과 전문 기술이 필요하며 시계 동기화가 잘못될 수 있는 수많은 가능성이 존재한다.
    - 잘못된 NTP 대몬 설정, 방화벽 NTP 트래픽 차단 등

### 3.3. 동기화된 시계에 의존하기

- 하루는 정확히 86400초가 아닐 수도 있고, 일 기준 시계가 거꾸로 갈 수도 있으며, 노드 간 시간 차이가 많이 날 수도 있다.
- 소프트웨어는 네트워크 결함을 가정해서 설계돼야하며 시계도 마찬가지로 고려 대상이다.
- 견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다.
- 시계가 잘못된다는 것을 눈치채기 어렵다.
- 동기화된 시계가 필요한 소프트웨어를 사용한다면 모든 장비 사이의 시계 차이를 모니터링해야 한다.
- 시계 차이가 큰 노드는 죽은 것으로 간주하고 클러스터에서 제거돼야 한다.

#### 3.3.1. 이벤트 순서화용 타임스탬프

- 그림 8-3 다중 리더 복제를 쓰는 데이터베이스에서 일 기준 시간을 위험하게 사용하는 예 - 291p
  - 노드 간 시계 차이로 데이터 수정의 순서가 변경될 수 있다.
- 최종 쓰기 승리 (last write win, LWW) 전략으로 충돌을 해소할 수 있고 다중 리더 복제, 리더 없는 데이터베이스에서 널리 사용된다.
- 타임스탬프를 서버가 아니라 클라이언트에서 생성하는 구현도 있지만 LWW에 존재하는 근본적은 문제를 바꾸지는 못한다.
  - 시계가 뒤처지는 노드는 시계가 빠른 노드가 먼저 쓴 내용을 그들 사이에 차이나는 시간이 흐를 때까지 덮어쓸 수 없기 때문에 데이터베이스 쓰기가 사라질 수 있다.
  - 순차적인 쓰기가 빠른 시간 내에 연속으로 실행되는 것과 진짜 동시에 쓰기가 실행되는 것을 구별할 수 없다.
  - 두 노드가 독립적으로 동일한 타임스탬프를 가진 쓰기 작업을 만들 수도 있다.
- 가장 최근 값을 유지하고 다른 것들을 버림으로써 충돌을 해소하고 싶더라도 최근의 정의는 로컬 일 기준 시게에 의존하며 그 시게는 틀릴 수도 있다는 것을 아는게 중요하다.
- 잘못된 순서화가 발생하지 않을 정도로 NTP 동기화를 정확하게 하기는 거의 불가능하다.
- 올바른 순서화를 위해서는 시계 출처가 측정하려고 하는 대상(네트워크 지연)보다 훨씬 더 정확해야한다.
  - 논리적 시계 (logical clock)
    - 진동 수정 대신 증가하는 카운터 기반
    - 일 기준, 경과한 초 수를 측정하지 않고 이벤트의 상대적인 순서만 측정
  - 물리적 시계 (physical clock)
    - 일 기준 시계와 단조 시계는 실제 경과 시간을 측정
    - 순서화 보장 336p

#### 3.3.2. 시계 읽기는 신뢰 구간이 있다

- 시계 읽기를 어떤 시점으로 생각하는 것보다 어떤 신뢰 구간에 속하는 시간의 범위로 생각하는 것이 좋다.
  - 장비의 일 기준 시계를 마이크로초, 나노초 해상도로 읽을 수 있지만 그 값이 그런 정밀성을 제공할 만큼 정확하지 않다.
  - 로컬 네트워크에 있는 NTP 서버와 매분 동기화하더라도 부정확한 수정 시계에서 발생하는 드리프트는 쉽게 몇 ms가 될 수 있다.
  - 공개 인터넷 NTP 서버를 사용하면 달성 가능한 최선의 정확도는 아마 수십 ms 정도이고 네트워크가 혼잡하다면 100ms 이상이 될 수 있다.
- 불확실성 경계는 시간 출처를 기반으로 계산할 수 있다.
  - GPS, 컴퓨터의 원자 시계: 제조사에서 제공하는 예상 오류 범위
  - NTP 서버: 마지막 동기화 시간 이후로 예상되는 시간 드리프트 + NTP 서버의 불확실성 + 네트워크 왕복 시간
  - clock_gettime()을 호출하더라도 예상 오차를 알려주지는 않는다.
  - 스패너의 구글 트루타임 API는 로컬 시계의 신뢰 구간을 명시적으로 보여준다.
  - [구글 스패너](https://cloud.google.com/spanner?hl=ko#features){:target="_blank" rel="noopener"}

#### 3.3.3. 전역 스냅숏용 동기화된 시계

- 스냅숏 격리는 작고 빠른 읽기 쓰기 트랜잭션과 크고 오래 실행되는 읽기 전용 트랜잭션 모두를 지원해야 하는 데이터베이스에서 아주 유용한 기능이다.
- 가장 흔한 스냅숏 격리 구현은 단조 증가하는 트랜잭션 ID가 필요하다.
- 스냅숏보다 나중에 쓰기가 실행됐다면 그 내용은 스냅숏 트랜잭션에게 보이지 않는다.
- 단일 노드 데이터베이스에서는 단순한 카운터가 트랜잭션 ID를 생성하는데 충분하다.
- 분산 데이터베이스는 코디네이션이 필요하다.
- 분산 시스템에서 작고 빠른 트랜잭션이 많으면 트랜잭션 ID 생성은 방어할 수 없는 병목이 된다.
- 구글 스패너 예시
  - 트루타임 API의 시계 신뢰 구간을 사용하여 신뢰 구간이 겹치지 않는다면 트랜잭션의 우선 순위를 보장할 수 있다.
    - A-earliest < A-latest < B-earliest < A-earliest
  - 트랜잭션 타임스탬프가 인과성을 반영하는 것을 보장하기 위해 읽기 쓰기 트랜잭션을 커밋하기 전에 의도적으로 신뢰 구간의 길이만큼 기다린다.
  - 그 데이터를 읽을지도 모르는 트랜잭션은 충분히 나중에 실행되는 게 보장되므로 신뢰 구간이 겹치지 않는다.
  - 시계 불확실성을 가능하면 작게 유지해야하기 때문에 각 데이터센터에 GPS 수신기나 원자 시계를 배치해서 약 7ms 이내로 동기화되게 한다.

### 3.4. 프로세스 중단

- 분산 시스템에서 리더가 안전하게 쓰기를 받을 수 있는 임차권(lease) 예제 - 295p
- 프로그램 실행 중에 예상치 못한 중단이 있어서 오랫동안 요청이 오랫동안 멈춰있다면 이미 임차권이 만료되어 다른 노드가 리더 역할을 맡고 있을 수 있다.
- 단일 장비에서는 뮤텍스, 세마포어, 원자적 카운터, 락프리, 블로킹 큐 등 다양한 스레드 안전 기법을 사용할 수 있지만 분산 시스템에서는 불가능 하다.
- 분산 시스템의 노드는 어느 시점에 실행이 상당히 멈출 수 있다고 가정해야 하고 심지어 함수 중간에 멈출 수도 있다.

#### 3.4.1. 응답 시간 보장

- 명시된 시간안에 응답하는 데 실패하면 심각한 손상을 유발할 수 있는 환경에서 실행되는 소프트웨어는 데드라인이 명시된다.
- 프로세스가 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케쥴링 해주는 실시간 운영체제가 필요하다.
- 라이브러리 함수는 최악의 실행 시간을 문서화해야 한다.
- 동적 메모리 할당은 제한되거나 완전히 금지될 수 있다.
- 보장 만족의 확신을 위해 막대한 양의 테스트와 측정을 해야 한다.
- 프로그래밍 언어, 라이브러리, 도구의 범위를 엄격하게 제한한다.
- 안전이 필수적인 임베디드 장치에서 가장 흔하게 사용된다.
- 실시간 시스템은 무엇보다도 제때에 응답하는 것을 우선시해야 하므로 처리량이 더 낮을 수도 있다. (실시간은 고성능과 동일하지 않다.)

#### 3.4.2. 가비지 컬렉션의 영향을 제한하기

- 언어 런타임은 객체 할당률과 시간에 따라 남아 있는 여유 메모리 공간을 추적할 수 있으므로 언제 GC 할지와 관련된 어느정도 유연성을 갖고 있다.
- GC 중단을 노드가 잠시 동안 계획적으로 중단되는 것으로 간주하고 노드가 GC 하는 동안 클라이언트 요청을 다른 노드들이 처리하게 한다.
- 런타임이 애플리케이션에게 노드가 곧 GC 중단이 필요하다는 경고를 할 수 있다면 애플리케이션은 그 노드로 새로운 요청을 멈추고, 그 노드가 요청 처리를 완료한 후 아무 요청도 처리 하지 않는 동안 GC를
  실행하기를 기다릴 수 있다.
- GC를 클라이언트로부터 감추고 응답 시간의 상위 백분위를 줄여준다.
- 지연 시간에 민감한 금융 거래 시스템 중에 이 방법을 쓰는 것도 있다.
- 수명이 짧은 객체만 GC를 사용하고 수명이 긴 객체의 전체 GC가 필요할 만큼 객체가 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법도 있다.
- GC 중단을 완전히 막을 수는 없지만 애플리케이션에 미치는 영향은 유용하게 줄일 수 있다.

## 4. 지식, 진실, 그리고 거짓말

### 4.1. 진실은 다수결로 결정된다

### 4.2. 비잔틴 결함

### 4.3. 시스템 모델과 현실
